"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationBinaryService = void 0;
const core_1 = require("../core");
const form_data_1 = __importDefault(require("form-data"));
class ApplicationBinaryService extends core_1.Service {
    constructor(client, applicationOrId) {
        super(client);
        this.listUrl = 'binaries';
        this.propertyName = 'attachments';
        this.baseUrl = `application/applications/${this.getIdString(applicationOrId)}`;
    }
    async upload(binary, fileName, uploadParamsOverride) {
        const url = uploadParamsOverride?.listUrl || this.listUrl;
        const method = 'POST';
        const body = this.createBinaryRequestBody(binary, fileName, uploadParamsOverride);
        let bodyHeaders;
        if (typeof body.getHeaders === 'function') {
            bodyHeaders = body.getHeaders();
        }
        const headers = Object.assign(uploadParamsOverride?.headers || {
            Accept: 'application/json'
        }, bodyHeaders);
        const res = await this.fetch(url, { method, body, headers });
        const data = await res.json();
        return { res, data };
    }
    uploadWithProgressXhr(binary, onProgress, fileName, uploadParamsOverride) {
        const url = `/${this.baseUrl}/${uploadParamsOverride?.listUrl || this.listUrl}`;
        const method = 'POST';
        const body = this.createBinaryRequestBody(binary, fileName, uploadParamsOverride);
        let bodyHeaders;
        if (typeof body.getHeaders === 'function') {
            bodyHeaders = body.getHeaders();
        }
        const headers = this.client.getFetchOptions().headers;
        Object.assign(headers, uploadParamsOverride?.headers || {
            Accept: 'application/json'
        });
        Object.assign(headers, bodyHeaders);
        const xhr = new XMLHttpRequest();
        xhr.open(method, url, true);
        for (const key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
        xhr.upload.addEventListener('progress', onProgress);
        xhr.send(body);
        return xhr;
    }
    getXMLHttpResponse(xhr) {
        return new Promise((res, rej) => {
            xhr.addEventListener('loadend', () => {
                xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 201)
                    ? res(JSON.parse(xhr.responseText))
                    : rej(xhr.responseText ? { data: JSON.parse(xhr.responseText) } : 'Could not upload file.');
            });
        });
    }
    async list(filter) {
        return super.list(filter);
    }
    async delete(binaryOrId) {
        return super.delete(binaryOrId);
    }
    async listPlugins() {
        const headers = { accept: 'application/json' };
        const url = `${this.listUrl}/plugins`;
        const res = await this.fetch(url, { headers });
        const data = await res.json();
        return { res, data };
    }
    async addPlugin(pluginName, pluginFile) {
        const url = `${this.listUrl}/plugins/${encodeURIComponent(pluginName)}`;
        const method = 'POST';
        const body = new form_data_1.default();
        const bufferOrStream = pluginFile instanceof ArrayBuffer ? Buffer.from(pluginFile) : pluginFile;
        body.append('file', bufferOrStream);
        let bodyHeaders;
        if (typeof body.getHeaders === 'function') {
            bodyHeaders = body.getHeaders();
        }
        const headers = Object.assign({
            accept: 'application/json'
        }, bodyHeaders);
        const res = await this.fetch(url, { method, body, headers });
        const data = await res.json();
        return { res, data };
    }
    async removePlugin(pluginName) {
        const method = 'DELETE';
        const headers = { accept: 'application/json' };
        const url = `${this.listUrl}/plugins/${pluginName}`;
        const res = await this.fetch(url, { method, headers });
        const data = await res.json();
        return { res, data };
    }
    async updateFiles(files) {
        const url = `${this.listUrl}/files`;
        const method = 'POST';
        const body = new form_data_1.default();
        files.forEach(file => {
            const bufferOrStream = file.contents instanceof ArrayBuffer ? Buffer.from(file.contents) : file.contents;
            body.append(file.path, bufferOrStream);
        });
        let bodyHeaders;
        if (typeof body.getHeaders === 'function') {
            bodyHeaders = body.getHeaders();
        }
        const headers = Object.assign({
            accept: 'application/json'
        }, bodyHeaders);
        const res = await this.fetch(url, { method, body, headers });
        const data = await res.json();
        return { res, data };
    }
    async downloadArchive(binaryId) {
        const url = `${this.listUrl}/${binaryId}`;
        return await this.fetch(url);
    }
    createBinaryRequestBody(binary, fileName, uploadParamsOverride) {
        const body = new form_data_1.default();
        const bufferOrStream = binary instanceof ArrayBuffer ? Buffer.from(binary) : binary;
        let uploadFileName = fileName;
        if (typeof File !== 'undefined' && binary instanceof File) {
            uploadFileName = binary.name;
        }
        body.append(uploadParamsOverride?.bodyFileProperty || 'file', bufferOrStream, uploadFileName);
        body.append('fileName', uploadFileName);
        if (uploadParamsOverride?.requestBody) {
            for (const key in uploadParamsOverride.requestBody) {
                if (uploadParamsOverride.requestBody.hasOwnProperty(key)) {
                    body.append(key, JSON.stringify(uploadParamsOverride.requestBody[key]));
                }
            }
        }
        return body;
    }
}
exports.ApplicationBinaryService = ApplicationBinaryService;
//# sourceMappingURL=ApplicationBinaryService.js.map