"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Paging = void 0;
/**
 * Paging allows you to query the next and previous data chunks
 * in a convenient way. You can also go to a specific page or just read
 * page information about the current data chunk.
 * Note that page numbers are generated by backend
 * and may be used as offset rather than a continuous range of positive numbers
 * (e.g. in case of users with restricted permissions).
 */
class Paging {
    constructor(service, statistics, filter) {
        this.filter = filter;
        this.service = service;
        this.currentPage = statistics.currentPage;
        this.nextPage = statistics.nextPage;
        this.prevPage = statistics.prevPage;
        this.pageSize = statistics.pageSize;
        this.totalPages = statistics.totalPages;
    }
    /**
     * Gets the next page of available data from the server.
     * @param filter
     */
    async next(filter = {}) {
        return this.list(this.getFilter(filter, this.nextPage));
    }
    /**
     * Gets the previous page of available data from server.
     * @param filter
     */
    async prev(filter = {}) {
        return this.list(this.getFilter(filter, this.prevPage));
    }
    /**
     * Method used by next(), prev() and goto() to call the service.list method.
     * It is public so it can be overriden in special cases (like children objects
     * in inventory).
     * @param filter
     */
    async list(filter = {}) {
        return this.service.list(filter);
    }
    /**
     * Goes to the page that you define as page parameter.
     * @param page
     * @param filter
     */
    async goto(page, filter = {}) {
        return this.list(this.getFilter(filter, page));
    }
    getFilter(filter, page) {
        return Object.assign(filter, this.filter, { currentPage: page });
    }
}
exports.Paging = Paging;
//# sourceMappingURL=Paging.js.map