"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const Paging_1 = require("./Paging");
class Service {
    constructor(client, realtime) {
        this.client = client;
        this.realtime = realtime;
        this.cache = new Map();
        const methodsToHide = ['list', 'create', 'update', 'detail', 'delete'];
        const prototype = Object.getPrototypeOf(this);
        methodsToHide.forEach(method => {
            if (!prototype.hasOwnProperty(method)) {
                Object.defineProperty(this, method, {
                    get() {
                        return undefined;
                    }
                });
            }
        });
    }
    async list(filter = {}) {
        const headers = { accept: 'application/json' };
        const url = this.listUrl;
        const res = await this.fetch(url, this.changeFetchOptions({ headers, params: filter }, url));
        const json = await res.json();
        const data = this.propertyName ? json[this.propertyName] : json;
        const paging = this.getPaging(json, filter);
        return { res, data, paging };
    }
    async detail(entityOrId, filter = {}) {
        const headers = { accept: 'application/json' };
        const url = this.getDetailUrl(entityOrId);
        const res = await this.fetch(url, this.changeFetchOptions({ headers, params: { ...filter } }, url));
        const data = await res.json();
        return { res, data };
    }
    async create(entity) {
        const url = this.listUrl;
        const method = 'POST';
        const body = JSON.stringify(this.onBeforeCreate(entity));
        const headers = { 'content-type': 'application/json', accept: 'application/json' };
        const res = await this.fetch(url, this.changeFetchOptions({ method, body, headers }, url));
        const data = await res.json();
        return { res, data };
    }
    async update(entity) {
        const url = this.getDetailUrl(entity);
        const method = 'PUT';
        const body = JSON.stringify(this.onBeforeUpdate(entity));
        const headers = { 'content-type': 'application/json', accept: 'application/json' };
        const res = await this.fetch(url, this.changeFetchOptions({ method, body, headers }, url));
        const data = await res.json();
        return { res, data };
    }
    async delete(entityOrId, params) {
        const method = 'DELETE';
        const url = this.getDetailUrl(entityOrId);
        const res = await this.fetch(url, this.changeFetchOptions({ method, params }, url));
        return { res, data: null };
    }
    onBeforeCreate(obj) {
        delete obj.id;
        return obj;
    }
    onBeforeUpdate(objWithId) {
        return objWithId;
    }
    changeFetchOptions(options, _url = '') {
        return options;
    }
    getUrl(url = '') {
        const baseUrl = this.baseUrl.replace(/\/+$/, '');
        const partialUrl = url.replace(/^\/+/, '');
        return `${baseUrl}/${partialUrl}`;
    }
    getEntityId(entityOrId) {
        if (entityOrId === undefined || entityOrId === null) {
            return '';
        }
        if (typeof entityOrId === 'object') {
            return this.getEntityId(entityOrId.id);
        }
        return `${entityOrId}`;
    }
    getDetailUrl(entityOrId) {
        const id = this.getEntityId(entityOrId);
        return `${this.listUrl}/${id}`;
    }
    async fetch(url, init) {
        const fullUrl = this.getUrl(url);
        const res = await this.client.fetch(fullUrl, init);
        return await this.handleErrorStatusCodes(res);
    }
    /**
     * Checks the response for errors and throws exceptions, otherwise returns the response as is.
     *
     * @param response The response from server.
     *
     * @returns If no errors are detected, it returns the same response.
     *
     * @throws If an error is detected, it throws `{ res, data }`, where `data` contains error details from server.
     */
    async handleErrorStatusCodes(response) {
        if (response.status >= 400) {
            let data = null;
            try {
                data = await response.json();
            }
            catch (ex) {
                try {
                    data = await response.text();
                }
                catch (ex) {
                    // do nothing
                }
            }
            throw { res: response, data };
        }
        return response;
    }
    mimeType(type) {
        return `application/vnd.com.nsn.cumulocity.${type}+json`;
    }
    getIdString(reference) {
        let id;
        if (typeof reference === 'object') {
            id = reference.id;
        }
        else {
            id = reference;
        }
        return String(id);
    }
    getPaging(json, filter) {
        if (json.statistics) {
            const statistics = {
                ...json.statistics,
                nextPage: this.getCurrentPageFromLink(json.next),
                prevPage: this.getCurrentPageFromLink(json.prev)
            };
            return new Paging_1.Paging(this, statistics, filter);
        }
        return null;
    }
    getCurrentPageFromLink(link = '') {
        const matches = link.match(/currentPage=(-{0,1}\d+)/);
        return matches && parseInt(matches[1], 10);
    }
}
exports.Service = Service;
//# sourceMappingURL=Service.js.map