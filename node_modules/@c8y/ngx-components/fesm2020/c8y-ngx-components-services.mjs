import * as i0 from '@angular/core';
import { Component, InjectionToken, Injectable, Optional, Inject, EventEmitter, NgModule } from '@angular/core';
import * as i1 from '@c8y/ngx-components';
import { BaseColumn, gettext, getBasicInputArrayFormFieldConfig, hookGeneric, ViewContext, CoreModule, hookRoute, hookBreadcrumb } from '@c8y/ngx-components';
import { FormGroup } from '@angular/forms';
import * as i1$1 from '@angular/router';
import { RouterModule } from '@angular/router';
import { flatten, entries, get } from 'lodash-es';
import * as i3 from '@angular/common';
import * as i4 from 'ngx-bootstrap/tooltip';
import { TooltipModule } from 'ngx-bootstrap/tooltip';
import * as i1$2 from '@c8y/client';
import { QueriesUtil } from '@c8y/client';

class LastUpdatedDateCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
LastUpdatedDateCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: LastUpdatedDateCellRendererComponent, deps: [{ token: i1.CellRendererContext }], target: i0.ɵɵFactoryTarget.Component });
LastUpdatedDateCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: LastUpdatedDateCellRendererComponent, selector: "ng-component", ngImport: i0, template: `{{ context.value | c8yDate }}`, isInline: true, dependencies: [{ kind: "pipe", type: i1.DatePipe, name: "c8yDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: LastUpdatedDateCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: `{{ context.value | c8yDate }}`
                }]
        }], ctorParameters: function () { return [{ type: i1.CellRendererContext }]; } });

class LastUpdatedDateGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.path = 'lastUpdated';
        this.name = 'lastUpdatedDate';
        this.header = gettext('Last updated');
        this.cellRendererComponent = LastUpdatedDateCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: [
                {
                    type: 'object',
                    key: 'lastUpdated',
                    templateOptions: {
                        label: gettext('Show services updated`between dates`')
                    },
                    fieldGroup: [
                        {
                            type: 'date-time',
                            key: 'after',
                            templateOptions: {
                                label: gettext('from`date`')
                            },
                            expressionProperties: {
                                'templateOptions.maxDate': (model) => model?.before
                            }
                        },
                        {
                            type: 'date-time',
                            key: 'before',
                            templateOptions: {
                                label: gettext('to`date`')
                            },
                            expressionProperties: {
                                'templateOptions.minDate': (model) => model?.after
                            }
                        }
                    ]
                }
            ],
            formGroup: new FormGroup({}),
            getFilter: model => {
                const filter = {};
                const dates = model && model.lastUpdated;
                if (dates && (dates.after || dates.before)) {
                    filter.__and = [];
                    if (dates.after) {
                        const after = this.formatDate(dates.after);
                        filter.__and.push({
                            __or: {
                                [this.path]: { __gt: after },
                                [`${this.path}.date`]: { __gt: after }
                            }
                        });
                    }
                    if (dates.before) {
                        const before = this.formatDate(dates.before);
                        filter.__and.push({
                            __or: {
                                [this.path]: { __lt: before },
                                [`${this.path}.date`]: { __lt: before }
                            }
                        });
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: `${this.path}.date` }, { path: this.path }]
        };
    }
    formatDate(dateToFormat) {
        return new Date(dateToFormat).toISOString();
    }
}

class NameCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
NameCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: NameCellRendererComponent, deps: [{ token: i1.CellRendererContext }], target: i0.ɵɵFactoryTarget.Component });
NameCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: NameCellRendererComponent, selector: "ng-component", ngImport: i0, template: `
    <a [routerLink]="['/service', context.item.id]" [title]="context.item.name" class="interact">
      {{ context.item.name }}
    </a>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1$1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: NameCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: `
    <a [routerLink]="['/service', context.item.id]" [title]="context.item.name" class="interact">
      {{ context.item.name }}
    </a>
  `
                }]
        }], ctorParameters: function () { return [{ type: i1.CellRendererContext }]; } });

class ServiceNameGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'name';
        this.path = 'name';
        this.header = gettext('Name');
        this.cellRendererComponent = NameCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'names',
                label: gettext('Filter services by name'),
                addText: gettext('Add next`name`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: gettext('daemon`SERVICE_NAME`')
            }),
            getFilter(model) {
                const filter = {};
                if (model.names.length) {
                    filter.name = { __in: model.names };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class ServiceTypeGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'serviceType';
        this.path = 'serviceType';
        this.header = gettext('Type');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'serviceTypes',
                label: gettext('Filter services by type'),
                addText: gettext('Add next`type`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: 'systemd'
            }),
            getFilter(model) {
                const filter = {};
                if (model.serviceTypes.length) {
                    filter.serviceType = { __in: model.serviceTypes };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

/**
 * Extension hook allowing to register custom service statuses and configure their visual presentation.
 * @deprecated Consider using the `hookServiceStatus` function instead.
 */
const HOOK_SERVICE_STATUS = new InjectionToken('HOOK_SERVICE_STATUS');
/**
 * Extension hook allowing to register custom service statuses and configure their visual presentation.
 *
 * You can either provide a single `StatusOption` as parameter:
 * ```typescript
 *  hookServiceStatus(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookServiceStatus([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<StatusOption>`
 * ```typescript
 *  export class MyServiceStatusFactory implements ExtensionFactory<StatusOption> {...}
 *  ...
 *  hookServiceStatus(MyServiceStatusFactory)
 * ```
 * A typed alternative to `HOOK_SERVICE_STATUS`.
 * @param status The `StatusOption`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
function hookServiceStatus(status, options) {
    return hookGeneric(status, HOOK_SERVICE_STATUS, options);
}
/**
 * Standard status options supported by the platform.
 */
const SERVICE_STATUS_OPTIONS = [
    {
        key: 'up',
        label: gettext('Up'),
        icon: 'check-circle',
        class: 'text-success'
    },
    {
        key: 'down',
        label: gettext('Down'),
        icon: 'exclamation-circle',
        class: 'text-danger'
    },
    {
        key: 'unknown',
        label: gettext('Unknown'),
        icon: 'inactive-state'
    }
];

/**
 * The service for system wide registered service status options.
 * It provides the standard service statuses plus all custom status options
 * registered with the <code>HOOK_SERVICE_STATUS</code> extension hook.
 */
class StatusOptionsService {
    get options() {
        return this._options;
    }
    constructor(options) {
        this._options = [...SERVICE_STATUS_OPTIONS, ...flatten(options)];
    }
}
StatusOptionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StatusOptionsService, deps: [{ token: HOOK_SERVICE_STATUS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
StatusOptionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StatusOptionsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StatusOptionsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: Array, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [HOOK_SERVICE_STATUS]
                }] }]; } });

class StatusCellRendererComponent {
    constructor(context, statusOptionsService) {
        this.context = context;
        this.statusOptionsService = statusOptionsService;
    }
}
StatusCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StatusCellRendererComponent, deps: [{ token: i1.CellRendererContext }, { token: StatusOptionsService }], target: i0.ɵɵFactoryTarget.Component });
StatusCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: StatusCellRendererComponent, selector: "ng-component", ngImport: i0, template: "<span [ngSwitch]=\"context.item.status\">\n  <ng-container *ngFor=\"let option of statusOptionsService.options\">\n    <i\n      *ngSwitchCase=\"option.key\"\n      [c8yIcon]=\"option.icon\"\n      class=\"{{ option.class }}\"\n      [tooltip]=\"option.label | translate\"\n      container=\"body\"\n      placement=\"top\"\n    ></i>\n  </ng-container>\n  <i\n    *ngSwitchDefault\n    c8yIcon=\"job\"\n    class=\"text-primary\"\n    [tooltip]=\"context.item.status\"\n    container=\"body\"\n    placement=\"top\"\n  ></i>\n</span>\n", dependencies: [{ kind: "directive", type: i1.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i3.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i3.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "directive", type: i4.TooltipDirective, selector: "[tooltip], [tooltipHtml]", inputs: ["adaptivePosition", "tooltip", "placement", "triggers", "container", "containerClass", "boundariesElement", "isOpen", "isDisabled", "delay", "tooltipHtml", "tooltipPlacement", "tooltipIsOpen", "tooltipEnable", "tooltipAppendToBody", "tooltipAnimation", "tooltipClass", "tooltipContext", "tooltipPopupDelay", "tooltipFadeDuration", "tooltipTrigger"], outputs: ["tooltipChange", "onShown", "onHidden", "tooltipStateChanged"], exportAs: ["bs-tooltip"] }, { kind: "pipe", type: i1.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StatusCellRendererComponent, decorators: [{
            type: Component,
            args: [{ template: "<span [ngSwitch]=\"context.item.status\">\n  <ng-container *ngFor=\"let option of statusOptionsService.options\">\n    <i\n      *ngSwitchCase=\"option.key\"\n      [c8yIcon]=\"option.icon\"\n      class=\"{{ option.class }}\"\n      [tooltip]=\"option.label | translate\"\n      container=\"body\"\n      placement=\"top\"\n    ></i>\n  </ng-container>\n  <i\n    *ngSwitchDefault\n    c8yIcon=\"job\"\n    class=\"text-primary\"\n    [tooltip]=\"context.item.status\"\n    container=\"body\"\n    placement=\"top\"\n  ></i>\n</span>\n" }]
        }], ctorParameters: function () { return [{ type: i1.CellRendererContext }, { type: StatusOptionsService }]; } });

class StatusGridColumn extends BaseColumn {
    constructor(statusOptionsService, initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'status';
        this.path = 'status';
        this.header = gettext('Status');
        this.dataType = "icon" /* ColumnDataType.Icon */;
        this.cellRendererComponent = StatusCellRendererComponent;
        this.filterable = true;
        this.resizable = false;
        this.filteringConfig = {
            fields: [
                {
                    key: 'statusOptions',
                    type: 'object',
                    props: {
                        label: gettext('Show devices with status')
                    },
                    fieldGroup: [
                        ...statusOptionsService.options.map(option => ({
                            key: option.key,
                            type: 'switch',
                            props: {
                                label: option.label,
                                optionDataCy: option.key
                            }
                        }))
                    ]
                },
                ...getBasicInputArrayFormFieldConfig({
                    key: 'custom',
                    label: gettext('or filter by custom status'),
                    addText: gettext('Add next`custom status`'),
                    tooltip: gettext('Use * as a wildcard character'),
                    placeholder: gettext('restarting`SERVICE_STATUS`'),
                    optional: true
                })
            ],
            getFilter(model) {
                const filter = {};
                filter.status = {
                    __in: [
                        ...entries(model?.statusOptions || {})
                            .filter(([_, value]) => !!value)
                            .map(([key, _]) => key),
                        ...model.custom.filter(c => !!c)
                    ]
                };
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

const SERVICE_FRAGMENT$1 = 'c8y_Service';
class ServicesDeviceTabComponent {
    constructor(route, inventoryService, gridService, statusOptionsService) {
        this.route = route;
        this.inventoryService = inventoryService;
        this.gridService = gridService;
        this.statusOptionsService = statusOptionsService;
        this.deviceId = this.route.snapshot.parent.data.contextData.id;
        this.sizeRequestDone = false;
        this.refresh$ = new EventEmitter();
        this.pagination = {
            pageSize: 50,
            currentPage: 1
        };
        this.columns = [
            new StatusGridColumn(this.statusOptionsService),
            new ServiceNameGridColumn(),
            new ServiceTypeGridColumn(),
            new LastUpdatedDateGridColumn()
        ];
        this.queriesUtil = new QueriesUtil();
        this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
        this.sizeRequest = this.inventoryService
            .childAdditionsList(this.deviceId, {
            query: `type eq ${SERVICE_FRAGMENT$1}`,
            withTotalPages: true,
            pageSize: 1
        })
            .then(response => {
            this.sizeRequestDone = true;
            return response?.paging?.totalPages;
        });
    }
    async onDataSourceModifier(dataSourceModifier) {
        const query = this.queriesUtil.buildQuery(this.queriesUtil.addAndFilter(this.gridService.getQueryObj(dataSourceModifier.columns), {
            type: SERVICE_FRAGMENT$1
        }));
        const dataRequest = this.inventoryService.childAdditionsList(this.deviceId, {
            query,
            withTotalPages: true,
            pageSize: dataSourceModifier.pagination.pageSize,
            currentPage: dataSourceModifier.pagination.currentPage
        });
        const filtererdSizeRequest = this.inventoryService
            .childAdditionsList(this.deviceId, {
            query,
            withTotalPages: true,
            pageSize: 1
        })
            .then(response => response?.paging?.totalPages);
        const [dataResponse, size, filteredSize] = await Promise.all([
            dataRequest,
            this.sizeRequest,
            filtererdSizeRequest
        ]);
        const { res, data, paging } = dataResponse;
        const serverSideDataResult = {
            res,
            data,
            paging,
            filteredSize,
            size
        };
        return serverSideDataResult;
    }
    trackByName(_index, column) {
        return column.name;
    }
}
ServicesDeviceTabComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabComponent, deps: [{ token: i1$1.ActivatedRoute }, { token: i1$2.InventoryService }, { token: i1.DataGridService }, { token: StatusOptionsService }], target: i0.ɵɵFactoryTarget.Component });
ServicesDeviceTabComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ServicesDeviceTabComponent, selector: "c8y-services-device-tab", ngImport: i0, template: "<div class=\"content-fullpage\">\n  <c8y-data-grid\n    [title]=\"'Services' | translate\"\n    [refresh]=\"refresh$\"\n    [actionControls]=\"[]\"\n    [pagination]=\"pagination\"\n    [columns]=\"columns\"\n    [infiniteScroll]=\"'auto'\"\n    [serverSideDataCallback]=\"serverSideDataCallback\"\n  >\n    <div class=\"c8y-empty-state\">\n      <ng-container *ngIf=\"!sizeRequestDone\">\n        <c8y-loading></c8y-loading>\n      </ng-container>\n      <ng-container *ngIf=\"sizeRequestDone\">\n        <ng-container *ngIf=\"(sizeRequest | async) === 0; else noResults\">\n          <div class=\"text-center\">\n            <h1 class=\"c8y-icon-duocolor\" c8yIcon=\"c8y-tools\"></h1>\n            <h3 translate>No services to display.</h3>\n          </div>\n        </ng-container>\n        <ng-template #noResults>\n          <h1 c8yIcon=\"search\"></h1>\n          <div>\n            <p>\n              <strong>{{ 'No results to display.' | translate }}</strong>\n            </p>\n            <small>{{ 'Refine your search terms or check your spelling.' | translate }}</small>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n    <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n      <c8y-column [name]=\"column.name\"></c8y-column>\n    </ng-container>\n  </c8y-data-grid>\n</div>\n", dependencies: [{ kind: "directive", type: i1.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i1.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i1.LoadingComponent, selector: "c8y-loading" }, { kind: "directive", type: i1.ColumnDirective, selector: "c8y-column", inputs: ["name"] }, { kind: "component", type: i1.DataGridComponent, selector: "c8y-data-grid", inputs: ["title", "loadMoreItemsLabel", "loadingItemsLabel", "showSearch", "refresh", "columns", "rows", "pagination", "infiniteScroll", "serverSideDataCallback", "selectable", "singleSelection", "selectionPrimaryKey", "displayOptions", "actionControls", "bulkActionControls", "headerActionControls", "searchText", "configureColumnsEnabled", "showCounterWarning", "activeClassName"], outputs: ["rowMouseOver", "rowMouseLeave", "rowClick", "onConfigChange", "onBeforeFilter", "onBeforeSearch", "onFilter", "itemsSelect", "onReload", "onAddCustomColumn", "onRemoveCustomColumn", "onColumnFilterReset", "onSort", "onPageSizeChange", "onColumnReordered", "onColumnVisibilityChange"] }, { kind: "pipe", type: i1.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-services-device-tab', template: "<div class=\"content-fullpage\">\n  <c8y-data-grid\n    [title]=\"'Services' | translate\"\n    [refresh]=\"refresh$\"\n    [actionControls]=\"[]\"\n    [pagination]=\"pagination\"\n    [columns]=\"columns\"\n    [infiniteScroll]=\"'auto'\"\n    [serverSideDataCallback]=\"serverSideDataCallback\"\n  >\n    <div class=\"c8y-empty-state\">\n      <ng-container *ngIf=\"!sizeRequestDone\">\n        <c8y-loading></c8y-loading>\n      </ng-container>\n      <ng-container *ngIf=\"sizeRequestDone\">\n        <ng-container *ngIf=\"(sizeRequest | async) === 0; else noResults\">\n          <div class=\"text-center\">\n            <h1 class=\"c8y-icon-duocolor\" c8yIcon=\"c8y-tools\"></h1>\n            <h3 translate>No services to display.</h3>\n          </div>\n        </ng-container>\n        <ng-template #noResults>\n          <h1 c8yIcon=\"search\"></h1>\n          <div>\n            <p>\n              <strong>{{ 'No results to display.' | translate }}</strong>\n            </p>\n            <small>{{ 'Refine your search terms or check your spelling.' | translate }}</small>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n    <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n      <c8y-column [name]=\"column.name\"></c8y-column>\n    </ng-container>\n  </c8y-data-grid>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.ActivatedRoute }, { type: i1$2.InventoryService }, { type: i1.DataGridService }, { type: StatusOptionsService }]; } });

const SERVICE_FRAGMENT = 'c8y_Service';
class ServicesDeviceTabGuard {
    constructor(inventoryService) {
        this.inventoryService = inventoryService;
    }
    canActivate(route) {
        const id = get(route, 'params.id') || get(route, 'parent.params.id');
        return this.inventoryService
            .childAdditionsList({ id }, { query: `type eq ${SERVICE_FRAGMENT}`, pageSize: 1 })
            .then(result => !!result?.data?.length);
    }
}
ServicesDeviceTabGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabGuard, deps: [{ token: i1$2.InventoryService }], target: i0.ɵɵFactoryTarget.Injectable });
ServicesDeviceTabGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabGuard });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabGuard, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.InventoryService }]; } });

class ServicesBreadcrumbFactory {
    constructor(inventoryService) {
        this.inventoryService = inventoryService;
    }
    async get(route) {
        const { context, contextData } = route.snapshot.data;
        const { routeConfig } = route.snapshot;
        this.contextData = contextData || this.contextData;
        if ((context === ViewContext.Service || routeConfig?.context === ViewContext.Service) &&
            !!this.contextData) {
            const serviceMO = (await this.inventoryService.detail(this.contextData, { withParents: true }))?.data;
            const breadcrumb = { items: [] };
            const breadcrumbItems = [];
            const device = serviceMO?.additionParents?.references[0]?.managedObject;
            if (device) {
                breadcrumbItems.push({
                    label: device.name,
                    path: `/device/${device.id}`
                });
                breadcrumbItems.push({
                    label: gettext('Services'),
                    path: `/device/${device.id}/services`
                });
                breadcrumbItems.push({
                    label: serviceMO.name
                });
            }
            breadcrumb.items = breadcrumbItems;
            return breadcrumb;
        }
    }
}
ServicesBreadcrumbFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesBreadcrumbFactory, deps: [{ token: i1$2.InventoryService }], target: i0.ɵɵFactoryTarget.Injectable });
ServicesBreadcrumbFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesBreadcrumbFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesBreadcrumbFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.InventoryService }]; } });

class ServicesDeviceTabModule {
}
ServicesDeviceTabModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ServicesDeviceTabModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabModule, declarations: [ServicesDeviceTabComponent,
        LastUpdatedDateCellRendererComponent,
        NameCellRendererComponent,
        StatusCellRendererComponent], imports: [CoreModule, RouterModule, TooltipModule] });
ServicesDeviceTabModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabModule, providers: [
        ServicesDeviceTabGuard,
        ServicesBreadcrumbFactory,
        hookRoute({
            context: ViewContext.Device,
            path: 'services',
            component: ServicesDeviceTabComponent,
            label: gettext('Services'),
            icon: 'statistics',
            priority: 500,
            canActivate: [ServicesDeviceTabGuard]
        }),
        hookBreadcrumb(ServicesBreadcrumbFactory)
    ], imports: [CoreModule, RouterModule, TooltipModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesDeviceTabModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CoreModule, RouterModule, TooltipModule],
                    declarations: [
                        ServicesDeviceTabComponent,
                        LastUpdatedDateCellRendererComponent,
                        NameCellRendererComponent,
                        StatusCellRendererComponent
                    ],
                    providers: [
                        ServicesDeviceTabGuard,
                        ServicesBreadcrumbFactory,
                        hookRoute({
                            context: ViewContext.Device,
                            path: 'services',
                            component: ServicesDeviceTabComponent,
                            label: gettext('Services'),
                            icon: 'statistics',
                            priority: 500,
                            canActivate: [ServicesDeviceTabGuard]
                        }),
                        hookBreadcrumb(ServicesBreadcrumbFactory)
                    ]
                }]
        }] });

class ServicesModule {
}
ServicesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ServicesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: ServicesModule, imports: [CoreModule, ServicesDeviceTabModule] });
ServicesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesModule, imports: [CoreModule, ServicesDeviceTabModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ServicesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CoreModule, ServicesDeviceTabModule]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { HOOK_SERVICE_STATUS, LastUpdatedDateCellRendererComponent, LastUpdatedDateGridColumn, NameCellRendererComponent, SERVICE_FRAGMENT$1 as SERVICE_FRAGMENT, SERVICE_STATUS_OPTIONS, ServiceNameGridColumn, ServiceTypeGridColumn, ServicesDeviceTabComponent, ServicesDeviceTabGuard, ServicesDeviceTabModule, ServicesModule, StatusCellRendererComponent, StatusGridColumn, StatusOptionsService, hookServiceStatus };
//# sourceMappingURL=c8y-ngx-components-services.mjs.map
