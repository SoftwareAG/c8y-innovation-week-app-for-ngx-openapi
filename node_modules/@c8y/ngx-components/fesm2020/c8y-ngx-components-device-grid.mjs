import * as i0 from '@angular/core';
import { Injectable, Component, ElementRef, ViewChild, HostListener, InjectionToken, EventEmitter, forwardRef, Input, Output, NgModule } from '@angular/core';
import * as i1$1 from '@c8y/ngx-components';
import { gettext, BaseColumn, getBasicInputArrayFormFieldConfig, SendStatus, PushStatus, DataGridService, Status, hookGeneric, ExtensionPointWithoutStateForPlugins, fromTriggerOnce, toObservable, FilteringActionType, PRODUCT_EXPERIENCE_EVENT_SOURCE, DataGridComponent, CommonModule, FormsModule, DeviceStatusModule, DataGridModule, DynamicFormsModule, ProductExperienceModule } from '@c8y/ngx-components';
import * as i1 from '@ngx-translate/core';
import { map, sortBy, remove, cloneDeep, flatten, groupBy } from 'lodash-es';
import * as i3 from '@angular/common';
import * as i2 from 'ngx-bootstrap/popover';
import { PopoverModule } from 'ngx-bootstrap/popover';
import * as i2$1 from '@c8y/ngx-components/assets-navigator';
import { AssetSelectorModule } from '@c8y/ngx-components/assets-navigator';
import { FormGroup } from '@angular/forms';
import { Subject, from, EMPTY } from 'rxjs';
import { shareReplay, map as map$1, switchMap, catchError, takeUntil } from 'rxjs/operators';
import * as i2$2 from '@angular/router';
import { RouterModule } from '@angular/router';
import * as i1$2 from '@c8y/client';

/**
 * Service contains logic extracted from the device-grid service to avoid circular dependency MTM-40239.
 */
class ColumnUtilService {
    constructor(translateService) {
        this.translateService = translateService;
    }
    getAlarmsHref(device) {
        return `${this.getHref(device)}/alarms`;
    }
    getHref(groupOrDevice, prefix = '#/') {
        if (groupOrDevice.c8y_IsDeviceGroup || groupOrDevice.c8y_IsDynamicGroup) {
            return `${prefix}group/${groupOrDevice.id}`;
        }
        return `${prefix}device/${groupOrDevice.id}`;
    }
    getParentsNames(device, featuredParentId) {
        const assetParentsReferences = device.assetParents.references;
        const assetParents = map(assetParentsReferences, 'managedObject');
        const sortedByName = sortBy(assetParents, ['name']);
        const featuredItems = remove(sortedByName, { id: featuredParentId });
        const items = featuredItems.concat(sortedByName);
        const names = map(items, 'name');
        return names.join(', ');
    }
    getModel(device) {
        const hardware = this.getHardware(device);
        return hardware && hardware.model;
    }
    getProperName(device) {
        const { id, name } = device;
        return name ? name : this.translateService.instant('Device {{id}}', { id });
    }
    getSerialNumber(device) {
        const hardware = this.getHardware(device);
        const serialPropertyName = this.isVendme(device) ? 'serial' : 'serialNumber';
        return hardware && hardware[serialPropertyName];
    }
    getHardware(device) {
        const hardwarePropertyName = this.isVendme(device)
            ? 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo'
            : 'c8y_Hardware';
        return device && device[hardwarePropertyName];
    }
    isVendme(device) {
        return device.type === 'com_nsn_startups_vendme_VendingMachine';
    }
}
ColumnUtilService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ColumnUtilService, deps: [{ token: i1.TranslateService }], target: i0.ɵɵFactoryTarget.Injectable });
ColumnUtilService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ColumnUtilService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ColumnUtilService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }]; } });

class AlarmsCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
        this.linkAriaLabel = gettext('See alarms for device "{{ name }}"');
    }
}
AlarmsCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: AlarmsCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }, { token: ColumnUtilService }], target: i0.ɵɵFactoryTarget.Component });
AlarmsCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: AlarmsCellRendererComponent, selector: "ng-component", ngImport: i0, template: "<a\n  class=\"d-flex a-i-center flex-wrap gap-4 no-decoration\"\n  [href]=\"columnUtilService.getAlarmsHref(context.item)\"\n  [attr.aria-label]=\"\n    linkAriaLabel | translate: { name: columnUtilService.getProperName(context.item) }\n  \"\n  *ngIf=\"\n    context.item.c8y_ActiveAlarmsStatus?.critical ||\n    context.item.c8y_ActiveAlarmsStatus?.major ||\n    context.item.c8y_ActiveAlarmsStatus?.minor ||\n    context.item.c8y_ActiveAlarmsStatus?.warning\n  \"\n>\n  <span\n    class=\"c8y-icon-badge\"\n    data-cy=\"alarms.cell-renderer--critical-alarm-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.critical }} {{ 'Critical alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.critical\"\n  >\n    <i [c8yIcon]=\"'exclamation-circle'\" class=\"status critical stroked-icon\" data-cy=\"alarms.cell-renderer--critical-alarm-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.critical }}</span>\n  </span>\n  <span\n    class=\"c8y-icon-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.major }} {{ 'Major alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.major\"\n  >\n    <i [c8yIcon]=\"'warning'\" class=\"status major stroked-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.major }}</span>\n  </span>\n  <span\n    class=\"c8y-icon-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.minor }} {{ 'Minor alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.minor\"\n  >\n    <i [c8yIcon]=\"'high-priority'\" class=\"status minor stroked-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.minor }}</span>\n  </span>\n  <span\n    class=\"c8y-icon-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.warning }} {{ 'Warning alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.warning\"\n  >\n    <i [c8yIcon]=\"'info-circle'\" class=\"status warning stroked-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.warning }}</span>\n  </span>\n</a>\n", dependencies: [{ kind: "directive", type: i1$1.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i1$1.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: AlarmsCellRendererComponent, decorators: [{
            type: Component,
            args: [{ template: "<a\n  class=\"d-flex a-i-center flex-wrap gap-4 no-decoration\"\n  [href]=\"columnUtilService.getAlarmsHref(context.item)\"\n  [attr.aria-label]=\"\n    linkAriaLabel | translate: { name: columnUtilService.getProperName(context.item) }\n  \"\n  *ngIf=\"\n    context.item.c8y_ActiveAlarmsStatus?.critical ||\n    context.item.c8y_ActiveAlarmsStatus?.major ||\n    context.item.c8y_ActiveAlarmsStatus?.minor ||\n    context.item.c8y_ActiveAlarmsStatus?.warning\n  \"\n>\n  <span\n    class=\"c8y-icon-badge\"\n    data-cy=\"alarms.cell-renderer--critical-alarm-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.critical }} {{ 'Critical alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.critical\"\n  >\n    <i [c8yIcon]=\"'exclamation-circle'\" class=\"status critical stroked-icon\" data-cy=\"alarms.cell-renderer--critical-alarm-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.critical }}</span>\n  </span>\n  <span\n    class=\"c8y-icon-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.major }} {{ 'Major alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.major\"\n  >\n    <i [c8yIcon]=\"'warning'\" class=\"status major stroked-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.major }}</span>\n  </span>\n  <span\n    class=\"c8y-icon-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.minor }} {{ 'Minor alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.minor\"\n  >\n    <i [c8yIcon]=\"'high-priority'\" class=\"status minor stroked-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.minor }}</span>\n  </span>\n  <span\n    class=\"c8y-icon-badge\"\n    title=\"{{ context.item.c8y_ActiveAlarmsStatus?.warning }} {{ 'Warning alarms' | translate }}\"\n    *ngIf=\"context.item.c8y_ActiveAlarmsStatus?.warning\"\n  >\n    <i [c8yIcon]=\"'info-circle'\" class=\"status warning stroked-icon\"></i>\n    <span class=\"badge badge-info\">{{ context.item.c8y_ActiveAlarmsStatus?.warning }}</span>\n  </span>\n</a>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }, { type: ColumnUtilService }]; } });

class AlarmsHeaderCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
AlarmsHeaderCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: AlarmsHeaderCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }], target: i0.ɵɵFactoryTarget.Component });
AlarmsHeaderCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: AlarmsHeaderCellRendererComponent, selector: "ng-component", ngImport: i0, template: `
    <div class="d-flex">
      <span class="text-truncate" [title]="context.property.header | translate">
        {{ context.property.header | translate }}
      </span>
      <button
        class="btn-help btn-help--sm a-s-center"
        type="button"
        [attr.aria-label]="'Help' | translate"
        [popover]="'Only includes alarms for the parent device.' | translate"
        placement="bottom"
        triggers="focus"
        container="body"
        (click)="$event.stopPropagation()"
      >
        <i c8yIcon="question-circle-o"></i>
      </button>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1$1.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i2.PopoverDirective, selector: "[popover]", inputs: ["adaptivePosition", "boundariesElement", "popover", "popoverContext", "popoverTitle", "placement", "outsideClick", "triggers", "container", "containerClass", "isOpen", "delay"], outputs: ["onShown", "onHidden"], exportAs: ["bs-popover"] }, { kind: "pipe", type: i1$1.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: AlarmsHeaderCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: `
    <div class="d-flex">
      <span class="text-truncate" [title]="context.property.header | translate">
        {{ context.property.header | translate }}
      </span>
      <button
        class="btn-help btn-help--sm a-s-center"
        type="button"
        [attr.aria-label]="'Help' | translate"
        [popover]="'Only includes alarms for the parent device.' | translate"
        placement="bottom"
        triggers="focus"
        container="body"
        (click)="$event.stopPropagation()"
      >
        <i c8yIcon="question-circle-o"></i>
      </button>
    </div>
  `
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }]; } });

class AlarmsDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'alarms';
        this.header = gettext('Alarms');
        this.headerCellRendererComponent = AlarmsHeaderCellRendererComponent;
        this.cellRendererComponent = AlarmsCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    alarm: {
                        type: 'object',
                        title: gettext('Show items'),
                        properties: {
                            critical: {
                                type: 'switch',
                                title: gettext('With active critical alarms')
                            },
                            major: {
                                type: 'switch',
                                title: gettext('With active major alarms')
                            },
                            minor: {
                                type: 'switch',
                                title: gettext('With active minor alarms')
                            },
                            warning: {
                                type: 'switch',
                                title: gettext('With active warnings')
                            },
                            none: {
                                type: 'switch',
                                title: gettext('With no active alarms or warnings')
                            }
                        }
                    }
                }
            },
            getFilter(model) {
                const filter = {};
                const ors = [];
                if (model.alarm.critical) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.critical': { __gt: 0 } });
                }
                if (model.alarm.major) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.major': { __gt: 0 } });
                }
                if (model.alarm.minor) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.minor': { __gt: 0 } });
                }
                if (model.alarm.warning) {
                    ors.push({ 'c8y_ActiveAlarmsStatus.warning': { __gt: 0 } });
                }
                if (model.alarm.none) {
                    ors.push({ __not: { __has: 'c8y_ActiveAlarmsStatus' } });
                    ors.push({
                        __and: map(['critical', 'major', 'minor', 'warning'], sev => {
                            const zero = {};
                            const has = { __not: { __has: undefined } };
                            const key = `c8y_ActiveAlarmsStatus.${sev}`;
                            zero[key] = 0;
                            has.__not.__has = key;
                            return { __or: [zero, has] };
                        })
                    });
                }
                if (ors.length) {
                    filter.__or = ors;
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [
                { path: 'c8y_ActiveAlarmsStatus.critical' },
                { path: 'c8y_ActiveAlarmsStatus.major' },
                { path: 'c8y_ActiveAlarmsStatus.minor' },
                { path: 'c8y_ActiveAlarmsStatus.warning' }
            ]
        };
    }
}

class GroupCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
GroupCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: GroupCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }, { token: ColumnUtilService }], target: i0.ɵɵFactoryTarget.Component });
GroupCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: GroupCellRendererComponent, selector: "ng-component", ngImport: i0, template: "<span\n  title=\"{{\n    columnUtilService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\"\n>\n  {{\n    columnUtilService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\n</span>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: GroupCellRendererComponent, decorators: [{
            type: Component,
            args: [{ template: "<span\n  title=\"{{\n    columnUtilService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\"\n>\n  {{\n    columnUtilService.getParentsNames(\n      context.item,\n      context.property.externalFilterQuery?.deviceGroupId\n    )\n  }}\n</span>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }, { type: ColumnUtilService }]; } });

class GroupFilteringFormRendererComponent {
    constructor(context) {
        this.context = context;
        this.preselected = [];
    }
    onEnterKeyUp(event) {
        event.stopPropagation();
        this.applyFilter();
    }
    onEscapeKeyDown(event) {
        event.stopPropagation();
        this.resetFilter();
    }
    ngOnInit() {
        const column = this.context.property;
        this.model = cloneDeep(column.externalFilterQuery || {});
        this.preselected = this.model.selectedNodes || [];
    }
    ngAfterViewInit() {
        setTimeout(() => {
            try {
                this.assetSelector.nativeElement.querySelector('input').focus();
            }
            catch (ex) {
                // intended empty
            }
        }, 250);
    }
    applyFilter() {
        this.context.applyFilter({
            externalFilterQuery: this.model
        });
    }
    resetFilter() {
        this.context.resetFilter();
    }
    selectionChanged(nodes) {
        this.model.selectedNodes = nodes.items;
    }
}
GroupFilteringFormRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: GroupFilteringFormRendererComponent, deps: [{ token: i1$1.FilteringFormRendererContext }], target: i0.ɵɵFactoryTarget.Component });
GroupFilteringFormRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: GroupFilteringFormRendererComponent, selector: "ng-component", host: { listeners: { "keyup.enter": "onEnterKeyUp($event)", "keydown.escape": "onEscapeKeyDown($event)" } }, viewQueries: [{ propertyName: "assetSelector", first: true, predicate: ["assetSelector"], descendants: true, read: ElementRef }], ngImport: i0, template: "<c8y-asset-selector\n  #assetSelector\n  [config]=\"{\n    groupsOnly: true,\n    multi: true,\n    groupsSelectable: true,\n    search: true\n  }\"\n  [selected]=\"preselected\"\n  (onSelected)=\"selectionChanged($event)\"\n  class=\"bg-component\"\n></c8y-asset-selector>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n", dependencies: [{ kind: "directive", type: i1$1.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "component", type: i2$1.AssetSelectorComponent, selector: "c8y-asset-selector", inputs: ["config", "active", "index", "asset", "selectedDevice", "selected", "rootNode", "selectedItems", "container"], outputs: ["onSelected", "onClearSelected", "onRowSelected", "onLoad"] }, { kind: "pipe", type: i1$1.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: GroupFilteringFormRendererComponent, decorators: [{
            type: Component,
            args: [{ template: "<c8y-asset-selector\n  #assetSelector\n  [config]=\"{\n    groupsOnly: true,\n    multi: true,\n    groupsSelectable: true,\n    search: true\n  }\"\n  [selected]=\"preselected\"\n  (onSelected)=\"selectionChanged($event)\"\n  class=\"bg-component\"\n></c8y-asset-selector>\n\n<div class=\"data-grid__dropdown__footer d-flex separator-top\">\n  <button\n    class=\"btn btn-default btn-sm m-r-8 flex-grow\"\n    (click)=\"resetFilter()\"\n    title=\"{{ 'Reset' | translate }}\"\n    translate\n  >\n    Reset\n  </button>\n\n  <button\n    class=\"btn btn-primary btn-sm flex-grow\"\n    (click)=\"applyFilter()\"\n    title=\"{{ 'Apply' | translate }}\"\n    translate\n  >\n    Apply\n  </button>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.FilteringFormRendererContext }]; }, propDecorators: { assetSelector: [{
                type: ViewChild,
                args: ['assetSelector', { static: false, read: ElementRef }]
            }], onEnterKeyUp: [{
                type: HostListener,
                args: ['keyup.enter', ['$event']]
            }], onEscapeKeyDown: [{
                type: HostListener,
                args: ['keydown.escape', ['$event']]
            }] } });

class GroupDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'group';
        this.header = gettext('Group');
        this.cellRendererComponent = GroupCellRendererComponent;
        this.filteringFormRendererComponent = GroupFilteringFormRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            generateChips(model) {
                if (model.selectedNodes) {
                    return model.selectedNodes.map(mo => ({
                        displayValue: mo.name,
                        value: mo,
                        remove() {
                            const { externalFilterQuery, columnName, value } = this;
                            const nodes = externalFilterQuery.selectedNodes.filter(node => node.id !== value.id);
                            return {
                                externalFilterQuery: { selectedNodes: nodes },
                                columnName: columnName
                            };
                        }
                    }));
                }
            },
            getFilter(model) {
                const filter = {};
                if (model.selectedNodes) {
                    filter.__or = model.selectedNodes.map((mo) => {
                        if (mo.c8y_DeviceQueryString) {
                            return { __useFilterQueryString: mo.c8y_DeviceQueryString };
                        }
                        return { __bygroupid: mo.id };
                    });
                }
                return filter;
            }
        };
        this.sortable = false;
    }
}

class ImeiDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.path = 'c8y_Mobile.imei';
        this.name = 'imei';
        this.header = gettext('IMEI');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'imeis',
                label: gettext('Show items with IMEI'),
                addText: gettext('Add next`IMEI`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: '46543432321'
            }),
            getFilter: (model) => {
                const filter = {};
                if (model.imeis.length) {
                    filter[this.path] = { __in: model.imeis };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class ModelCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
ModelCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ModelCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }, { token: ColumnUtilService }], target: i0.ɵɵFactoryTarget.Component });
ModelCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ModelCellRendererComponent, selector: "ng-component", ngImport: i0, template: ` {{ columnUtilService.getModel(context.item) }} `, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ModelCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: ` {{ columnUtilService.getModel(context.item) }} `
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }, { type: ColumnUtilService }]; } });

class ModelDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const hardwareModelPath = 'c8y_Hardware.model';
        const vendingModelPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.model';
        this.name = 'model';
        this.header = gettext('Model');
        this.cellRendererComponent = ModelCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'models',
                label: gettext('Show items with model'),
                addText: gettext('Add next`model`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: 'NTC-220'
            }),
            getFilter(model) {
                const filter = {};
                if (model.models.length) {
                    filter.__or = {
                        [hardwareModelPath]: { __in: model.models },
                        [vendingModelPath]: { __in: model.models }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareModelPath }, { path: vendingModelPath }]
        };
    }
}

class NameCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
NameCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: NameCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }, { token: ColumnUtilService }], target: i0.ɵɵFactoryTarget.Component });
NameCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: NameCellRendererComponent, selector: "ng-component", ngImport: i0, template: `
    <a
      [href]="columnUtilService.getHref(context.item)"
      title="{{ columnUtilService.getProperName(context.item) }}"
      class="interact"
    >
      {{ columnUtilService.getProperName(context.item) }}
    </a>
  `, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: NameCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: `
    <a
      [href]="columnUtilService.getHref(context.item)"
      title="{{ columnUtilService.getProperName(context.item) }}"
      class="interact"
    >
      {{ columnUtilService.getProperName(context.item) }}
    </a>
  `
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }, { type: ColumnUtilService }]; } });

class NameDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'name';
        this.path = 'name';
        this.header = gettext('Name');
        this.cellCSSClassName = "data-record-header" /* ColumnDataRecordClassName.Header */;
        this.cellRendererComponent = NameCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'names',
                label: gettext('Show items with name'),
                addText: gettext('Add next`name`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: gettext('My device`DEVICE_NAME`')
            }),
            getFilter(model) {
                const filter = {};
                if (model.names.length) {
                    filter.name = { __in: model.names };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class RegistrationDateCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
RegistrationDateCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: RegistrationDateCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }], target: i0.ɵɵFactoryTarget.Component });
RegistrationDateCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: RegistrationDateCellRendererComponent, selector: "ng-component", ngImport: i0, template: ` {{ context.value | c8yDate }} `, isInline: true, dependencies: [{ kind: "pipe", type: i1$1.DatePipe, name: "c8yDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: RegistrationDateCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: ` {{ context.value | c8yDate }} `
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }]; } });

class RegistrationDateDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.path = 'creationTime';
        this.name = 'registrationDate';
        this.header = gettext('Registration date');
        this.cellRendererComponent = RegistrationDateCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: [
                {
                    type: 'object',
                    key: 'registrationDate',
                    templateOptions: {
                        label: gettext('Show items registered`between dates`')
                    },
                    fieldGroup: [
                        {
                            type: 'date-time',
                            key: 'after',
                            templateOptions: {
                                label: gettext('from`date`')
                            },
                            expressionProperties: {
                                'templateOptions.maxDate': (model) => model?.before
                            }
                        },
                        {
                            type: 'date-time',
                            key: 'before',
                            templateOptions: {
                                label: gettext('to`date`')
                            },
                            expressionProperties: {
                                'templateOptions.minDate': (model) => model?.after
                            }
                        }
                    ]
                }
            ],
            formGroup: new FormGroup({}),
            getFilter: model => {
                const filter = {};
                const dates = model && model.registrationDate;
                if (dates && (dates.after || dates.before)) {
                    filter.__and = [];
                    if (dates.after) {
                        const after = this.formatDate(dates.after);
                        filter.__and.push({
                            __or: {
                                [this.path]: { __gt: after },
                                [`${this.path}.date`]: { __gt: after }
                            }
                        });
                    }
                    if (dates.before) {
                        const before = this.formatDate(dates.before);
                        filter.__and.push({
                            __or: {
                                [this.path]: { __lt: before },
                                [`${this.path}.date`]: { __lt: before }
                            }
                        });
                    }
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: `${this.path}.date` }, { path: this.path }]
        };
    }
    formatDate(dateToFormat) {
        return new Date(dateToFormat).toISOString();
    }
}

class SerialNumberCellRendererComponent {
    constructor(context, columnUtilService) {
        this.context = context;
        this.columnUtilService = columnUtilService;
    }
}
SerialNumberCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SerialNumberCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }, { token: ColumnUtilService }], target: i0.ɵɵFactoryTarget.Component });
SerialNumberCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: SerialNumberCellRendererComponent, selector: "ng-component", ngImport: i0, template: ` {{ columnUtilService.getSerialNumber(context.item) }} `, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SerialNumberCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: ` {{ columnUtilService.getSerialNumber(context.item) }} `
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }, { type: ColumnUtilService }]; } });

class SerialNumberDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        const hardwareSerialNumberPath = 'c8y_Hardware.serialNumber';
        const vendingSerialNumberPath = 'com_nsn_startups_vendme_fragments_VendingMachineTypeInfo.serial';
        this.name = 'serialNumber';
        this.header = gettext('Serial number');
        this.cellRendererComponent = SerialNumberCellRendererComponent;
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'serialNumbers',
                label: gettext('Show items with serial number'),
                addText: gettext('Add next`serial number`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: '54321-123'
            }),
            getFilter(model) {
                const filter = {};
                if (model.serialNumbers.length) {
                    filter.__or = {
                        [hardwareSerialNumberPath]: { __in: model.serialNumbers },
                        [vendingSerialNumberPath]: { __in: model.serialNumbers }
                    };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: hardwareSerialNumberPath }, { path: vendingSerialNumberPath }]
        };
    }
}

class StatusCellRendererComponent {
    constructor(context) {
        this.context = context;
    }
}
StatusCellRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StatusCellRendererComponent, deps: [{ token: i1$1.CellRendererContext }], target: i0.ɵɵFactoryTarget.Component });
StatusCellRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: StatusCellRendererComponent, selector: "ng-component", ngImport: i0, template: ` <device-status [mo]="context.item"></device-status> `, isInline: true, dependencies: [{ kind: "component", type: i1$1.DeviceStatusComponent, selector: "device-status", inputs: ["mo"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StatusCellRendererComponent, decorators: [{
            type: Component,
            args: [{
                    template: ` <device-status [mo]="context.item"></device-status> `
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CellRendererContext }]; } });

class StatusDeviceGridColumn extends BaseColumn {
    constructor() {
        super();
        const responseIntervalPath = 'c8y_RequiredAvailability.responseInterval';
        const responseIntervalLessThanOrEqualTo0 = { [responseIntervalPath]: { __le: 0 } };
        const responseIntervalNotDefined = { __not: { __has: responseIntervalPath } };
        const availabilityStatusPath = 'c8y_Availability.status';
        const availabilityStatusAvailable = { [availabilityStatusPath]: SendStatus.AVAILABLE };
        const availabilityStatusUnavailable = { [availabilityStatusPath]: SendStatus.UNAVAILABLE };
        const availabilityStatusMaintenance = { [availabilityStatusPath]: SendStatus.MAINTENANCE };
        const availabilityStatusNotDefined = { __not: { __has: availabilityStatusPath } };
        const connectionStatusPath = 'c8y_Connection.status';
        const connectionStatusConnected = { [connectionStatusPath]: PushStatus.CONNECTED };
        const connectionStatusDisconnected = { [connectionStatusPath]: PushStatus.DISCONNECTED };
        const connectionStatusMaintenance = { [connectionStatusPath]: PushStatus.MAINTENANCE };
        const deviceUnderMaintenance = {
            __or: [
                responseIntervalLessThanOrEqualTo0,
                availabilityStatusMaintenance,
                connectionStatusMaintenance
            ]
        };
        const deviceNotUnderMaintenance = {
            // using __and of __nots because backend does not support __not with __ors
            __and: [
                { __not: responseIntervalLessThanOrEqualTo0 },
                { __not: availabilityStatusMaintenance },
                { __not: connectionStatusMaintenance }
            ]
        };
        this.name = 'status';
        this.header = gettext('Status');
        this.dataType = "icon" /* ColumnDataType.Icon */;
        this.cellRendererComponent = StatusCellRendererComponent;
        this.resizable = false;
        this.filterable = true;
        this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    sendStatus: {
                        title: gettext('Show devices with send status'),
                        type: 'object',
                        properties: {
                            sendOnline: {
                                type: 'switch',
                                title: gettext('Online')
                            },
                            sendOffline: {
                                type: 'switch',
                                title: gettext('Offline')
                            },
                            sendUnknown: {
                                type: 'switch',
                                title: gettext('Unknown')
                            },
                            sendNotMonitored: {
                                type: 'switch',
                                title: gettext('Not monitored')
                            }
                        }
                    },
                    pushStatus: {
                        title: gettext('Show devices with push status'),
                        type: 'object',
                        properties: {
                            pushOnline: {
                                type: 'switch',
                                title: gettext('Online')
                            },
                            pushOffline: {
                                type: 'switch',
                                title: gettext('Offline')
                            },
                            pushNotMonitored: {
                                type: 'switch',
                                title: gettext('Not monitored')
                            }
                        }
                    },
                    maintenanceStatus: {
                        title: gettext('Show devices with maintenance status'),
                        type: 'object',
                        properties: {
                            maintenance: {
                                type: 'switch',
                                title: gettext('Device is under maintenance')
                            }
                        }
                    }
                }
            },
            formGroup: new FormGroup({}),
            getFilter(model) {
                const filter = {};
                const ors = [];
                if (model?.sendStatus?.sendOnline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, availabilityStatusAvailable]
                    });
                }
                if (model?.sendStatus?.sendOffline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, availabilityStatusUnavailable]
                    });
                }
                if (model?.sendStatus?.sendUnknown) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, availabilityStatusNotDefined]
                    });
                }
                if (model?.sendStatus?.sendNotMonitored || model?.pushStatus?.pushNotMonitored) {
                    ors.push(responseIntervalNotDefined);
                }
                if (model?.pushStatus?.pushOnline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, connectionStatusConnected]
                    });
                }
                if (model?.pushStatus?.pushOffline) {
                    ors.push({
                        __and: [deviceNotUnderMaintenance, connectionStatusDisconnected]
                    });
                }
                if (model?.maintenanceStatus?.maintenance) {
                    ors.push(deviceUnderMaintenance);
                }
                if (ors.length) {
                    filter.__or = ors;
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: availabilityStatusPath }]
        };
    }
}

class SystemIdDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.path = 'id';
        this.name = 'systemId';
        this.header = gettext('System ID');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'ids',
                label: gettext('Show items with system ID'),
                addText: gettext('Add next`id`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: '10300'
            }),
            getFilter: (model) => {
                const filter = {};
                if (model.ids.length) {
                    filter[this.path] = { __in: model.ids };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = {
            pathSortingConfigs: [{ path: this.path }]
        };
    }
}

class TypeDeviceGridColumn extends BaseColumn {
    constructor(initialColumnConfig) {
        super(initialColumnConfig);
        this.name = 'type';
        this.path = 'type';
        this.header = gettext('Type');
        this.filterable = true;
        this.filteringConfig = {
            fields: getBasicInputArrayFormFieldConfig({
                key: 'types',
                label: gettext('Show devices with type'),
                addText: gettext('Add next`type`'),
                tooltip: gettext('Use * as a wildcard character'),
                placeholder: gettext('MyType`DEVICE_TYPE`')
            }),
            getFilter(model) {
                const filter = {};
                if (model.types.length) {
                    filter.type = { __in: model.types };
                }
                return filter;
            }
        };
        this.sortable = true;
        this.sortingConfig = { pathSortingConfigs: [{ path: 'type' }] };
    }
}

class DeviceGridService extends DataGridService {
    constructor(inventoryService, userService, translateService, alertService, modal, columnUtilService, userPreferencesService) {
        super(userPreferencesService);
        this.inventoryService = inventoryService;
        this.userService = userService;
        this.translateService = translateService;
        this.alertService = alertService;
        this.modal = modal;
        this.columnUtilService = columnUtilService;
        this.userPreferencesService = userPreferencesService;
        this.GRID_CONFIG_DEFAULT_STORAGE_KEY = 'device-grid-config';
    }
    getDefaultColumns() {
        const defaultColumns = [
            new StatusDeviceGridColumn(),
            new NameDeviceGridColumn(),
            new ModelDeviceGridColumn(),
            new SerialNumberDeviceGridColumn(),
            new GroupDeviceGridColumn(),
            new RegistrationDateDeviceGridColumn(),
            new SystemIdDeviceGridColumn(),
            new ImeiDeviceGridColumn(),
            new AlarmsDeviceGridColumn()
        ];
        return defaultColumns;
    }
    getChildDeviceGridColumns() {
        const childDeviceGridColumn = [
            new StatusDeviceGridColumn(),
            new NameDeviceGridColumn(),
            new ModelDeviceGridColumn(),
            new SerialNumberDeviceGridColumn(),
            new RegistrationDateDeviceGridColumn(),
            new SystemIdDeviceGridColumn(),
            new ImeiDeviceGridColumn(),
            new AlarmsDeviceGridColumn()
        ];
        return childDeviceGridColumn;
    }
    getDefaultPagination() {
        return {
            pageSize: 25,
            currentPage: 1
        };
    }
    getInfiniteScrollPagination() {
        return {
            pageSize: 50,
            currentPage: 1
        };
    }
    getDefaultActionControls() {
        return [
            {
                type: "DELETE" /* DeviceGridActionType.Delete */,
                callback: (item) => this.delete(item)
            }
        ];
    }
    getDefaultBulkActionControls() {
        return [];
    }
    getDefaultHeaderActionControls() {
        return [];
    }
    getProperName(device) {
        return this.columnUtilService.getProperName(device);
    }
    getModel(device) {
        return this.columnUtilService.getModel(device);
    }
    getSerialNumber(device) {
        return this.columnUtilService.getSerialNumber(device);
    }
    getParentsNames(device, featuredParentId) {
        return this.columnUtilService.getParentsNames(device, featuredParentId);
    }
    getHref(groupOrDevice, prefix = '#/') {
        return this.columnUtilService.getHref(groupOrDevice, prefix);
    }
    getAlarmsHref(device) {
        return this.columnUtilService.getAlarmsHref(device);
    }
    async delete(device) {
        try {
            const deviceWithChildren = await (await this.inventoryService.detail(device, { withChildren: true })).data;
            const hasChildDevices = deviceWithChildren.childDevices?.references?.length > 0;
            const hasChildAdditions = deviceWithChildren.childAdditions?.references?.length > 0;
            const hasChildAssets = deviceWithChildren.childAssets?.references?.length > 0;
            const showDeleteChildren = () => hasChildAdditions || hasChildDevices || hasChildAssets;
            const modalResult = await this.modal.confirm(gettext('Delete device'), this.translateService.instant(gettext(`You are about to delete device "{{ name }}". Do you want to proceed?`), device), Status.DANGER, { ok: gettext('Delete'), cancel: gettext('Cancel') }, {
                cascade: {
                    text: gettext('Also delete child hierarchy of this device.'),
                    checked: showDeleteChildren(),
                    showIf: showDeleteChildren,
                    disabledByKey: 'withDeviceUser'
                },
                withDeviceUser: {
                    text: this.translateService.instant(gettext('Also delete associated device owner "{{ owner }}".'), device),
                    checked: false,
                    showIf: () => {
                        const isRootDevice = device.c8y_IsDevice;
                        const hasDeviceUserAsOwner = device.owner &&
                            this.userService.isDeviceUser({ id: device.owner });
                        return Boolean(isRootDevice && hasDeviceUserAsOwner);
                    },
                    disabledByKey: 'cascade'
                }
            });
            await this.inventoryService.delete(device, modalResult.confirmOptions);
            this.alertService.success(gettext('Device deleted.'));
            return Promise.resolve();
        }
        catch (ex) {
            // only if not cancel from modal
            if (ex) {
                this.alertService.addServerFailure(ex);
            }
            return Promise.reject();
        }
    }
    async getData(columns, pagination, query = {}, withChildren = false, text = null) {
        const filters = {
            ...this.getDevicesFilters(columns, pagination, query, false, text),
            withGroups: true,
            withChildren
        };
        return this.inventoryService.list(filters);
    }
    async getChildDeviceData(columns, pagination, query = {}, withChildren = false, id) {
        const childDeviceFilters = true;
        const filters = {
            ...this.getDevicesFilters(columns, pagination, query, childDeviceFilters),
            withGroups: true,
            withChildren
        };
        return this.inventoryService.childDevicesList(id, filters);
    }
    async getCount(columns, pagination, query = {}, text = null) {
        const filters = {
            ...this.getDevicesFilters(columns, pagination, query, false, text),
            pageSize: 1,
            currentPage: 1
        };
        return (await this.inventoryService.list(filters)).paging.totalPages;
    }
    async getCountChildDevices(columns, pagination, query = {}, id) {
        const childDeviceFilters = true;
        const filters = {
            ...this.getDevicesFilters(columns, pagination, query, childDeviceFilters),
            pageSize: 1,
            currentPage: 1
        };
        return (await this.inventoryService.childDevicesList(id, filters)).paging.totalPages;
    }
    async getTotalChildDevices(query = {}, id) {
        const filters = {
            q: this.queriesUtil.buildQuery(query),
            pageSize: 1,
            withTotalPages: true
        };
        return (await this.inventoryService.childDevicesList(id, filters)).paging.totalPages;
    }
    async getTotal(query = {}) {
        const filters = {
            q: this.queriesUtil.buildQuery(query),
            pageSize: 1,
            withTotalPages: true
        };
        return (await this.inventoryService.list(filters)).paging.totalPages;
    }
    getDeviceQueryString(columns, query) {
        let fullQuery = this.getQueryObj(columns);
        fullQuery = this.queriesUtil.addAndFilter(fullQuery, query);
        return this.queriesUtil.buildQuery(fullQuery);
    }
    clearConfig(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        super.clearConfig(key);
    }
    getConfig$(key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        return super.getConfig$(key);
    }
    saveConfig$(config, key = this.GRID_CONFIG_DEFAULT_STORAGE_KEY) {
        return super.saveConfig$(config, key);
    }
    getDevicesFilters(columns, pagination, query, childDeviceFilters, text) {
        return {
            ...(childDeviceFilters
                ? { query: this.getDeviceQueryString(columns, query) }
                : { q: this.getDeviceQueryString(columns, query) }),
            ...(text && { text }),
            pageSize: pagination.pageSize,
            currentPage: pagination.currentPage,
            withChildren: false,
            withTotalPages: true
        };
    }
}
DeviceGridService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridService, deps: [{ token: i1$2.InventoryService }, { token: i1$2.UserService }, { token: i1.TranslateService }, { token: i1$1.AlertService }, { token: i1$1.ModalService }, { token: ColumnUtilService }, { token: i1$1.UserPreferencesService }], target: i0.ɵɵFactoryTarget.Injectable });
DeviceGridService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1$2.InventoryService }, { type: i1$2.UserService }, { type: i1.TranslateService }, { type: i1$1.AlertService }, { type: i1$1.ModalService }, { type: ColumnUtilService }, { type: i1$1.UserPreferencesService }]; } });

/**
 * A hook to use for Multi Provider extension.
 * @deprecated Consider using the `hookDeviceGridAction` function instead.
 */
const HOOK_DEVICE_GRID_ACTION = new InjectionToken('DeviceGridActionHook');
/**
 * You can either provide a single `DeviceGridActionExtension` as parameter:
 * ```typescript
 *  hookDeviceGridAction(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookDeviceGridAction([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<DeviceGridActionExtension>`
 * ```typescript
 *  export class MyDeviceGridActionFactory implements ExtensionFactory<DeviceGridActionExtension> {...}
 *  ...
 *  hookDeviceGridAction(MyDeviceGridActionFactory)
 * ```
 * A typed alternative to `HOOK_DEVICE_GRID_ACTION_DELETE`.
 * @param action The `DeviceGridDeleteExtension`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
function hookDeviceGridAction(action, options) {
    return hookGeneric(action, HOOK_DEVICE_GRID_ACTION, options);
}
/**
 * A service which defines device grid action options.
 */
class DeviceGridExtensionService extends ExtensionPointWithoutStateForPlugins {
    constructor(rootInjector, plugins, router, deviceGridService) {
        super(rootInjector, plugins);
        this.router = router;
        this.deviceGridService = deviceGridService;
        this.items$ = this.setupItemsObservable();
    }
    setupItemsObservable() {
        return fromTriggerOnce(this.router, this.refresh$, [
            () => flatten(this.injectors.map(injector => injector.get(HOOK_DEVICE_GRID_ACTION, [
                {
                    type: "DELETE" /* BuiltInActionType.Delete */,
                    deviceMatches: (_mo) => true,
                    onAction: (mo) => this.deviceGridService.delete(mo),
                    refreshAfterActionDone: true
                }
            ], { self: true }))),
            () => this.factories
        ]).pipe(shareReplay(1));
    }
}
DeviceGridExtensionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridExtensionService, deps: [{ token: i0.Injector }, { token: i1$1.PluginsResolveService }, { token: i2$2.Router }, { token: DeviceGridService }], target: i0.ɵɵFactoryTarget.Injectable });
DeviceGridExtensionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridExtensionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridExtensionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1$1.PluginsResolveService }, { type: i2$2.Router }, { type: DeviceGridService }]; } });

class DeviceGridComponent {
    /** Pagination settings, e.g. allows for setting current page or page size. If not given, defaults to standard settings. */
    set _pagination(value) {
        if (value) {
            this.pagination = value;
        }
    }
    /** Sets load more mode. */
    set _infiniteScroll(infiniteScroll) {
        this.infiniteScroll = infiniteScroll;
        if (infiniteScroll) {
            this.pagination = this.deviceGridService.getInfiniteScrollPagination();
        }
    }
    /** Sets action controls (actions available for individual items). If not given, it defaults to standard actions. */
    set _actionControls(value) {
        if (value) {
            this.actionControls = value;
        }
        else {
            this.actionControls = this.deviceGridService.getDefaultActionControls();
        }
    }
    /** Sets bulk action controls (actions available for items selected by user). If not given, it defaults to standard bulk actions. */
    set _bulkActionControls(value) {
        if (value) {
            this.bulkActionControls = value;
        }
        else {
            this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        }
    }
    /** Sets header action controls (actions available from the grid header). If not given, it defaults to empty list of actions. */
    set _headerActionControls(value) {
        if (value) {
            this.headerActionControls = value;
        }
        else {
            this.headerActionControls = this.deviceGridService.getDefaultHeaderActionControls();
        }
    }
    constructor(deviceGridService, dgExtensionService) {
        this.deviceGridService = deviceGridService;
        this.dgExtensionService = dgExtensionService;
        /** Takes an event emitter. When an event is emitted, the grid will be reloaded. */
        this.refresh = new EventEmitter();
        /** The title for the data grid, it's displayed in the grid's header. */
        this.title = gettext('Devices');
        /** The label for load more button. */
        this.loadMoreItemsLabel = gettext('Load more devices');
        /** The label for loading indicator. */
        this.loadingItemsLabel = gettext('Loading devices…');
        /** The list of columns to be displayed in the grid. If not given, it defaults to standard columns. */
        this.columns = this.deviceGridService.getDefaultColumns();
        /** Determines whether items can be selected by clicking a checkbox in the first column. */
        this.selectable = false;
        /** Restricts selection to a single row only. Selection column displays radio button instead of checkboxes */
        this.singleSelection = false;
        /** Sets the base query which is appended to the request for data. */
        this.baseQuery = {};
        this.childDeviceGrid = false;
        /** Sets the withChildren query which is appended to the request. */
        this.withChildren = false;
        /**
         * Enables the search for devices where any device propery is matched agains the search term.
         * Enabled by default. This input does not take effect if the <code>childDeviceGrid</code> input is set to <code>true</code>
         */
        this.showSearch = true;
        /**
         * Sets the class name used for active rows (last clicked).
         * Set empty string to disable appending active class to grid rows.
         */
        this.activeClassName = 'active';
        /** Emits an event when columns configuration changes. */
        this.onColumnsChange = new EventEmitter();
        this.onFilterChange = new EventEmitter();
        this.onDeviceQueryStringChange = new EventEmitter();
        /** Emits an event when items selection changes. The array contains ids of selected items. */
        this.itemsSelect = new EventEmitter();
        this.actionControls = [];
        this.appliedFilters = [];
        this.pagination = this.deviceGridService.getDefaultPagination();
        this.bulkActionControls = this.deviceGridService.getDefaultBulkActionControls();
        this.headerActionControls = this.deviceGridService.getDefaultHeaderActionControls();
        this.destroyed$ = new Subject();
        this.serverSideDataCallback = this.onDataSourceModifier.bind(this);
    }
    ngOnInit() {
        this.setActionControls();
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    trackByName(_index, column) {
        return column.name;
    }
    async onDataSourceModifier(dataSourceModifier) {
        let serverSideDataResult;
        let filteredSize;
        let size;
        if (this.childDeviceGrid) {
            const { res, data, paging } = await this.deviceGridService.getChildDeviceData(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.withChildren, this.parentDeviceId);
            filteredSize = await this.deviceGridService.getCountChildDevices(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.parentDeviceId);
            size = await this.deviceGridService.getTotalChildDevices(this.baseQuery, this.parentDeviceId);
            serverSideDataResult = {
                res,
                data,
                paging,
                filteredSize,
                size
            };
        }
        else {
            const { res, data, paging } = await this.deviceGridService.getData(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, this.withChildren, dataSourceModifier.searchText);
            filteredSize = await this.deviceGridService.getCount(dataSourceModifier.columns, dataSourceModifier.pagination, this.baseQuery, dataSourceModifier.searchText);
            size = await this.deviceGridService.getTotal(this.baseQuery);
            serverSideDataResult = {
                res,
                data,
                paging,
                filteredSize,
                size
            };
        }
        this.onColumnsChange.emit(dataSourceModifier.columns);
        this.onDeviceQueryStringChange.emit(this.deviceGridService.getDeviceQueryString(dataSourceModifier.columns, this.baseQuery));
        if (this.dataCallback) {
            serverSideDataResult = this.dataCallback(serverSideDataResult);
        }
        return serverSideDataResult;
    }
    setActionControls() {
        const asArrayOfGroupedActionHooks = (hooks) => Object.values(groupBy(hooks, 'type'));
        this.dgExtensionService.items$
            .pipe(map$1(asArrayOfGroupedActionHooks), switchMap(from), map$1((hooks) => {
            const { type, icon, text, showOnHover } = hooks[0];
            const matchingHooks = (device) => hooks.filter(hook => hook.deviceMatches(device));
            const hasMatchingHooks = (device) => !!matchingHooks(device).length;
            const useInventoryDelete = (device) => !hasMatchingHooks(device) && type === "DELETE" /* BuiltInActionType.Delete */;
            const resolveAction = (device) => useInventoryDelete(device)
                ? this.deviceGridService.delete(device)
                : matchingHooks(device)[0].onAction(device);
            this.actionControls.push({
                type,
                icon,
                text,
                showOnHover,
                showIf: (device) => type === "DELETE" /* BuiltInActionType.Delete */ || hasMatchingHooks(device),
                callback: (device) => toObservable(resolveAction(device))
                    .pipe(catchError(_err => EMPTY), takeUntil(this.destroyed$))
                    .subscribe(_success => {
                    if (useInventoryDelete(device) || matchingHooks(device)[0].refreshAfterActionDone)
                        this.refresh.emit();
                })
            });
        }), takeUntil(this.destroyed$))
            .subscribe();
    }
    updateFiltering(columnNames, action) {
        const { type } = action;
        if (type === FilteringActionType.ResetFilter) {
            this.dataGrid.clearFilters();
        }
        else {
            this.dataGrid.updateFiltering(columnNames, action);
        }
    }
}
DeviceGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridComponent, deps: [{ token: DeviceGridService }, { token: DeviceGridExtensionService }], target: i0.ɵɵFactoryTarget.Component });
DeviceGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: DeviceGridComponent, selector: "c8y-device-grid", inputs: { dataCallback: "dataCallback", refresh: "refresh", title: "title", loadMoreItemsLabel: "loadMoreItemsLabel", loadingItemsLabel: "loadingItemsLabel", legacyConfigKey: "legacyConfigKey", legacyFilterKey: "legacyFilterKey", columns: "columns", _pagination: ["pagination", "_pagination"], _infiniteScroll: ["infiniteScroll", "_infiniteScroll"], _actionControls: ["actionControls", "_actionControls"], selectable: "selectable", singleSelection: "singleSelection", baseQuery: "baseQuery", _bulkActionControls: ["bulkActionControls", "_bulkActionControls"], _headerActionControls: ["headerActionControls", "_headerActionControls"], childDeviceGrid: "childDeviceGrid", parentDeviceId: "parentDeviceId", withChildren: "withChildren", showSearch: "showSearch", activeClassName: "activeClassName" }, outputs: { onColumnsChange: "onColumnsChange", onFilterChange: "onFilterChange", onDeviceQueryStringChange: "onDeviceQueryStringChange", itemsSelect: "itemsSelect" }, providers: [
        {
            provide: PRODUCT_EXPERIENCE_EVENT_SOURCE,
            useExisting: forwardRef(() => DeviceGridComponent)
        }
    ], viewQueries: [{ propertyName: "dataGrid", first: true, predicate: DataGridComponent, descendants: true, static: true }], ngImport: i0, template: "<c8y-data-grid\n  [title]=\"title\"\n  [loadMoreItemsLabel]=\"loadMoreItemsLabel\"\n  [loadingItemsLabel]=\"loadingItemsLabel\"\n  [columns]=\"columns\"\n  [pagination]=\"pagination\"\n  [infiniteScroll]=\"infiniteScroll\"\n  [actionControls]=\"actionControls\"\n  [selectable]=\"selectable\"\n  [singleSelection]=\"singleSelection\"\n  [bulkActionControls]=\"bulkActionControls\"\n  [serverSideDataCallback]=\"serverSideDataCallback\"\n  (itemsSelect)=\"itemsSelect.emit($event)\"\n  [refresh]=\"refresh\"\n  [showSearch]=\"showSearch && !childDeviceGrid\"\n  [headerActionControls]=\"headerActionControls\"\n  [activeClassName]=\"activeClassName\"\n  c8yProductExperience\n  inherit\n>\n  <c8y-ui-empty-state\n    [icon]=\"'search'\"\n    [title]=\"'No matching devices.' | translate\"\n    [subtitle]=\"'Refine your search terms' | translate\"\n    [horizontal]=\"true\"\n  ></c8y-ui-empty-state>\n\n  <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n    <c8y-column [name]=\"column.name\"></c8y-column>\n  </ng-container>\n</c8y-data-grid>\n", dependencies: [{ kind: "component", type: i1$1.EmptyStateComponent, selector: "c8y-ui-empty-state", inputs: ["icon", "title", "subtitle", "horizontal"] }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1$1.ColumnDirective, selector: "c8y-column", inputs: ["name"] }, { kind: "component", type: i1$1.DataGridComponent, selector: "c8y-data-grid", inputs: ["title", "loadMoreItemsLabel", "loadingItemsLabel", "showSearch", "refresh", "columns", "rows", "pagination", "infiniteScroll", "serverSideDataCallback", "selectable", "singleSelection", "selectionPrimaryKey", "displayOptions", "actionControls", "bulkActionControls", "headerActionControls", "searchText", "configureColumnsEnabled", "showCounterWarning", "activeClassName"], outputs: ["rowMouseOver", "rowMouseLeave", "rowClick", "onConfigChange", "onBeforeFilter", "onBeforeSearch", "onFilter", "itemsSelect", "onReload", "onAddCustomColumn", "onRemoveCustomColumn", "onColumnFilterReset", "onSort", "onPageSizeChange", "onColumnReordered", "onColumnVisibilityChange"] }, { kind: "directive", type: i1$1.ProductExperienceDirective, selector: "[c8yProductExperience]", inputs: ["actionName", "actionData", "inherit", "suppressDataOverriding"] }, { kind: "pipe", type: i1$1.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-device-grid', providers: [
                        {
                            provide: PRODUCT_EXPERIENCE_EVENT_SOURCE,
                            useExisting: forwardRef(() => DeviceGridComponent)
                        }
                    ], template: "<c8y-data-grid\n  [title]=\"title\"\n  [loadMoreItemsLabel]=\"loadMoreItemsLabel\"\n  [loadingItemsLabel]=\"loadingItemsLabel\"\n  [columns]=\"columns\"\n  [pagination]=\"pagination\"\n  [infiniteScroll]=\"infiniteScroll\"\n  [actionControls]=\"actionControls\"\n  [selectable]=\"selectable\"\n  [singleSelection]=\"singleSelection\"\n  [bulkActionControls]=\"bulkActionControls\"\n  [serverSideDataCallback]=\"serverSideDataCallback\"\n  (itemsSelect)=\"itemsSelect.emit($event)\"\n  [refresh]=\"refresh\"\n  [showSearch]=\"showSearch && !childDeviceGrid\"\n  [headerActionControls]=\"headerActionControls\"\n  [activeClassName]=\"activeClassName\"\n  c8yProductExperience\n  inherit\n>\n  <c8y-ui-empty-state\n    [icon]=\"'search'\"\n    [title]=\"'No matching devices.' | translate\"\n    [subtitle]=\"'Refine your search terms' | translate\"\n    [horizontal]=\"true\"\n  ></c8y-ui-empty-state>\n\n  <ng-container *ngFor=\"let column of columns; trackBy: trackByName\">\n    <c8y-column [name]=\"column.name\"></c8y-column>\n  </ng-container>\n</c8y-data-grid>\n" }]
        }], ctorParameters: function () { return [{ type: DeviceGridService }, { type: DeviceGridExtensionService }]; }, propDecorators: { dataCallback: [{
                type: Input
            }], refresh: [{
                type: Input
            }], title: [{
                type: Input
            }], loadMoreItemsLabel: [{
                type: Input
            }], loadingItemsLabel: [{
                type: Input
            }], legacyConfigKey: [{
                type: Input
            }], legacyFilterKey: [{
                type: Input
            }], columns: [{
                type: Input,
                args: ['columns']
            }], _pagination: [{
                type: Input,
                args: ['pagination']
            }], _infiniteScroll: [{
                type: Input,
                args: ['infiniteScroll']
            }], _actionControls: [{
                type: Input,
                args: ['actionControls']
            }], selectable: [{
                type: Input
            }], singleSelection: [{
                type: Input
            }], baseQuery: [{
                type: Input
            }], _bulkActionControls: [{
                type: Input,
                args: ['bulkActionControls']
            }], _headerActionControls: [{
                type: Input,
                args: ['headerActionControls']
            }], childDeviceGrid: [{
                type: Input
            }], parentDeviceId: [{
                type: Input
            }], withChildren: [{
                type: Input
            }], showSearch: [{
                type: Input
            }], activeClassName: [{
                type: Input
            }], onColumnsChange: [{
                type: Output
            }], onFilterChange: [{
                type: Output
            }], onDeviceQueryStringChange: [{
                type: Output
            }], itemsSelect: [{
                type: Output
            }], dataGrid: [{
                type: ViewChild,
                args: [DataGridComponent, { static: true }]
            }] } });

class DeviceGridModule {
}
DeviceGridModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DeviceGridModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridModule, declarations: [DeviceGridComponent,
        GroupFilteringFormRendererComponent,
        StatusCellRendererComponent,
        NameCellRendererComponent,
        ModelCellRendererComponent,
        SerialNumberCellRendererComponent,
        GroupCellRendererComponent,
        RegistrationDateCellRendererComponent,
        AlarmsCellRendererComponent,
        AlarmsHeaderCellRendererComponent], imports: [CommonModule,
        FormsModule,
        DeviceStatusModule,
        DataGridModule,
        AssetSelectorModule,
        DynamicFormsModule,
        PopoverModule,
        RouterModule,
        ProductExperienceModule], exports: [DeviceGridComponent,
        GroupFilteringFormRendererComponent,
        StatusCellRendererComponent,
        NameCellRendererComponent,
        ModelCellRendererComponent,
        SerialNumberCellRendererComponent,
        GroupCellRendererComponent,
        RegistrationDateCellRendererComponent,
        AlarmsCellRendererComponent,
        AlarmsHeaderCellRendererComponent] });
DeviceGridModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridModule, imports: [CommonModule,
        FormsModule,
        DeviceStatusModule,
        DataGridModule,
        AssetSelectorModule,
        DynamicFormsModule,
        PopoverModule,
        RouterModule,
        ProductExperienceModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DeviceGridModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        DeviceStatusModule,
                        DataGridModule,
                        AssetSelectorModule,
                        DynamicFormsModule,
                        PopoverModule,
                        RouterModule,
                        ProductExperienceModule
                    ],
                    declarations: [
                        DeviceGridComponent,
                        GroupFilteringFormRendererComponent,
                        StatusCellRendererComponent,
                        NameCellRendererComponent,
                        ModelCellRendererComponent,
                        SerialNumberCellRendererComponent,
                        GroupCellRendererComponent,
                        RegistrationDateCellRendererComponent,
                        AlarmsCellRendererComponent,
                        AlarmsHeaderCellRendererComponent
                    ],
                    exports: [
                        DeviceGridComponent,
                        GroupFilteringFormRendererComponent,
                        StatusCellRendererComponent,
                        NameCellRendererComponent,
                        ModelCellRendererComponent,
                        SerialNumberCellRendererComponent,
                        GroupCellRendererComponent,
                        RegistrationDateCellRendererComponent,
                        AlarmsCellRendererComponent,
                        AlarmsHeaderCellRendererComponent
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AlarmsCellRendererComponent, AlarmsDeviceGridColumn, AlarmsHeaderCellRendererComponent, ColumnUtilService, DeviceGridComponent, DeviceGridExtensionService, DeviceGridModule, DeviceGridService, GroupCellRendererComponent, GroupDeviceGridColumn, GroupFilteringFormRendererComponent, HOOK_DEVICE_GRID_ACTION, ImeiDeviceGridColumn, ModelCellRendererComponent, ModelDeviceGridColumn, NameCellRendererComponent, NameDeviceGridColumn, RegistrationDateCellRendererComponent, RegistrationDateDeviceGridColumn, SerialNumberCellRendererComponent, SerialNumberDeviceGridColumn, StatusCellRendererComponent, StatusDeviceGridColumn, SystemIdDeviceGridColumn, TypeDeviceGridColumn, hookDeviceGridAction };
//# sourceMappingURL=c8y-ngx-components-device-grid.mjs.map
