import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import * as i1 from '@c8y/client';
import { AlarmService, ApplicationService, AuditService, BasicAuth, CookieAuth, DeviceRegistrationBulkService, DeviceRegistrationService, EventBinaryService, EventService, FetchClient, IdentityService, InventoryBinaryService, InventoryRoleService, InventoryService, MeasurementService, OperationBulkService, OperationService, Realtime, SmartGroupsService, SmartRulesService, SystemOptionsService, TenantLoginOptionsService, TenantOptionsService, TenantSecurityOptionsService, TenantService, TrustedCertificateService, UserGroupService, UserRoleService, UserService } from '@c8y/client';
export { AlarmService, ApplicationService, AuditService, BasicAuth, CookieAuth, DeviceRegistrationBulkService, DeviceRegistrationService, EventBinaryService, EventService, FetchClient, IdentityService, InventoryBinaryService, InventoryRoleService, InventoryService, MeasurementService, OperationBulkService, OperationService, Realtime, SmartGroupsService, SmartRulesService, SystemOptionsService, TenantLoginOptionsService, TenantOptionsService, TenantSecurityOptionsService, TenantService, TrustedCertificateService, UserGroupService, UserRoleService, UserService } from '@c8y/client';
import { from, Subject, pipe } from 'rxjs';
import { filter } from 'rxjs/operators';

class HttpHandler {
}

class HttpInterceptHandler extends HttpHandler {
    constructor(interceptor, nextHandler) {
        super();
        this.interceptor = interceptor;
        this.nextHandler = nextHandler;
    }
    handle(req) {
        return this.interceptor.intercept(req, this.nextHandler);
    }
}
class HttpRequestHandler extends HttpHandler {
    constructor(fetch, apiService) {
        super();
        this.fetch = fetch;
        this.apiService = apiService;
    }
    handle(req) {
        const { options, url } = req;
        const { method } = options;
        this.apiService?.onStart({ method, options, url });
        let fetchPromise = this.fetch(url, options);
        if (typeof options.responseInterceptor === 'function') {
            fetchPromise = fetchPromise.then(options.responseInterceptor);
        }
        fetchPromise.then((response) => this.apiService?.onFinish({ method, options, url, response }), (response) => this.apiService?.onFinish({ method, options, url, response }));
        return from(fetchPromise);
    }
}

class ApiService {
    constructor(client) {
        this.client = client;
        this.callsSubject = new Subject();
        this.interceptors = new Map();
        this.interceptorCounter = 0;
        this.calls = this.callsSubject.asObservable();
        this.hookIntoClientFetch();
    }
    /**
     * Allows to hook into the responses received by the FetchClient.
     * This is meant to be used to react on the responses, not for manipulation of the responses.
     * @param hookFilter A filter function to filter for specific responses.
     * @returns An Observable of the filtered responses.
     */
    hookResponse(hookFilter) {
        return this.callsSubject.pipe(filter(({ phase }) => phase === 'finish'), filter(hookFilter));
    }
    /**
     * Allows to hook into the requests performed by the FetchClient.
     * This is meant to be used to react on the requests, not for manipulation of the requests.
     * @param hookFilter A filter function to filter for specific requests.
     * @returns An Observable of the filtered requests.
     */
    hookRequest(hookFilter) {
        return this.callsSubject.pipe(filter(({ phase }) => phase === 'start'), filter(hookFilter));
    }
    onFinish(call) {
        this.callsSubject.next({ phase: 'finish', ...call });
    }
    onStart(call) {
        this.callsSubject.next({ phase: 'start', ...call });
    }
    resolveData(call) {
        const { response, method, url } = call;
        if ('data' in response) {
            return Promise.resolve({ data: response.data, method, url });
        }
        else {
            // No Content success status, for example DELETE request.
            if (response?.status === 204) {
                return Promise.resolve({ data: null, method, url });
            }
            const cb = data => ({ data, method, url });
            return response.clone().json().then(cb, cb);
        }
    }
    /**
     * Can be added to a pipe to exclude any permission call. Permission calls are PUT
     * request with only an id in it, to verify if the user has access to this managed object.
     * @returns The operator to be added to a pipe.
     */
    excludePermissionCall() {
        return pipe(filter(({ method, options }) => {
            if (method === 'PUT' && options.body && typeof options.body === 'string') {
                const parsedBody = JSON.parse(options.body);
                const bodyKeys = Object.keys(parsedBody);
                return !(bodyKeys.length === 1 && bodyKeys[0] === 'id');
            }
            return true;
        }));
    }
    /**
     * Allows to intercept requests performed via the FetchClient requests.
     * @param interceptor The interceptor to be added.
     * @param id An optional unique identifier for the interceptor. The chain of interceptors is ordered by this id. And it can be used to remove the interceptor later on.
     * @returns The id of the interceptor (same as provided id if one was provided, otherwise an id will be generated).
     */
    addInterceptor(interceptor, id) {
        if (!id) {
            id = `${++this.interceptorCounter}`;
        }
        this.interceptors.set(id, interceptor);
        return id;
    }
    /**
     * Allows to remove a previously added interceptor by it's id.
     * @param id The id of the interceptor that should be removed.
     * @returns true if an interceptor existed and has been removed, or false if id does not exist.
     */
    removeInterceptor(id) {
        return this.interceptors.delete(id);
    }
    /**
     * Checks if an interceptor with a given id exists.
     * @param id The id of the interceptor.
     * @returns - Returns true if an interceptor with the given id exists, otherwise false.
     */
    hasInterceptor(id) {
        return this.interceptors.has(id);
    }
    hookIntoClientFetch() {
        const fetch = this.client.fetch.bind(this.client);
        const requestHandler = new HttpRequestHandler(fetch, this);
        this.client.fetch = async (url, options = { method: 'GET' }) => {
            const { method } = options;
            return this.createInterceptorChain({ url, options, method }, requestHandler).toPromise();
        };
    }
    createInterceptorChain(call, requestHandler) {
        let handler = requestHandler;
        // Do some sorting to always apply the interceptors in the specific order
        const sortedInterceptorIds = Array.from(this.interceptors.keys()).sort((a, b) => b.localeCompare(a));
        for (const interceptorId of sortedInterceptorIds) {
            handler = new HttpInterceptHandler(this.interceptors.get(interceptorId), handler);
        }
        return handler.handle(call);
    }
}
ApiService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ApiService, deps: [{ token: i1.FetchClient }], target: i0.ɵɵFactoryTarget.Injectable });
ApiService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ApiService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ApiService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.FetchClient }]; } });

var services = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AlarmService: AlarmService,
    ApplicationService: ApplicationService,
    AuditService: AuditService,
    BasicAuth: BasicAuth,
    CookieAuth: CookieAuth,
    DeviceRegistrationBulkService: DeviceRegistrationBulkService,
    DeviceRegistrationService: DeviceRegistrationService,
    EventBinaryService: EventBinaryService,
    EventService: EventService,
    FetchClient: FetchClient,
    IdentityService: IdentityService,
    InventoryBinaryService: InventoryBinaryService,
    InventoryRoleService: InventoryRoleService,
    InventoryService: InventoryService,
    MeasurementService: MeasurementService,
    OperationBulkService: OperationBulkService,
    OperationService: OperationService,
    Realtime: Realtime,
    SmartGroupsService: SmartGroupsService,
    SmartRulesService: SmartRulesService,
    SystemOptionsService: SystemOptionsService,
    TenantLoginOptionsService: TenantLoginOptionsService,
    TenantOptionsService: TenantOptionsService,
    TenantSecurityOptionsService: TenantSecurityOptionsService,
    TenantService: TenantService,
    TrustedCertificateService: TrustedCertificateService,
    UserGroupService: UserGroupService,
    UserRoleService: UserRoleService,
    UserService: UserService
});

function toProvider(provide) {
    let deps = [FetchClient, Realtime];
    if (provide === FetchClient) {
        deps = [CookieAuth];
    }
    if (provide === BasicAuth || provide === CookieAuth) {
        deps = [];
    }
    if (provide === Realtime) {
        deps = [FetchClient];
    }
    return { provide, useClass: provide, deps };
}
const providers = Object.keys(services)
    .map(k => toProvider(services[k]))
    .concat([{ provide: ApiService, useClass: ApiService, deps: [FetchClient] }]);
// @dynamic
class DataModule {
    static providers() {
        return providers;
    }
    static forRoot() {
        return {
            ngModule: DataModule,
            providers
        };
    }
}
DataModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DataModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DataModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: DataModule });
DataModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DataModule, providers: providers });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DataModule, decorators: [{
            type: NgModule,
            args: [{
                    providers
                }]
        }] });

// do not expose as it might confuse people on what to implement
// export * from './http-handler.model';

/**
 * Generated bundle index. Do not edit.
 */

export { ApiService, DataModule, HttpHandler };
//# sourceMappingURL=c8y-ngx-components-api.mjs.map
