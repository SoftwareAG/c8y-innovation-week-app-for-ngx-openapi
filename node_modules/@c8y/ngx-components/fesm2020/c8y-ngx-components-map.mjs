import * as i0 from '@angular/core';
import { InjectionToken, Directive, Injectable, EventEmitter, Component, Optional, Inject, ViewChild, ContentChild, Input, Output, SimpleChange, NgModule } from '@angular/core';
import * as i1$1 from '@c8y/ngx-components';
import { gettext, sortByPriority, ManagedObjectRealtimeService, CommonModule as CommonModule$1, FormsModule as FormsModule$1, RealtimeModule } from '@c8y/ngx-components';
import * as i3 from '@ngx-translate/core';
import { Subject, fromEvent, BehaviorSubject, NEVER, interval, of, merge, from } from 'rxjs';
import { takeUntil, map, switchMap, tap, filter, first, debounceTime, mergeMap } from 'rxjs/operators';
import { flatten, cloneDeep } from 'lodash-es';
import * as i1 from '@c8y/client';
import * as i1$2 from '@angular/common';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

function getStatus(device) {
    if (!device.c8y_ActiveAlarmsStatus) {
        return 'text-primary';
    }
    if (device.c8y_ActiveAlarmsStatus.critical) {
        return 'status critical';
    }
    if (device.c8y_ActiveAlarmsStatus.major) {
        return 'status major';
    }
    if (device.c8y_ActiveAlarmsStatus.warning) {
        return 'status warning';
    }
    if (device.c8y_ActiveAlarmsStatus.minor) {
        return 'status minor';
    }
    return 'text-primary';
}
function getC8yMarker(marker, asset) {
    marker.asset = asset;
    return marker;
}
const MAP_TILE_LAYER = new InjectionToken('MAP_TILE_LAYER');
var ClusterSize;
(function (ClusterSize) {
    ClusterSize[ClusterSize["NONE"] = 0] = "NONE";
    ClusterSize[ClusterSize["FOUR"] = 1] = "FOUR";
    ClusterSize[ClusterSize["SIXTEEN"] = 2] = "SIXTEEN";
})(ClusterSize || (ClusterSize = {}));
const MAP_DEFAULT_CONFIG = new InjectionToken('MAP_DEFAULT_CONFIG');
const defaultLayer = {
    layerUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    label: 'OpenStreetMap',
    priority: 1000,
    options: {
        maxZoom: 18,
        minZoom: 2,
        attribution: '&copy;<a href="http://www.openstreetmap.org/copyright" rel="noreferrer nofollow">OpenStreetMap</a>',
        noWrap: true
    }
};
const defaultMapConfig = {
    center: [51.23544, 6.79599],
    zoomLevel: 2
};

class ClusterMap {
    set clusterMarker(item) {
        this.removeClusterToBigMarker();
        this._clusterMarker = item;
    }
    get clusterMarker() {
        return this._clusterMarker;
    }
    set rect(item) {
        if (this._rect) {
            this._rect.remove();
        }
        this._rect = item;
    }
    get rect() {
        return this._rect;
    }
    constructor(iterable, addAssetCallback, translateService) {
        this.iterable = iterable;
        this.addAssetCallback = addAssetCallback;
        this.translateService = translateService;
        this.markers = [];
        this.positions = [];
        this.iterableDiffer = this.iterable.find(this.positions).create(this.trackBy);
    }
    render(map) {
        if (this._rect) {
            this._rect.addTo(map);
        }
        this.updateChanges(map);
        if (this._clusterMarker) {
            this._clusterMarker.addTo(map);
        }
    }
    clear(map) {
        this.removeClusterToBigMarker();
        this._rect.remove();
        this.positions = [];
        this.updateChanges(map);
    }
    removeClusterToBigMarker() {
        if (this._clusterMarker) {
            this._clusterMarker.remove();
            this._clusterMarker = null;
        }
    }
    addMarkerToMap(device, map) {
        const marker = this.addAssetCallback(device);
        this.markers.push(marker);
        marker.addTo(map);
    }
    setClusterToBigMarker(map, count, leaflet) {
        const bound = this.rect.getBounds();
        const text = this.translateService.instant(gettext('Zoom in'));
        const divMarker = leaflet.divIcon({
            html: `<div class="c8y-map-marker-count" data-count="${count}" title="${text}"></div>`
        });
        const labelIcon = leaflet.marker(bound.getCenter(), {
            icon: divMarker
        });
        labelIcon.addTo(map);
        labelIcon.on('click', () => {
            map.fitBounds(bound);
        });
        this.clusterMarker = labelIcon;
    }
    updateChanges(map) {
        const changes = this.iterableDiffer.diff(this.positions);
        if (changes) {
            changes.forEachRemovedItem((record) => {
                this.removeMarkerFromMap(record.item);
            });
            changes.forEachAddedItem((record) => {
                this.addMarkerToMap(record.item, map);
            });
        }
    }
    trackBy(index, item) {
        const trackItems = [item.id, item.c8y_Position.lat, item.c8y_Position.lng, getStatus(item)];
        return trackItems.join('');
    }
    removeMarkerFromMap(device) {
        const markers = this.markers.filter((marker) => marker.asset?.id === device.id);
        markers.forEach(marker => marker.remove());
    }
}

class MapPopupDirective {
    constructor(template, elementRef, viewContainer) {
        this.template = template;
        this.elementRef = elementRef;
        this.viewContainer = viewContainer;
    }
}
MapPopupDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapPopupDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
MapPopupDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.7", type: MapPopupDirective, selector: "[c8yMapPopup]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapPopupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[c8yMapPopup]'
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }]; } });

class MapService {
    constructor(inventory) {
        this.inventory = inventory;
        /**
         * The devices that are maximal displayed in one cluster.
         */
        this.MAX_DEVICE_PER_CLUSTER = 200;
        /**
         * The count until the cluster is sized. There are a maximum of
         * three clusters: 1, 4 or 16.
         */
        this.CLUSTER_LEVEL_THRESHOLD = 500;
    }
    /**
     * Returns the leaflet instance used by the cumulocity core.
     */
    async getLeaflet() {
        const c8yLeafletInstance = (await import('leaflet')).default;
        return c8yLeafletInstance;
    }
    /**
     * Verifies if a given managed object is a device with a position fragment.
     * @param mo The given managed object.
     */
    isPositionedDevice(mo) {
        return !!(mo?.c8y_IsDevice && this.hasPosition(mo));
    }
    /**
     * Verifies if a given managed object has a position fragment.
     * @param mo The given managed object.
     */
    hasPosition(mo) {
        return mo?.c8y_Position;
    }
    async getPositionMOs(bound, byGroupIdMO) {
        return this.getPositionMOsFromBound(bound, byGroupIdMO, false);
    }
    async getPositionMOsFromBoundCount(bound, byGroupIdMO) {
        return this.getPositionMOsFromBound(bound, byGroupIdMO, true);
    }
    async getPositionDevices(pageSize = this.MAX_DEVICE_PER_CLUSTER, count) {
        const { paging, data } = await this.inventory.list({
            pageSize: count ? 1 : pageSize,
            withTotalPages: count,
            query: '$filter=has(c8y_Position) and has(c8y_IsDevice)'
        });
        if (count) {
            return paging.totalPages;
        }
        return data;
    }
    async getPositionMOsFromBound(bound, byGroupIdMO, count = false) {
        const { lat: latMin, lng: lngMin } = bound.getSouthWest();
        const { lat: latMax, lng: lngMax } = bound.getNorthEast();
        const byGroupIdFilter = byGroupIdMO
            ? `(bygroupid(${byGroupIdMO.id}) or id eq '${byGroupIdMO.id}') and `
            : '';
        const boundFilter = `$filter=${byGroupIdFilter}has(c8y_Position) and c8y_Position.lng gt ${lngMin}d and c8y_Position.lat gt ${latMin}d and c8y_Position.lng lt ${lngMax}d and c8y_Position.lat lt ${latMax}d`;
        const { paging, data } = await this.inventory.list({
            pageSize: count ? 1 : this.MAX_DEVICE_PER_CLUSTER,
            withTotalPages: count,
            query: boundFilter
        });
        if (count) {
            return paging.totalPages;
        }
        return data;
    }
    async getAllPositionsMOs(byGroupIdMO, pageSize = 500) {
        const filter = {
            pageSize,
            withTotalPages: true,
            query: 'has(c8y_Position)'
        };
        if (byGroupIdMO) {
            filter.query = `$filter=(bygroupid(${byGroupIdMO.id}) or id eq '${byGroupIdMO.id}') and has(c8y_Position)`;
        }
        const { paging, data, res } = await this.inventory.list(filter);
        return {
            res,
            paging: paging,
            data: data
        };
    }
    async getClusterSize(bound) {
        const count = await this.getPositionMOsFromBoundCount(bound);
        let clusterSize = ClusterSize.NONE;
        if (count > this.CLUSTER_LEVEL_THRESHOLD) {
            clusterSize = ClusterSize.SIXTEEN;
        }
        else if (count > this.MAX_DEVICE_PER_CLUSTER) {
            clusterSize = ClusterSize.FOUR;
        }
        return clusterSize;
    }
}
MapService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapService, deps: [{ token: i1.InventoryService }], target: i0.ɵɵFactoryTarget.Injectable });
MapService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.InventoryService }]; } });

class MapComponent {
    constructor(moRealtimeService, mapService, layers, defaultConfig, translateService) {
        this.moRealtimeService = moRealtimeService;
        this.mapService = mapService;
        this.layers = layers;
        this.defaultConfig = defaultConfig;
        this.translateService = translateService;
        this.markers = [];
        this.config = {};
        this.onMove = new EventEmitter();
        this.onMoveEnd = new EventEmitter();
        this.onZoomStart = new EventEmitter();
        this.onZoomEnd = new EventEmitter();
        this.destroy$ = new Subject();
        if (!this.layers) {
            this.layers = [defaultLayer];
        }
        if (!this.defaultConfig) {
            this.defaultConfig = defaultMapConfig;
        }
    }
    startRealtime() {
        if (!this.assets || (Array.isArray(this.assets) && this.assets.length > 1)) {
            this.config.realtime = false;
            this.stopRealtime();
            return;
        }
        const asset = Array.isArray(this.assets) ? this.assets[0] : this.assets;
        this.realtimeSubscription = this.moRealtimeService
            .onUpdate$(asset)
            .subscribe((asset) => {
            const marker = this.findMarker(asset.id);
            const icon = this.getAssetIcon(asset);
            marker.setIcon(icon);
            marker.setLatLng([asset.c8y_Position.lat, asset.c8y_Position.lng]);
            if (Array.isArray(this.assets)) {
                this.assets[0] = asset;
            }
            else {
                this.assets = asset;
            }
            this.moveToPositionOfMo(asset);
        });
    }
    moveToPositionOfMo(positions) {
        const position = Array.isArray(positions) ? positions[0] : positions;
        if (this.config.follow) {
            this.map.setView([position.c8y_Position.lat, position.c8y_Position.lng]);
        }
    }
    stopRealtime() {
        if (this.realtimeSubscription) {
            this.realtimeSubscription.unsubscribe();
        }
    }
    findMarker(assetId) {
        return this.markers.find((marker) => marker.asset?.id === assetId);
    }
    addMarkerToMap(marker) {
        this.markers.push(marker);
        marker.addTo(this.map);
    }
    getAssetMarker(asset) {
        const icon = this.getAssetIcon(asset);
        const leafletMarker = this.leaflet.marker([asset.c8y_Position.lat, asset.c8y_Position.lng], {
            icon
        });
        const marker = getC8yMarker(leafletMarker, asset);
        if (this.popup) {
            marker.on('click', () => {
                this.popup.viewContainer.clear();
                const view = this.popup.viewContainer.createEmbeddedView(this.popup.template, {
                    $implicit: asset
                });
                view.detectChanges();
                marker
                    .unbindPopup()
                    .bindPopup(this.popup.elementRef.nativeElement.previousSibling, {
                    offset: [0, -30],
                    maxWidth: 140,
                    autoPan: false
                })
                    .openPopup();
            });
        }
        return marker;
    }
    getAssetIcon(asset) {
        const assetTypeIcon = this.config.icon || asset.icon?.name;
        const status = getStatus(asset);
        const color = this.config.color ? `style='color: ${this.config.color};'` : '';
        const icon = this.leaflet.divIcon({
            html: `<div class="dlt-c8y-icon-marker icon-3x ${status}" ${color}><i class="dlt-c8y-icon-${assetTypeIcon || 'data-transfer'}" /></div>`,
            className: 'c8y-map-marker-icon'
        });
        return icon;
    }
    clearMarkers() {
        this.markers.forEach(marker => marker.remove());
        this.markers = [];
    }
    refreshMarkers() {
        this.clearMarkers();
        const assets = Array.isArray(this.assets) ? this.assets : [this.assets];
        assets.forEach(asset => {
            const marker = this.getAssetMarker(asset);
            this.addMarkerToMap(marker);
        });
        if (!this.config.center) {
            this.zoomToBound(assets);
        }
        this.toggleControls();
    }
    center() {
        this.map.setView(this.config.center || this.defaultConfig.center);
    }
    async ngAfterViewInit() {
        this.leaflet = await this.mapService.getLeaflet();
        this.initMap();
    }
    ngOnChanges(changes) {
        if (changes.assets?.currentValue && !changes.assets?.firstChange) {
            this.refreshMarkers();
        }
        if (changes.config?.currentValue && !changes.config?.firstChange) {
            this.changeConfig(changes.config);
        }
    }
    ngOnDestroy() {
        this.unsubscribeAllListeners();
    }
    unsubscribeAllListeners() {
        this.destroy$.next();
        this.stopRealtime();
    }
    initMap() {
        const defaultOptions = {
            center: this.config.center || this.defaultConfig.center,
            zoomSnap: 0,
            zoom: this.config.zoomLevel || this.defaultConfig.zoomLevel
        };
        if (this.map) {
            this.map.remove();
        }
        this.map = this.leaflet.map(this.mapElement.nativeElement, defaultOptions);
        this.map.attributionControl.setPrefix('');
        this.addLayers();
        this.handleMobile();
        fromEvent(this.map, 'moveend')
            .pipe(takeUntil(this.destroy$))
            .subscribe(event => this.onMoveEnd.emit(event));
        fromEvent(this.map, 'move')
            .pipe(takeUntil(this.destroy$))
            .subscribe(event => this.onMove.emit(event));
        fromEvent(this.map, 'zoomend')
            .pipe(takeUntil(this.destroy$))
            .subscribe(event => this.onZoomEnd.emit(event));
        fromEvent(this.map, 'zoomstart')
            .pipe(takeUntil(this.destroy$))
            .subscribe(event => this.onZoomStart.emit(event));
    }
    handleMobile() {
        // adding event listener to do mobile 2 finger scrolling
        if (this.leaflet.Browser.mobile) {
            const touchMsg = this.translateService.instant(gettext('Use two fingers to move the map.'));
            this.map.dragging.disable();
            const container = this.map.getContainer();
            container.setAttribute('data-touch-warning-content', touchMsg);
            container.addEventListener('touchstart', event => this.handleTouch(event));
            container.addEventListener('touchmove', event => this.handleTouch(event));
            container.addEventListener('touchend', event => this.handleTouch(event));
            container.addEventListener('touchcancel', event => this.handleTouch(event));
            container.addEventListener('click', event => this.handleTouch(event));
        }
    }
    addLayers() {
        const flattenLayers = flatten(this.layers);
        const tileLayers = sortByPriority(flattenLayers).reduce((acc, layer) => {
            const tiles = this.leaflet.tileLayer(layer.layerUrl, layer.options);
            tiles.addTo(this.map);
            acc = { [layer.label]: tiles, ...acc };
            return acc;
        }, {});
        if (flattenLayers.length > 1) {
            this.leaflet.control.layers(tileLayers).addTo(this.map);
        }
    }
    changeConfig(change) {
        if (this.hasChanged(change, 'zoomLevel')) {
            this.map.setZoom(this.config.zoomLevel);
        }
        if (this.hasChanged(change, 'center')) {
            this.map.setView(change.currentValue.center || this.defaultConfig.center);
        }
        if (this.hasChanged(change, 'icon') || this.hasChanged(change, 'color')) {
            this.refreshMarkers();
        }
        if (this.hasChanged(change, 'realtime') && change.currentValue.realtime) {
            this.startRealtime();
        }
        if (change.currentValue.realtime === false) {
            this.stopRealtime();
        }
        if (this.hasChanged(change, 'follow')) {
            this.moveToPositionOfMo(this.assets);
        }
        if (this.hasChanged(change, 'disablePan') || this.hasChanged(change, 'disableZoom')) {
            this.toggleControls();
        }
    }
    hasChanged(change, prop) {
        return change.currentValue[prop] !== change.previousValue[prop];
    }
    toggleControls() {
        if (this.config.disableZoom) {
            this.map.removeControl(this.map.zoomControl);
            this.map.scrollWheelZoom.disable();
        }
        else {
            this.map.addControl(this.map.zoomControl);
            this.map.scrollWheelZoom.enable();
        }
        if (this.config.disablePan) {
            this.map.dragging.disable();
        }
        else {
            this.map.dragging.enable();
        }
    }
    handleTouch(e) {
        // Disregard touch events on the minimap if present
        const ignoreList = [
            'leaflet-control-minimap',
            'leaflet-interactive',
            'leaflet-popup-content',
            'leaflet-popup-content-wrapper',
            'leaflet-popup-close-button',
            'leaflet-control-zoom-in',
            'leaflet-control-zoom-out'
        ];
        let ignoreElement = false;
        for (let i = 0; i < ignoreList.length; i++) {
            if (this.leaflet.DomUtil.hasClass(e.target, ignoreList[i])) {
                ignoreElement = true;
            }
        }
        const container = this.map.getContainer();
        if (ignoreElement) {
            if (this.leaflet.DomUtil.hasClass(e.target, 'leaflet-interactive') &&
                e.type === 'touchmove' &&
                e.touches.length === 1) {
                this.leaflet.DomUtil.addClass(container, 'touch-warning');
                this.map.dragging.disable();
            }
            else {
                this.leaflet.DomUtil.removeClass(container, 'touch-warning');
            }
            return;
        }
        if (e.type !== 'touchmove' && e.type !== 'touchstart') {
            this.leaflet.DomUtil.removeClass(container, 'touch-warning');
            return;
        }
        if (e.touches.length === 1) {
            this.leaflet.DomUtil.addClass(container, 'touch-warning');
            this.map.dragging.disable();
        }
        else {
            this.map.dragging.enable();
            this.leaflet.DomUtil.removeClass(container, 'touch-warning');
        }
    }
    zoomToBound(assets) {
        const bounds = assets.map(asset => [
            asset.c8y_Position.lat,
            asset.c8y_Position.lng
        ]);
        this.map.fitBounds(bounds);
    }
}
MapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapComponent, deps: [{ token: i1$1.ManagedObjectRealtimeService }, { token: MapService }, { token: MAP_TILE_LAYER, optional: true }, { token: MAP_DEFAULT_CONFIG, optional: true }, { token: i3.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
MapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: MapComponent, selector: "c8y-map", inputs: { config: "config", assets: "assets" }, outputs: { onMove: "onMove", onMoveEnd: "onMoveEnd", onZoomStart: "onZoomStart", onZoomEnd: "onZoomEnd" }, providers: [ManagedObjectRealtimeService], queries: [{ propertyName: "popup", first: true, predicate: MapPopupDirective, descendants: true }], viewQueries: [{ propertyName: "mapElement", first: true, predicate: ["map"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"c8y-map\">  \n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-map', providers: [ManagedObjectRealtimeService], template: "<div class=\"c8y-map\">  \n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.ManagedObjectRealtimeService }, { type: MapService }, { type: Array, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_TILE_LAYER]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_DEFAULT_CONFIG]
                }] }, { type: i3.TranslateService }]; }, propDecorators: { mapElement: [{
                type: ViewChild,
                args: ['map']
            }], popup: [{
                type: ContentChild,
                args: [MapPopupDirective]
            }], config: [{
                type: Input
            }], assets: [{
                type: Input
            }], onMove: [{
                type: Output
            }], onMoveEnd: [{
                type: Output
            }], onZoomStart: [{
                type: Output
            }], onZoomEnd: [{
                type: Output
            }] } });

class ClusterMapComponent extends MapComponent {
    constructor(moRealtimeService, mapService, layers, defaultConfig, translateService, iterable, colorService) {
        super(moRealtimeService, mapService, layers, defaultConfig, translateService);
        this.moRealtimeService = moRealtimeService;
        this.mapService = mapService;
        this.layers = layers;
        this.defaultConfig = defaultConfig;
        this.translateService = translateService;
        this.iterable = iterable;
        this.colorService = colorService;
        this.isLoading$ = new BehaviorSubject(false);
        this.msUntilRefresh$ = new BehaviorSubject(5000);
        this.showClusterColor = false;
        this.mapChange = new EventEmitter();
        this.reloadTrigger$ = new BehaviorSubject(false);
        this.clusters = [];
        this.MIN_INTERVAL = 5000;
        this.EVENT_THROTTLE_TIME = 750;
        if (!this.layers) {
            this.layers = [defaultLayer];
        }
        if (!this.defaultConfig) {
            this.defaultConfig = defaultMapConfig;
        }
        this.config = {
            center: this.defaultConfig.center
        };
    }
    async ngOnChanges(changes) {
        if (changes.config?.firstChange) {
            return;
        }
        if (changes.rootNode?.previousValue !== changes.rootNode?.currentValue) {
            this.changeRootNode(changes.rootNode.currentValue);
        }
        if (changes.config?.currentValue) {
            this.changeConfig(changes.config);
        }
    }
    changeConfig(change) {
        // on following, cancel reload to avoid stale state
        if (change.currentValue.follow === true) {
            this.cancelReload();
            this.isLoading$.next(false);
        }
        if (change.currentValue.refreshInterval !== change.previousValue.refreshInterval) {
            this.reload();
        }
        super.changeConfig(change);
    }
    async ngAfterViewInit() {
        if (!this.leaflet) {
            this.leaflet = await this.mapService.getLeaflet();
        }
        this.initMap();
        this.changeRootNode(this.rootNode);
        this.changeConfig(new SimpleChange({}, this.config, false));
    }
    async reset() {
        this.ngOnDestroy();
        await this.ngAfterViewInit();
    }
    reload() {
        this.reloadTrigger$.next(true);
    }
    cancelReload() {
        this.reloadTrigger$.next(false);
    }
    listenToClusterChanges() {
        const timerStart$ = new Subject();
        const timerEnd$ = new Subject();
        const documentHiddenEvent$ = fromEvent(document, 'visibilitychange').pipe(takeUntil(this.destroy$));
        const interval$ = timerStart$.pipe(map(() => this.config.refreshInterval), switchMap(configInterval => {
            if (!configInterval) {
                return NEVER;
            }
            return interval(1000).pipe(map(value => value * 1000), tap(value => this.msUntilRefresh$.next(configInterval - value)), filter(value => value >= this.MIN_INTERVAL && value >= configInterval), first(), takeUntil(timerEnd$));
        }), switchMap(() => (document.hidden ? documentHiddenEvent$ : of(true))), takeUntil(this.destroy$));
        const mapChange$ = merge(fromEvent(this.map, 'move'), fromEvent(this.map, 'moveend')).pipe(debounceTime(this.EVENT_THROTTLE_TIME), tap(event => this.mapChange.emit(event)), takeUntil(this.destroy$));
        merge(this.reloadTrigger$, mapChange$, interval$)
            .pipe(tap(() => {
            timerEnd$.next(true);
            this.msUntilRefresh$.next(0);
            this.isLoading$.next(true);
        }), switchMap(value => value === false
            ? of([])
            : from(this.mapService.getClusterSize(this.map.getBounds())).pipe(mergeMap((clusterSize) => this.getClusterRects(clusterSize, this.map.getBounds())), mergeMap(rects => this.createOrUpdateCluster(rects)))), takeUntil(this.destroy$))
            .subscribe((clusters) => {
            clusters.forEach(cluster => cluster.render(this.map));
            this.isLoading$.next(false);
            timerStart$.next();
            this.msUntilRefresh$.next(this.config.refreshInterval);
        });
    }
    refreshMarkers() {
        if (this.assets) {
            super.refreshMarkers();
            return;
        }
        this.clusters.forEach(cluster => {
            cluster.clear(this.map);
        });
        this.reload();
    }
    changeRootNode(mo) {
        this.unsubscribeAllListeners();
        this.clearMarkers();
        this.clearClusters();
        const isPositionDevice = mo?.c8y_Position && mo?.c8y_IsDevice;
        if (isPositionDevice) {
            this.assets = mo;
            this.refreshMarkers();
            return;
        }
        this.assets = null;
        this.listenToClusterChanges();
        this.reload();
    }
    async getClusterRects(levelThreshold = ClusterSize.FOUR, viewBounds, level = 0) {
        let rects = [];
        if (levelThreshold === ClusterSize.NONE) {
            const rect = await this.getRect(viewBounds);
            rects.push(rect);
            return rects;
        }
        if (level >= levelThreshold) {
            return rects;
        }
        level++;
        const { lat: x1, lng: y1 } = viewBounds.getSouthWest();
        const { lat: x2, lng: y2 } = viewBounds.getNorthEast();
        const newX2 = (x1 + x2) / 2;
        const newY2 = (y1 + y2) / 2;
        const bounds = [
            [
                [x1, y1],
                [newX2, newY2]
            ],
            [
                [newX2, newY2],
                [x2, y2]
            ],
            [
                [x1, newY2],
                [newX2, y2]
            ],
            [
                [newX2, y1],
                [x2, newY2]
            ]
        ];
        for (const bound of bounds) {
            const latLngBound = this.leaflet.latLngBounds(bound);
            const rect = await this.getRect(latLngBound);
            rects = [...rects, ...(await this.getClusterRects(levelThreshold, latLngBound, level))];
            if (level === levelThreshold) {
                rects.push(rect);
            }
        }
        return rects;
    }
    async getRect(latLngBound) {
        let color = 'none';
        if (this.showClusterColor) {
            color = await this.colorService.generateColor(latLngBound.toBBoxString());
        }
        const rect = this.leaflet.rectangle(latLngBound, {
            color,
            weight: color === 'none' ? 0 : 1,
            interactive: false
        });
        return rect;
    }
    clearClusters() {
        this.clusters.forEach(cluster => {
            cluster.clear(this.map);
        });
        this.clusters = [];
    }
    async updateCluster(cluster) {
        const clusterCount = await this.mapService.getPositionMOsFromBoundCount(cluster.rect.getBounds(), this.rootNode);
        if (clusterCount > this.mapService.MAX_DEVICE_PER_CLUSTER) {
            cluster.setClusterToBigMarker(this.map, clusterCount, this.leaflet);
            cluster.positions = [];
            return cluster;
        }
        cluster.removeClusterToBigMarker();
        cluster.positions = await this.mapService.getPositionMOs(cluster.rect.getBounds(), this.rootNode);
        return cluster;
    }
    createOrUpdateCluster(rects) {
        const isNew = rects.length !== this.clusters.length;
        if (isNew) {
            this.clearClusters();
        }
        const updatePromise = rects.map((rect, index) => {
            if (isNew) {
                const cluster = new ClusterMap(this.iterable, asset => this.getAssetMarker(asset), this.translateService);
                this.clusters.push(cluster);
            }
            this.clusters[index].rect = rect;
            return this.updateCluster(this.clusters[index]);
        });
        return Promise.all(updatePromise);
    }
}
ClusterMapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ClusterMapComponent, deps: [{ token: i1$1.ManagedObjectRealtimeService }, { token: MapService }, { token: MAP_TILE_LAYER, optional: true }, { token: MAP_DEFAULT_CONFIG, optional: true }, { token: i3.TranslateService }, { token: i0.IterableDiffers }, { token: i1$1.ColorService }], target: i0.ɵɵFactoryTarget.Component });
ClusterMapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ClusterMapComponent, selector: "c8y-cluster-map", inputs: { config: "config", rootNode: "rootNode", assets: ["asset", "assets"], showClusterColor: "showClusterColor" }, outputs: { mapChange: "mapChange" }, providers: [ManagedObjectRealtimeService], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div class=\"c8y-map\">\n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ClusterMapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-cluster-map', providers: [ManagedObjectRealtimeService], template: "<div class=\"c8y-map\">\n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.ManagedObjectRealtimeService }, { type: MapService }, { type: Array, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_TILE_LAYER]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_DEFAULT_CONFIG]
                }] }, { type: i3.TranslateService }, { type: i0.IterableDiffers }, { type: i1$1.ColorService }]; }, propDecorators: { config: [{
                type: Input
            }], rootNode: [{
                type: Input
            }], assets: [{
                type: Input,
                args: ['asset']
            }], showClusterColor: [{
                type: Input
            }], mapChange: [{
                type: Output
            }] } });

class MapStatusComponent {
    constructor() {
        this.configChange = new EventEmitter();
        this.onUnfollow = new EventEmitter();
        this.showCenter = false;
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        this.initConfig = cloneDeep(this.config);
    }
    ngOnChanges(changes) {
        if (changes.clusterMap?.previousValue !== changes.clusterMap?.currentValue) {
            this.checkIfMapIsAlreadyCentered();
            this.secondsUntilRefresh$ = this.clusterMap.msUntilRefresh$.pipe(map(milliseconds => `${Math.floor(milliseconds / 1000)}`), takeUntil(this.destroy$));
        }
    }
    center() {
        this.clusterMap.center();
    }
    reload() {
        this.clusterMap.reload();
    }
    cancelReload() {
        this.clusterMap.cancelReload();
    }
    toggleRealtime() {
        this.config = {
            ...this.config,
            realtime: !this.config.realtime
        };
        this.configChange.emit(this.config);
    }
    unfollow() {
        this.config = {
            ...this.clusterMap.config,
            follow: false
        };
        this.configChange.emit(this.config);
        this.onUnfollow.emit(this.config);
    }
    follow() {
        this.config = {
            ...this.config,
            follow: true
        };
        this.configChange.emit(this.config);
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    checkIfMapIsAlreadyCentered() {
        this.clusterMap.mapChange.pipe(takeUntil(this.destroy$)).subscribe((event) => {
            if (this.config?.center && event.sourceTarget?.getBounds) {
                const bounds = event.sourceTarget.getBounds();
                this.showCenter = !bounds.getCenter().equals(this.config.center, 3);
            }
        });
    }
}
MapStatusComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapStatusComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MapStatusComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: MapStatusComponent, selector: "c8y-map-status", inputs: { config: "config", clusterMap: "clusterMap" }, outputs: { configChange: "configChange", onUnfollow: "onUnfollow" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"c8y-map-status\">\n  <div class=\"leaflet-touch\">\n    <div class=\"leaflet-bar\" role=\"group\">\n      <button\n        type=\"button\"\n        title=\"{{ 'Realtime' | translate }}\"\n        class=\"c8y-realtime\"\n        *ngIf=\"initConfig.realtime || clusterMap.config.follow\"\n        (click)=\"toggleRealtime()\"\n      >\n        <span class=\"c8y-pulse\" [ngClass]=\"{ active: clusterMap?.config.realtime }\"></span>\n      </button>\n      <button\n        type=\"button\"\n        class=\"time-ellapsed\"\n        *ngIf=\"\n          clusterMap?.config.refreshInterval &&\n          (secondsUntilRefresh$ | async) &&\n          !clusterMap?.config.follow\n        \"\n        disabled=\"disabled\"\n        title=\"{{ secondsUntilRefresh$ | async }}s / {{\n          clusterMap?.config.refreshInterval / 1000\n        }}s\"\n        [style.--timescope]=\"clusterMap?.config.refreshInterval + 1000 + 'ms'\"\n      >\n        <svg\n          [ngClass]=\"{ 'time-on': !(clusterMap?.isLoading$ | async) }\"\n          viewBox=\"0 0 40 40\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <circle cx=\"20\" cy=\"20\" r=\"15.8\" stroke=\"var(--c8y-brand-primary)\" stroke-width=\"6\" />\n        </svg>\n\n        <span>{{ secondsUntilRefresh$ | async }}</span>\n      </button>\n      <button\n        type=\"button\"\n        *ngIf=\"clusterMap?.isLoading$ | async\"\n        title=\"{{ 'Cancel reload' | translate }}\"\n        (click)=\"cancelReload()\"\n      >\n        <i c8yIcon=\"refresh\" class=\"icon-spin\"></i>\n      </button>\n      <button\n        type=\"button\"\n        *ngIf=\"\n          !clusterMap?.config.realtime && !clusterMap?.assets && !(clusterMap?.isLoading$ | async)\n        \"\n        (click)=\"reload()\"\n        [title]=\"'Reload' | translate\"\n      >\n        <i c8yIcon=\"refresh\"></i>\n      </button>\n      <button\n        type=\"button\"\n        (click)=\"center()\"\n        title=\"{{ 'Center map' | translate }}\"\n        [disabled]=\"!showCenter || clusterMap?.config.follow\"\n      >\n        <i c8yIcon=\"target1\"></i>\n      </button>\n      <button\n        type=\"button\"\n        title=\"{{ 'Unfollow' | translate }}\"\n        *ngIf=\"clusterMap?.config.follow\"\n        (click)=\"unfollow()\"\n      >\n        <i c8yIcon=\"marker-off\"></i>\n      </button>\n\n      <button\n        type=\"button\"\n        title=\"{{ 'Follow' | translate }}\"\n        *ngIf=\"initConfig.follow && !clusterMap?.config.follow\"\n        (click)=\"follow()\"\n      >\n        <i c8yIcon=\"marker\"></i>\n      </button>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i1$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$1.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "pipe", type: i1$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i1$1.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapStatusComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-map-status', template: "<div class=\"c8y-map-status\">\n  <div class=\"leaflet-touch\">\n    <div class=\"leaflet-bar\" role=\"group\">\n      <button\n        type=\"button\"\n        title=\"{{ 'Realtime' | translate }}\"\n        class=\"c8y-realtime\"\n        *ngIf=\"initConfig.realtime || clusterMap.config.follow\"\n        (click)=\"toggleRealtime()\"\n      >\n        <span class=\"c8y-pulse\" [ngClass]=\"{ active: clusterMap?.config.realtime }\"></span>\n      </button>\n      <button\n        type=\"button\"\n        class=\"time-ellapsed\"\n        *ngIf=\"\n          clusterMap?.config.refreshInterval &&\n          (secondsUntilRefresh$ | async) &&\n          !clusterMap?.config.follow\n        \"\n        disabled=\"disabled\"\n        title=\"{{ secondsUntilRefresh$ | async }}s / {{\n          clusterMap?.config.refreshInterval / 1000\n        }}s\"\n        [style.--timescope]=\"clusterMap?.config.refreshInterval + 1000 + 'ms'\"\n      >\n        <svg\n          [ngClass]=\"{ 'time-on': !(clusterMap?.isLoading$ | async) }\"\n          viewBox=\"0 0 40 40\"\n          fill=\"none\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <circle cx=\"20\" cy=\"20\" r=\"15.8\" stroke=\"var(--c8y-brand-primary)\" stroke-width=\"6\" />\n        </svg>\n\n        <span>{{ secondsUntilRefresh$ | async }}</span>\n      </button>\n      <button\n        type=\"button\"\n        *ngIf=\"clusterMap?.isLoading$ | async\"\n        title=\"{{ 'Cancel reload' | translate }}\"\n        (click)=\"cancelReload()\"\n      >\n        <i c8yIcon=\"refresh\" class=\"icon-spin\"></i>\n      </button>\n      <button\n        type=\"button\"\n        *ngIf=\"\n          !clusterMap?.config.realtime && !clusterMap?.assets && !(clusterMap?.isLoading$ | async)\n        \"\n        (click)=\"reload()\"\n        [title]=\"'Reload' | translate\"\n      >\n        <i c8yIcon=\"refresh\"></i>\n      </button>\n      <button\n        type=\"button\"\n        (click)=\"center()\"\n        title=\"{{ 'Center map' | translate }}\"\n        [disabled]=\"!showCenter || clusterMap?.config.follow\"\n      >\n        <i c8yIcon=\"target1\"></i>\n      </button>\n      <button\n        type=\"button\"\n        title=\"{{ 'Unfollow' | translate }}\"\n        *ngIf=\"clusterMap?.config.follow\"\n        (click)=\"unfollow()\"\n      >\n        <i c8yIcon=\"marker-off\"></i>\n      </button>\n\n      <button\n        type=\"button\"\n        title=\"{{ 'Follow' | translate }}\"\n        *ngIf=\"initConfig.follow && !clusterMap?.config.follow\"\n        (click)=\"follow()\"\n      >\n        <i c8yIcon=\"marker\"></i>\n      </button>\n    </div>\n  </div>\n</div>\n" }]
        }], propDecorators: { config: [{
                type: Input
            }], configChange: [{
                type: Output
            }], onUnfollow: [{
                type: Output
            }], clusterMap: [{
                type: Input
            }] } });

class MapModule {
}
MapModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MapModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: MapModule, declarations: [MapComponent, MapStatusComponent, ClusterMapComponent, MapPopupDirective], imports: [CommonModule, FormsModule, CommonModule$1, FormsModule$1, RealtimeModule], exports: [MapComponent, MapStatusComponent, ClusterMapComponent, MapPopupDirective] });
MapModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapModule, providers: [
        {
            provide: MAP_TILE_LAYER,
            useValue: [defaultLayer]
        },
        {
            provide: MAP_DEFAULT_CONFIG,
            useValue: defaultMapConfig
        }
    ], imports: [CommonModule, FormsModule, CommonModule$1, FormsModule$1, RealtimeModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MapModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [MapComponent, MapStatusComponent, ClusterMapComponent, MapPopupDirective],
                    imports: [CommonModule, FormsModule, CommonModule$1, FormsModule$1, RealtimeModule],
                    exports: [MapComponent, MapStatusComponent, ClusterMapComponent, MapPopupDirective],
                    providers: [
                        {
                            provide: MAP_TILE_LAYER,
                            useValue: [defaultLayer]
                        },
                        {
                            provide: MAP_DEFAULT_CONFIG,
                            useValue: defaultMapConfig
                        }
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ClusterMap, ClusterMapComponent, ClusterSize, MAP_DEFAULT_CONFIG, MAP_TILE_LAYER, MapComponent, MapModule, MapPopupDirective, MapService, MapStatusComponent, defaultLayer, defaultMapConfig, getC8yMarker, getStatus };
//# sourceMappingURL=c8y-ngx-components-map.mjs.map
