import { __awaiter } from 'tslib';
import * as i0 from '@angular/core';
import { EventEmitter, Injectable, Component, Input, ViewChild, Pipe, Output, forwardRef, NgModule } from '@angular/core';
import * as i2 from '@c8y/ngx-components';
import { gettext, PackageType, Status, DropAreaComponent, C8yStepper, internalApps, FilterInputComponent, CoreModule, hookWizard } from '@c8y/ngx-components';
import * as i3 from '@c8y/client';
import { ApplicationAvailability, ApplicationType } from '@c8y/client';
import { saveAs } from 'file-saver';
import { groupBy, uniqBy, get, pick, kebabCase, cloneDeep } from 'lodash-es';
import { BehaviorSubject, defer, merge, combineLatest, pipe } from 'rxjs';
import { map, shareReplay, debounceTime, take, filter, distinctUntilKeyChanged, tap, switchMap } from 'rxjs/operators';
import { satisfies, gt, coerce } from 'semver';
import * as i2$1 from '@ngx-translate/core';
import * as i3$1 from '@angular/common';
import * as i4 from '@angular/router';
import * as i6 from 'ngx-bootstrap/dropdown';
import { BsDropdownModule } from 'ngx-bootstrap/dropdown';
import * as i7 from 'ngx-bootstrap/tooltip';
import { TooltipModule } from 'ngx-bootstrap/tooltip';
import * as i8 from '@angular/cdk/a11y';
import { A11yModule } from '@angular/cdk/a11y';
import * as i1 from '@angular/forms';
import { Validators, NG_VALUE_ACCESSOR, FormsModule, ReactiveFormsModule } from '@angular/forms';
import * as i1$1 from 'ngx-bootstrap/modal';
import * as i5 from '@angular/cdk/stepper';

/** Wizard types  */
var EcosystemWizards;
(function (EcosystemWizards) {
    EcosystemWizards["APPLICATION_UPLOAD"] = "ecosystemApplicationUpload";
    EcosystemWizards["MICROSERVICE_UPLOAD"] = "ecosystemMicroserviceUpload";
    EcosystemWizards["PACKAGE_UPLOAD"] = "ecosystemPackageUpload";
    EcosystemWizards["BLUEPRINT_DEPLOYMENT"] = "ecosystemBlueprintDeployment";
    EcosystemWizards["LICENSE_CONFIRM"] = "ecosystemLicenseConfirm";
})(EcosystemWizards || (EcosystemWizards = {}));
var ERROR_TYPE;
(function (ERROR_TYPE) {
    ERROR_TYPE["TYPE_VALIDATION"] = "TYPE_VALIDATION";
    ERROR_TYPE["ALREADY_SUBSCRIBED"] = "ALREADY_SUBSCRIBED";
    ERROR_TYPE["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    ERROR_TYPE["NO_MANIFEST_FILE"] = "NO_MANIFEST_FILE";
    ERROR_TYPE["INVALID_PACKAGE"] = "INVALID_PACKAGE";
    ERROR_TYPE["INVALID_APPLICATION"] = "INVALID_APPLICATION";
    ERROR_TYPE["MICROSERVICE_NAME_TOO_LONG"] = "MICROSERVICE_NAME_TOO_LONG";
    ERROR_TYPE["APPLICATION_CREATION_FAILED"] = "APPLICATION_CREATION_FAILED";
    ERROR_TYPE["KEY_OR_CONTEXT_PATH_MISMATCH"] = "KEY_OR_CONTEXT_PATH_MISMATCH";
})(ERROR_TYPE || (ERROR_TYPE = {}));
const PRODUCT_EXPERIENCE = {
    APPLICATIONS: {
        EVENTS: {
            AVAILABILITY: 'availability',
            APPLICATION_CARD: 'applicationCard',
            APPLICATION_PROPERTIES: 'applicationProperties',
            DEPLOY_APPLICATION: 'deployApplication',
            DUPLICATE_APPLICATION: 'duplicateApplication',
            INSTALLED_PLUGINS: 'installedPlugins',
            PACKAGE_PLUGINS: 'packagePlugins',
            PACKAGE_VERSIONS: 'packageVersions',
            FILTER_LIST: 'filterList'
        },
        COMPONENTS: {
            APPLICATION_CARD: 'application-card',
            APPLICATION_PLUGINS: 'application-plugins',
            APPLICATION_PROPERTIES: 'application-properties',
            DEPLOY_APPLICATION: 'deploy-application',
            DUPLICATE_APPLICATION_PROPERTIES: 'duplicate-application-properties',
            PLUGIN_LIST: 'plugin-list',
            PACKAGE_VERSIONS: 'package-versions-list',
            UPDATE_PLUGIN_OF_APP: 'update-plugin-of-app',
            LIST_FILTERS: 'list-filters'
        },
        ACTIONS: {
            AVAILABILITY_CHANGE: 'availabilityChange',
            CANCEL: 'cancel',
            CLONE: 'clone',
            CHANGE_PLUGIN_VERSION: 'changePluginVersion',
            DELETE: 'delete',
            DOWNLOAD: 'download',
            DEPLOY_APPLICATION: 'deployApplication',
            EDIT: 'edit',
            INSTALL_PLUGIN: 'installPlugin',
            INSTALL_PLUGINS: 'installPlugins',
            SELECT_VERSION: 'selectVersion',
            SET_AS_LATEST: 'setAsLatest',
            UPDATE_AVAILABLE: 'updateAvailable',
            UPLOAD: 'upload',
            SET_FILTER_TERM: 'setFilterTerm',
            SET_PREDEFINED_FILTERS: 'setPredefinedFilters',
            RESET_FILTER: 'resetFilter'
        },
        RESULTS: {
            DEPLOYED: 'deployed',
            DUPLICATED: 'duplicated',
            PLUGIN_INSTALLED: 'pluginInstalled',
            PLUGIN_REMOVED: 'pluginRemoved',
            PLUGIN_VERSION_CHANGED: 'pluginVersionChanged',
            SERVER_FAILURE: 'serverFailure',
            SUCCESS: 'success'
        }
    }
};

const ERROR_MESSAGES = {
    [ERROR_TYPE.TYPE_VALIDATION]: gettext('Wrong file format. Expected a *.zip file with a valid manifest.'),
    [ERROR_TYPE.ALREADY_SUBSCRIBED]: gettext('Could not subscribe to the microservice because another application with the same context path is already subscribed.'),
    [ERROR_TYPE.NO_MANIFEST_FILE]: gettext('Could not find a manifest.'),
    [ERROR_TYPE.INVALID_PACKAGE]: gettext('You have not uploaded a valid package.'),
    [ERROR_TYPE.INVALID_APPLICATION]: gettext('You have not uploaded a valid application.'),
    [ERROR_TYPE.INTERNAL_ERROR]: gettext('An internal error occurred, try to upload again.'),
    [ERROR_TYPE.MICROSERVICE_NAME_TOO_LONG]: gettext('Microservice name "{{ name }}" must not be longer than {{ maxChars }} characters.'),
    [ERROR_TYPE.APPLICATION_CREATION_FAILED]: gettext('Application creation failed.'),
    [ERROR_TYPE.KEY_OR_CONTEXT_PATH_MISMATCH]: gettext('The "contextPath`KEEP_ORIGINAL`" or "key`KEEP_ORIGINAL`" of the uploaded archive do not match with the existing application.')
};
const APP_STATE = {
    SUBSCRIBED: {
        label: gettext('Subscribed`application`'),
        class: 'label-primary',
        tooltip: gettext('Provided by parent tenant.')
    },
    CUSTOM: {
        label: gettext('Custom`application`'),
        class: 'label-info',
        tooltip: gettext('Manually uploaded to the platform.')
    },
    EXTERNAL: {
        label: gettext('External`application`'),
        class: 'label-warning',
        tooltip: gettext('Application hosted outside of the platform.')
    },
    UNPACKED: {
        label: gettext('Unpacked`application`'),
        class: 'label-success',
        tooltip: gettext('Deployed from a package available under "Packages".')
    },
    PACKAGE_BLUEPRINT: {
        label: gettext('Blueprint'),
        class: 'label-success',
        tooltip: gettext('Contains an application and may include plugins.')
    },
    PACKAGE_PLUGIN: {
        label: gettext('Plugins'),
        class: 'label-info',
        tooltip: gettext('Contains only plugins.')
    },
    PACKAGE_UNKNOWN: {
        label: gettext('Unknown`package-type`'),
        class: 'label-info',
        tooltip: gettext('Package contents could not be determined.')
    }
};
const PACKAGE_TYPE_LABELS = {
    [PackageType.COMMUNITY]: {
        label: gettext('COMMUNITY`Package created by the developer community.`'),
        tooltip: gettext('Package created by the developer community.')
    },
    [PackageType.OFFICIAL]: {
        label: gettext('OFFICIAL`Package maintained by Software AG.`'),
        tooltip: gettext('Package maintained by Software AG.')
    },
    [PackageType.UNKNOWN]: {
        label: gettext('CUSTOM`Package maintained by an unknown source.`'),
        tooltip: gettext('Package maintainer unknown.')
    }
};
const packageProperties = [
    {
        label: gettext('Version'),
        key: 'version'
    },
    {
        label: gettext('Author'),
        key: 'author'
    },
    {
        label: gettext('Keywords'),
        key: 'keywords'
    },
    {
        label: gettext('Source'),
        key: 'repository',
        transform: (repository) => ((repository === null || repository === void 0 ? void 0 : repository.url) ? repository.url : repository),
        type: 'link',
        action: (e, link) => window.open(link, '_blank', 'noopener,noreferrer')
    },
    {
        label: gettext('Homepage'),
        key: 'homepage',
        type: 'link',
        action: (e, link) => window.open(link, '_blank', 'noopener,noreferrer')
    },
    {
        label: gettext('Required platform version'),
        key: 'requiredPlatformVersion'
    },
    {
        label: gettext('License'),
        key: 'license'
    }
];

class EcosystemError extends Error {
    constructor(type) {
        super(ERROR_MESSAGES[type]);
        this.type = type;
    }
}

const CUMULOCITY_JSON = 'cumulocity.json';
const MICROSERVICE_NAME_MAX_LENGTH = 23;
class EcosystemService {
    constructor(modal, alertService, humanizeAppName, translateService, applicationService, appStateService, zipService, tenantService, inventoryService, wizardModalService) {
        this.modal = modal;
        this.alertService = alertService;
        this.humanizeAppName = humanizeAppName;
        this.translateService = translateService;
        this.applicationService = applicationService;
        this.appStateService = appStateService;
        this.zipService = zipService;
        this.tenantService = tenantService;
        this.inventoryService = inventoryService;
        this.wizardModalService = wizardModalService;
        this.appDeleted = new EventEmitter();
        this.progress = new BehaviorSubject(null);
        this.appsGroupedByContextPath$ = defer(() => this.getWebApplications()).pipe(map(webApps => groupBy(webApps, 'contextPath')), shareReplay({ bufferSize: 1, refCount: true }));
    }
    getUniqueAppConfig(srcApp, existingApps) {
        let app = {
            name: srcApp.name,
            key: srcApp.key,
            contextPath: srcApp.contextPath
        };
        for (let retryNo = 0; retryNo < 9;) {
            if (this.checkIfAppNameKeyPathExists(existingApps, app, retryNo)) {
                retryNo++;
                app = {
                    name: [srcApp.name, retryNo].join('-'),
                    key: [srcApp.key, retryNo].join('-'),
                    contextPath: [srcApp.contextPath, retryNo].join('-')
                };
            }
            else {
                return app;
            }
        }
        return app;
    }
    /**
     * Verify versions compatibility for blueprints. If a blueprint version
     * is not compatible, a warning is shown.
     *
     * @param blueprint The blueprint to install.
     * @returns true if the installation can continue or false if it should be aborted.
     */
    verifyBlueprintVersionsCompatibility(blueprint) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = yield this.getPlatformVersion();
            if (blueprint.versioningMatrix) {
                try {
                    const pluginApiVersion = blueprint.versioningMatrix[blueprint.version].api;
                    if (!satisfies(api, pluginApiVersion)) {
                        return yield this.showModal(blueprint, false);
                    }
                }
                catch (_a) {
                    return yield this.showModal(blueprint, false);
                }
            }
            return true;
        });
    }
    /**
     * Verify versions compatibility for plugins. In case a version does not exist in the
     * versioningMatrix we don't do anything due to backward compatibility. If a plugin version
     * is not compatible, a warning is shown.
     *
     * @param pluginsToInstall The list of plugins to install.
     * @returns true if the installation can continue or false if it should be aborted.
     */
    verifyPluginVersionsCompatibility(pluginsToInstall, app) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const api = yield this.getPlatformVersion();
            const sdk = (_a = app.manifest) === null || _a === void 0 ? void 0 : _a.webSDKversion;
            for (const plugin of pluginsToInstall) {
                if (plugin.versioningMatrix) {
                    try {
                        const pluginSdkVersion = plugin.versioningMatrix[plugin.version].sdk;
                        const pluginApiVersion = plugin.versioningMatrix[plugin.version].api;
                        if (!satisfies(sdk, pluginSdkVersion) || !satisfies(api, pluginApiVersion)) {
                            return yield this.showModal(plugin, true);
                        }
                    }
                    catch (_b) {
                        return yield this.showModal(plugin, false);
                    }
                }
            }
            return true;
        });
    }
    /**
     * Community plugins need to verify the license agreement. If a package is a community
     * package, the license is shown.
     *
     * @param pluginsToInstall The list of plugins to install.
     * @returns true if the installation can continue.
     */
    verifyLicenses(pluginsToInstall) {
        return __awaiter(this, void 0, void 0, function* () {
            let _resolve;
            const result = new Promise(resolve => {
                _resolve = resolve;
            });
            pluginsToInstall = pluginsToInstall.filter(plugin => plugin.type !== PackageType.CUSTOM);
            if (pluginsToInstall.length === 0) {
                return Promise.resolve(true);
            }
            const initialState = {
                id: EcosystemWizards.LICENSE_CONFIRM,
                componentInitialState: {
                    pluginsToInstall
                }
            };
            const modalOptions = { initialState };
            const wizard = this.wizardModalService.show(modalOptions);
            wizard.content.onClose.subscribe(confirmed => {
                _resolve(confirmed);
            });
            return result;
        });
    }
    /**
     * @description
     * Compares currently deployed application version with application version tagged as "latest"
     *
     * @param {string} currentApplicationVersion Deployed application version
     * @param {object} latestApp Latest application version object
     *
     * @returns {boolean} Returns true if latest version is greater than current, otherwise false
     */
    shouldUpgradePackage(currentApplicationVersion, latestApp) {
        const latestApplicationVersion = latestApp === null || latestApp === void 0 ? void 0 : latestApp.version;
        if (!latestApplicationVersion || !currentApplicationVersion) {
            return false;
        }
        return gt(coerce(latestApplicationVersion), coerce(currentApplicationVersion));
    }
    /**
     * @description
     * Gets an object that contains searched tag
     *
     * @param {array} applicationVersions Array with all available versions
     * @param {string} tagName Searched tag
     *
     * @returns {object} Returns an object with searched tag
     */
    getApplicationVersionObjectByTag(applicationVersions, tagName) {
        return applicationVersions === null || applicationVersions === void 0 ? void 0 : applicationVersions.find(element => element.tags.includes(tagName));
    }
    getApplication(appId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.applicationService.detail(appId)).data;
        });
    }
    getApplications(customFilter = {}) {
        const filter = {
            pageSize: 2000,
            withTotalPages: true
        };
        Object.assign(filter, customFilter);
        const currentTenant = this.appStateService.currentTenant.value;
        return this.applicationService.listByTenant(currentTenant.name, filter);
    }
    getMicroservices() {
        return __awaiter(this, void 0, void 0, function* () {
            const apps = (yield this.getApplications()).data;
            const microservices = apps.filter(app => this.isMicroservice(app));
            return microservices.sort((a, b) => a.name.localeCompare(b.name));
        });
    }
    getWebApplications(customFilter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const apps = (yield this.getApplications(customFilter)).data;
            const webApps = apps.filter(app => this.isApplication(app));
            return webApps.sort((a, b) => a.name.localeCompare(b.name));
        });
    }
    getFeatureApplications(customFilter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const apps = (yield this.getApplications(customFilter)).data;
            const webApps = apps.filter(app => this.isFeature(app));
            return webApps.sort((a, b) => a.name.localeCompare(b.name));
        });
    }
    getPackageApplications(customFilter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = Object.assign({}, customFilter);
            const sharedFilter = Object.assign({
                availability: ApplicationAvailability.SHARED,
                type: 'HOSTED',
                pageSize: 2000
            }, customFilter);
            const [{ data: apps }, { data: shared }] = yield Promise.all([
                this.getApplications(filter),
                this.applicationService.list(sharedFilter)
            ]);
            const webApps = [...apps, ...shared].filter(app => this.isPackage(app));
            // an app could be subscribed to a tenant, but also have it's availability set to SHARED, in that case it would occur twice.
            const uniqWebApps = uniqBy(webApps, (app) => app.id);
            return uniqWebApps.sort((a, b) => a.name.localeCompare(b.name));
        });
    }
    isMicroserviceHostingAllowed() {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: apps } = yield this.applicationService.listByName('feature-microservice-hosting');
            return !!apps.filter(app => { var _a, _b; return ((_b = (_a = app.owner) === null || _a === void 0 ? void 0 : _a.tenant) === null || _b === void 0 ? void 0 : _b.id) === 'management'; }).length;
        });
    }
    canOpenAppInBrowser(app) {
        const isNotAFeature = !this.isFeature(app);
        const hasProperType = [ApplicationType.HOSTED, ApplicationType.EXTERNAL].includes(app.type);
        const isNotPackage = !this.isPackage(app);
        return isNotAFeature && hasProperType && isNotPackage;
    }
    openApp(app) {
        window.open(this.applicationService.getHref(app), '_blank', 'noopener,noreferrer');
    }
    canDeleteApp(app) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.isOwner(app) && (!this.isCurrentApp(app) || (yield this.hasSubscribedAppParent(app))));
        });
    }
    isOwner(app) {
        const currentTenant = this.appStateService.currentTenant.value;
        const appOwner = get(app, 'owner.tenant.id');
        return currentTenant.name === appOwner;
    }
    isFeature(app) {
        return !!app.name.match(/feature-/);
    }
    isMicroservice(app) {
        return app.type === 'MICROSERVICE';
    }
    isExternal(app) {
        return app.type === 'EXTERNAL';
    }
    isPackage(app) {
        var _a;
        return ((_a = app.manifest) === null || _a === void 0 ? void 0 : _a.isPackage) === true;
    }
    isPlugin(app) {
        var _a;
        return ((_a = app.manifest) === null || _a === void 0 ? void 0 : _a.package) === 'plugin';
    }
    cancelAppCreation(app) {
        if (this.xhr) {
            this.xhr.abort();
        }
        if (app) {
            this.applicationService.delete(app);
        }
    }
    updateUploadProgress(event) {
        if (event.lengthComputable) {
            const currentProgress = this.progress.value;
            this.progress.next(currentProgress + (event.loaded / event.total) * (95 - currentProgress));
        }
    }
    setAppActiveVersion(app, activeVersionId) {
        return this.applicationService.update({ id: app.id, activeVersionId });
    }
    setPackageVersionTag(app, version, tags) {
        return this.applicationService.setPackageVersionTag(app, version, tags);
    }
    deletePackageVersion(app, params) {
        return this.applicationService.deleteVersionPackage(app, params);
    }
    getHumanizedAppName(app) {
        return this.humanizeAppName.transform(app.name).pipe(debounceTime(250), take(1)).toPromise();
    }
    createConfig(app, formGroupValue) {
        const { id, type, availability } = app;
        let config = pick(formGroupValue, ['name', 'key', 'contextPath']);
        config = Object.assign(Object.assign({}, config), { isSetup: true, id,
            type,
            availability });
        return config;
    }
    updateAppManifest(application, sourcePackage) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id } = application;
            const cleanedApp = this.removeAppProperties(application);
            if (!cleanedApp.manifest) {
                cleanedApp.manifest = {};
            }
            cleanedApp.manifest.isPackage = false;
            cleanedApp.manifest.source = sourcePackage.id;
            return yield this.applicationService
                .binary(id)
                .updateFiles([{ path: CUMULOCITY_JSON, contents: JSON.stringify(cleanedApp) }]);
        });
    }
    listArchives(appId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = {
                pageSize: 100
            };
            return (yield this.applicationService.binary(appId).list(filter)).data;
        });
    }
    deleteArchive(archive, app) {
        return __awaiter(this, void 0, void 0, function* () {
            const humanizedArchiveName = yield this.getHumanizedAppName(archive);
            try {
                yield this.modal.confirm(gettext('Delete archive'), this.translateService.instant(gettext(`You are about to delete archive "{{ humanizedArchiveName }}". Do you want to proceed?`), { humanizedArchiveName }), Status.DANGER, { ok: gettext('Delete'), cancel: gettext('Cancel') });
                yield this.applicationService.binary(app).delete(archive.id);
                this.alertService.success(gettext('Archive deleted.'));
            }
            catch (ex) {
                if (ex) {
                    this.alertService.danger(get(ex, 'data.message'), ex.data);
                }
                throw new Error('Cancelled');
            }
        });
    }
    getArchiveManagedObject(binaryId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.inventoryService.detail(binaryId)).data;
        });
    }
    downloadArchive(app, archive) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const binary = yield this.getBinary(app, archive);
                const fileBinary = new Blob([binary], { type: 'application/x-zip-compressed' });
                saveAs(fileBinary, archive.name);
            }
            catch (e) {
                // empty
            }
        });
    }
    updateApp(app, deleteOnFailure = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.applicationService.update(app);
            }
            catch (ex) {
                this.alertError(ex);
                if (deleteOnFailure) {
                    yield this.applicationService.delete(app.id);
                    throw new EcosystemError(ERROR_TYPE.APPLICATION_CREATION_FAILED);
                }
            }
        });
    }
    deleteApp(app, silent = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const humanizedAppName = yield this.getHumanizedAppName(app);
            if (!silent) {
                yield this.modal.confirm(gettext('Delete application'), this.translateService.instant(gettext(`You are about to delete application "{{ humanizedAppName }}". Do you want to proceed?`), { humanizedAppName }), Status.DANGER, { ok: gettext('Delete'), cancel: gettext('Cancel') });
            }
            yield this.applicationService.delete(app.id);
            if (!silent) {
                this.alertService.success(gettext('Application deleted.'));
            }
            this.appDeleted.emit(app);
        });
    }
    checkIfSubscribed(app) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTenant = yield this.tenantService.current();
            const subscribedApps = currentTenant.data.applications.references;
            return subscribedApps.some(application => application.application.id === app.id);
        });
    }
    subscribeApp(app) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTenant = this.appStateService.currentTenant.value;
            try {
                yield this.tenantService.subscribeApplication(currentTenant, app);
                this.alertService.success(gettext('Successfully subscribed to application.'));
            }
            catch (ex) {
                this.alertError(ex);
            }
        });
    }
    unsubscribeApp(app) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTenant = this.appStateService.currentTenant.value;
            try {
                yield this.tenantService.unsubscribeApplication(currentTenant, app);
                this.alertService.success(gettext('Successfully unsubscribed from application.'));
            }
            catch (ex) {
                this.alertError(ex);
            }
        });
    }
    isValidAppType(archive, appType) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const currentType = yield this.getAppType(archive);
                if (currentType !== appType) {
                    throw new EcosystemError(ERROR_TYPE.TYPE_VALIDATION);
                }
                else {
                    this.progress.next(this.progress.value + 10);
                    return true;
                }
            }
            catch (ex) {
                throw new EcosystemError(ERROR_TYPE.TYPE_VALIDATION);
            }
        });
    }
    uploadArchiveToApp(archive, app, isNewVersion = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let uploadOverrides;
            if (isNewVersion) {
                uploadOverrides = yield this.getUploadOverrides(archive, app);
            }
            const binaryService = this.applicationService.binary(app);
            this.xhr = binaryService.uploadWithProgressXhr(archive, this.updateUploadProgress.bind(this), '', uploadOverrides);
            const binaryMo = yield binaryService.getXMLHttpResponse(this.xhr);
            // TODO commented it due to: https://cumulocity.atlassian.net/browse/MTM-48553
            // Add it back when BE fixes issues with activeVersion.
            // if (isNewVersion) {
            //   return await this.getApplication(app);
            // }
            return (yield this.setAppActiveVersion(app, (binaryMo.binaryId || binaryMo.id))).data;
        });
    }
    validateArchiveToAppCompatibility(archive, app) {
        return __awaiter(this, void 0, void 0, function* () {
            const appType = yield this.getAppType(archive);
            if (appType !== app.type) {
                throw new EcosystemError(ERROR_TYPE.INVALID_APPLICATION);
            }
            else {
                this.progress.next(this.progress.value + 10);
            }
            if (this.isMicroservice(app)) {
                return;
            }
            const manifest = yield this.getCumulocityJson(archive);
            // A user can upload an app without a Cumulocity JSON file (e.g. a react app).
            // This is allowed and should not trigger a validation error.
            if (!manifest) {
                return;
            }
            yield this.validatePackageKeyAndContextPath(manifest, app);
        });
    }
    getCumulocityJson(archive) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const c8yManifest = yield this.getCumulocityJson$(archive).toPromise();
                return c8yManifest;
            }
            catch (ex) {
                return null;
            }
        });
    }
    createAppForArchive(archive, isPackageTypeArchive = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let isPackage = false;
            const appType = yield this.getAppType(archive);
            let appModel = {};
            const supportedAppTypes = [ApplicationType.HOSTED, ApplicationType.MICROSERVICE];
            if (supportedAppTypes.includes(appType)) {
                try {
                    appModel = yield this.getCumulocityJson$(archive).toPromise();
                    isPackage = appModel.isPackage;
                }
                catch (e) {
                    // do nothing, we allow having HOSTED applications without the manifest file
                }
            }
            const name = this.getBaseNameFromArchiveOrAppModel(archive, appType, appModel);
            const clearedName = this.removeForbiddenCharacters(name);
            const key = this.getAppKey(appModel, clearedName);
            const contextPath = this.getContextPath(appModel, name);
            const appToSave = {
                type: appType,
                name,
                key,
                contextPath
            };
            if (isPackageTypeArchive && !isPackage) {
                throw new EcosystemError(ERROR_TYPE.INVALID_PACKAGE);
            }
            else if (!isPackageTypeArchive && isPackage) {
                throw new EcosystemError(ERROR_TYPE.INVALID_APPLICATION);
            }
            else if (this.isNameLengthExceeded(name, appType)) {
                const error = new Error();
                error.name = ERROR_TYPE.MICROSERVICE_NAME_TOO_LONG;
                error.message = this.translateService.instant(ERROR_MESSAGES[error.name], {
                    name,
                    maxChars: MICROSERVICE_NAME_MAX_LENGTH
                });
                throw error;
            }
            return (yield this.applicationService.create(Object.assign(Object.assign({}, appToSave), { manifest: Object.assign({ isPackage }, ((appModel === null || appModel === void 0 ? void 0 : appModel.package) && { package: appModel.package })) }))).data;
        });
    }
    reactivateArchive(app) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.applicationService.reactivateArchive(app.id);
                this.alertService.success(gettext('Application reactivated.'));
            }
            catch (ex) {
                this.alertError(ex);
            }
        });
    }
    removeOldestArchive(app, archives) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.modal.confirm(gettext('Delete oldest archive and continue'), gettext('Up to 6 archives can be saved in the platform. If you upload a new archive, the oldest archive that is not active will be deleted. Do you want to proceed?'), Status.INFO, { ok: gettext('Delete and continue') });
                const archiveToDelete = archives[archives.length - 2];
                yield this.applicationService.binary(app).delete(archiveToDelete.id);
                this.alertService.success(gettext('Archive deleted.'));
            }
            catch (ex) {
                this.alertError(ex);
            }
        });
    }
    deployApp(selectedPackage, formGroupValue, model) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Create new app config
            const config = this.createConfig(selectedPackage, formGroupValue);
            config.version = model.selected.version;
            config.isSetup = true;
            if (!config.manifest) {
                config.manifest = {};
            }
            config.manifest.isPackage = false;
            config.manifest.source = selectedPackage.id;
            config.manifest.package = 'blueprint';
            // Create new app
            const newApp = (yield this.applicationService.create(config)).data;
            // Binary
            try {
                // Get binary details
                const { data: binaryDetails } = yield this.inventoryService.detail(model.selected.binaryId);
                // Get binary from specific package version
                const binary = yield this.getBinary(selectedPackage, {
                    id: model.selected.binaryId
                });
                // Create zip
                const fileBinary = new Blob([binary], { type: binaryDetails.contentType });
                const file = new File([fileBinary], binaryDetails.name, {
                    type: binaryDetails.contentType
                });
                // Upload binary to new app
                yield this.uploadArchiveToApp(file, newApp);
                // Update manifest
                yield this.updateAppManifest(newApp, selectedPackage);
            }
            catch (error) {
                if (((_a = error === null || error === void 0 ? void 0 : error.res) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                    yield this.applicationService.delete(newApp.id);
                    yield this.fallbackToCloneLatest(config, selectedPackage);
                }
            }
        });
    }
    fallbackToCloneLatest(config, selectedPackage) {
        return __awaiter(this, void 0, void 0, function* () {
            let clonedPkg;
            try {
                clonedPkg = (yield this.applicationService.clone(selectedPackage)).data;
                // clean out all falsely cloned applicationVersions, we don't need them
                for (const appVersion of clonedPkg.applicationVersions) {
                    if (appVersion.tags.includes('latest')) {
                        yield this.setPackageVersionTag(clonedPkg, appVersion.version, []);
                    }
                    yield this.deletePackageVersion(clonedPkg, {
                        version: appVersion.version
                    });
                }
                delete config.type;
                config.isPackage = false;
                const { data: newApp } = yield this.updateApp(Object.assign({ id: clonedPkg.id, activeVersionId: clonedPkg.activeVersionId }, config), false);
                yield this.updateAppManifest(newApp, selectedPackage);
            }
            catch (error) {
                yield this.deleteApp(clonedPkg.id, true);
            }
        });
    }
    getAppState(app) {
        if (!this.isOwner(app)) {
            return APP_STATE.SUBSCRIBED;
        }
        else if (this.isUnpacked(app)) {
            return APP_STATE.UNPACKED;
        }
        else if (app.type === ApplicationType.EXTERNAL) {
            return APP_STATE.EXTERNAL;
        }
        return APP_STATE.CUSTOM;
    }
    getPackageContentState(app) {
        if (!this.isPackage(app)) {
            return;
        }
        if (this.isPackageBlueprint(app)) {
            return APP_STATE.PACKAGE_BLUEPRINT;
        }
        if (this.isPluginsPackage(app)) {
            return APP_STATE.PACKAGE_PLUGIN;
        }
        return APP_STATE.PACKAGE_UNKNOWN;
    }
    isPackageBlueprint(app) {
        return this.isPackage(app) && app.manifest.package === 'blueprint';
    }
    isPluginsPackage(app) {
        return this.isPackage(app) && app.manifest.package === 'plugin';
    }
    isUnpacked(app) {
        var _a;
        return !!((_a = app.manifest) === null || _a === void 0 ? void 0 : _a.source);
    }
    hasExports(app) {
        var _a, _b;
        return !!((_b = (_a = app.manifest) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.length);
    }
    isApplication(app) {
        return (app.type !== ApplicationType.MICROSERVICE && !this.isFeature(app) && !this.isPackage(app));
    }
    isCustomMicroservice(app) {
        return this.isOwner(app) && app.type === ApplicationType.MICROSERVICE;
    }
    getBinary(app, archive) {
        return __awaiter(this, void 0, void 0, function* () {
            let binary;
            try {
                const res = yield this.applicationService.binary(app).downloadArchive(archive.id);
                binary = yield res.arrayBuffer();
            }
            catch (ex) {
                const msg = gettext('Could not get the binary.');
                this.alertService.danger(msg);
            }
            return binary;
        });
    }
    isOverwrittenByCustomApp(app) {
        return __awaiter(this, void 0, void 0, function* () {
            return !this.isOwner(app) && (yield this.hasSubscribedAppParent(app));
        });
    }
    hasSubscribedAppParent(app) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const appsGroupedByContextPath = yield this.appsGroupedByContextPath$.pipe(take(1)).toPromise();
            return app.contextPath && ((_a = appsGroupedByContextPath[app.contextPath]) === null || _a === void 0 ? void 0 : _a.length) === 2;
        });
    }
    /**
     * @deprecated
     */
    setAvailabilityToPrivateIfNotSetAlready(app) {
        app.availability = ApplicationAvailability.PRIVATE;
        return app;
    }
    /**
     * Shows an error dialog.
     * @param error Either a server error or an internal [[EcosystemError]].
     */
    alertError(error) {
        if (error instanceof EcosystemError) {
            this.alertService.danger(error.message);
        }
        else {
            this.alertService.addServerFailure(error);
        }
    }
    validatePackageKeyAndContextPath(manifest, app) {
        return __awaiter(this, void 0, void 0, function* () {
            const contextPath = get(manifest, 'contextPath');
            const appKey = get(manifest, 'key');
            if (contextPath !== app.contextPath || appKey !== app.key) {
                throw new EcosystemError(ERROR_TYPE.KEY_OR_CONTEXT_PATH_MISMATCH);
            }
        });
    }
    filterContainString(name, filterTerm) {
        const term = filterTerm.toLowerCase().trim();
        return name && name.toLowerCase().indexOf(term) > -1;
    }
    showModal(packageType, isPlugin) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let message;
                if (packageType.name) {
                    message = gettext(`The current version of the package "{{ name }}" that you are trying to install is not compatible with the platform version. Do you want to proceed?`);
                }
                else if (isPlugin) {
                    message = gettext(`The current version of the plugin that you are trying to install is not compatible with the platform version. Do you want to proceed?`);
                }
                else {
                    message = gettext(`The current version of the blueprint that you are trying to install is not compatible with the platform version. Do you want to proceed?`);
                }
                const translatedBody = this.translateService.instant(message, {
                    name: packageType.name
                });
                yield this.modal.confirm(gettext('Blueprint installation'), translatedBody, 'warning', {
                    ok: gettext('Continue'),
                    cancel: gettext('Cancel')
                });
            }
            catch (_a) {
                // modal canceled
                return false;
            }
            return true;
        });
    }
    getPlatformVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.appStateService.state$
                .pipe(take(1), map(state => { var _a; return (_a = state === null || state === void 0 ? void 0 : state.versions) === null || _a === void 0 ? void 0 : _a.backend; }), filter(backendVersion => !!backendVersion))
                .toPromise();
        });
    }
    getAppKey(appModel, name) {
        let key = appModel === null || appModel === void 0 ? void 0 : appModel.key;
        if (!key) {
            key = `${kebabCase(name)}-key`;
        }
        return key;
    }
    getContextPath(appModel, name) {
        return (appModel === null || appModel === void 0 ? void 0 : appModel.contextPath) || name.toLowerCase();
    }
    removeForbiddenCharacters(str) {
        return str.replace(/[^a-zA-Z0-9-_]/g, '');
    }
    isCurrentApp(app) {
        const currentApp = this.appStateService.state.app;
        return currentApp.contextPath === app.contextPath;
    }
    getCumulocityJson$(archive) {
        return this.zipService.getJsonData(archive, {
            filename: CUMULOCITY_JSON
        });
    }
    getAppType(archive) {
        return this.getCumulocityJson$(archive)
            .toPromise()
            .then(data => get(data, 'type') ||
            (get(data, 'apiVersion') ? ApplicationType.MICROSERVICE : ApplicationType.HOSTED))
            .catch(() => ApplicationType.HOSTED);
    }
    getBaseNameFromArchiveOrAppModel(archive, appType, appModel) {
        let baseName = (appModel === null || appModel === void 0 ? void 0 : appModel.name) || archive.name.replace(/\.zip$/i, '');
        if (appType === 'MICROSERVICE') {
            baseName = this.removeVersionFromName(baseName);
        }
        return baseName;
    }
    checkIfAppNameKeyPathExists(existingApps, app, retryNo) {
        return existingApps.find(existingApp => existingApp.name === app.name ||
            existingApp.key === app.key ||
            existingApp.contextPath === app.contextPath ||
            existingApp.name === [app.name, retryNo].join('-') ||
            existingApp.key === [app.key, retryNo].join('-') ||
            existingApp.contextPath === [app.contextPath, retryNo].join('-'));
    }
    removeAppProperties(app) {
        const tempApp = cloneDeep(app);
        const propertiesToRemove = ['id', 'owner', 'activeVersionId', 'self'];
        propertiesToRemove.forEach(prop => delete tempApp[prop]);
        return tempApp;
    }
    getUploadOverrides(archive, app) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { version } = yield this.getCumulocityJson$(archive).toPromise();
            const isInitialPackage = ((_a = app.applicationVersions) === null || _a === void 0 ? void 0 : _a.length) === 0;
            return {
                listUrl: 'versions',
                headers: {
                    Accept: 'application/vnd.com.nsn.cumulocity.applicationVersion+json;charset=UTF-8;ver=0.9'
                },
                bodyFileProperty: 'applicationBinary',
                requestBody: {
                    applicationVersion: Object.assign({ version }, (isInitialPackage && { tags: ['latest'] }))
                }
            };
        });
    }
    removeVersionFromName(name) {
        const versionRegExp = /-\d+\.\d+\.\d+(\.\d+)?(-\d+)?(.*)$/;
        return name.replace(versionRegExp, '');
    }
    isNameLengthExceeded(name, appType) {
        return name.length > MICROSERVICE_NAME_MAX_LENGTH && appType === ApplicationType.MICROSERVICE;
    }
}
EcosystemService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: EcosystemService, deps: [{ token: i2.ModalService }, { token: i2.AlertService }, { token: i2.HumanizeAppNamePipe }, { token: i2$1.TranslateService }, { token: i3.ApplicationService }, { token: i2.AppStateService }, { token: i2.ZipService }, { token: i3.TenantService }, { token: i3.InventoryService }, { token: i2.WizardModalService }], target: i0.ɵɵFactoryTarget.Injectable });
EcosystemService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: EcosystemService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: EcosystemService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.ModalService }, { type: i2.AlertService }, { type: i2.HumanizeAppNamePipe }, { type: i2$1.TranslateService }, { type: i3.ApplicationService }, { type: i2.AppStateService }, { type: i2.ZipService }, { type: i3.TenantService }, { type: i3.InventoryService }, { type: i2.WizardModalService }]; } });

class AddApplicationComponent {
    constructor(ecosystemService, alertService, applicationService, wizardComponent, translateService) {
        this.ecosystemService = ecosystemService;
        this.alertService = alertService;
        this.applicationService = applicationService;
        this.wizardComponent = wizardComponent;
        this.translateService = translateService;
        this.canGoBack = false;
        this.canOpenInBrowser = false;
        this.uploadCanceled = false;
    }
    get progress() {
        return this.ecosystemService.progress;
    }
    onFileDroppedEvent(event) {
        if (event && event.length > 0) {
            const file = event[0].file;
            this.onFile(file);
        }
    }
    onFile(file) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isLoading = true;
            this.errorMessage = null;
            this.progress.next(0);
            try {
                this.createdApp = yield this.createApplicationHandler(file);
                yield this.uploadApplicationHandler(file, this.createdApp);
                this.canOpenInBrowser = this.ecosystemService.canOpenAppInBrowser(this.createdApp);
                this.isAppCreated = true;
            }
            catch (ex) {
                this.ecosystemService.cancelAppCreation(this.createdApp);
                this.createdApp = null;
                this.dropAreaComponent.onDelete();
                // prepare translation of static message if it exists
                const staticErrorMessage = ERROR_MESSAGES[ex.message] && this.translateService.instant(ERROR_MESSAGES[ex.message]);
                // if there is no static message, use dynamic one from the exception
                this.errorMessage = staticErrorMessage !== null && staticErrorMessage !== void 0 ? staticErrorMessage : ex.message;
                if (!this.errorMessage && !this.uploadCanceled) {
                    this.alertService.addServerFailure(ex);
                }
            }
            this.progress.next(100);
            this.isLoading = false;
        });
    }
    getHref(app) {
        return this.applicationService.getHref(app);
    }
    cancel() {
        this.cancelFileUpload();
        this.wizardComponent.close();
    }
    done() {
        this.wizardComponent.close();
    }
    back() {
        this.wizardComponent.reset();
    }
    cancelFileUpload() {
        this.uploadCanceled = true;
        this.ecosystemService.cancelAppCreation(this.createdApp);
        this.createdApp = null;
    }
}
AddApplicationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: AddApplicationComponent, deps: [{ token: EcosystemService }, { token: i2.AlertService }, { token: i3.ApplicationService }, { token: i2.WizardComponent }, { token: i2$1.TranslateService }], target: i0.ɵɵFactoryTarget.Component });
AddApplicationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: AddApplicationComponent, selector: "c8y-add-application", inputs: { headerText: "headerText", headerIcon: "headerIcon", successText: "successText", createApplicationHandler: "createApplicationHandler", uploadApplicationHandler: "uploadApplicationHandler", canGoBack: "canGoBack" }, viewQueries: [{ propertyName: "dropAreaComponent", first: true, predicate: DropAreaComponent, descendants: true }], ngImport: i0, template: "<c8y-wizard-header>\n  <i [c8yIcon]=\"headerIcon\"></i>\n  <h4 id=\"modal-title\">{{ headerText | translate }}</h4>\n</c8y-wizard-header>\n\n<c8y-wizard-body>\n  <p class=\"p-16 text-center text-medium separator-bottom sticky-top bg-component\">\n    {{ 'Upload a *.zip file' | translate }}\n  </p>\n  <c8y-form-group\n    *ngIf=\"!isAppCreated; else appCreated\"\n    [hasError]=\"!!errorMessage\"\n    class=\"m-t-16 m-l-auto m-r-auto\"\n    style=\"max-width: 285px\"\n    id=\"modal-body\"\n  >\n    <c8y-drop-area\n      (dropped)=\"onFileDroppedEvent($event)\"\n      [accept]=\"'.zip'\"\n      [loading]=\"isLoading\"\n      [maxAllowedFiles]=\"1\"\n      [progress]=\"progress | async\"\n      class=\"drop-area\"\n    ></c8y-drop-area>\n    <c8y-messages>\n      <c8y-message *ngIf=\"errorMessage\">\n        {{ errorMessage | translate }}\n      </c8y-message>\n    </c8y-messages>\n  </c8y-form-group>\n  <ng-template #appCreated>\n    <div class=\"d-flex a-i-center j-c-center\" style=\"min-height: 285px\">\n      <c8y-operation-result\n        text=\"{{ successText | translate }}\"\n        [vertical]=\"true\"\n        [size]=\"84\"\n        class=\"lead\"\n        type=\"success\"\n      ></c8y-operation-result>\n    </div>\n  </ng-template>\n</c8y-wizard-body>\n\n<c8y-wizard-footer>\n  <button\n    (click)=\"back()\"\n    *ngIf=\"!isAppCreated && canGoBack\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Back' | translate }}\"\n    translate\n    type=\"button\"\n  >\n    Back\n  </button>\n  <button\n    (click)=\"cancel()\"\n    *ngIf=\"!isAppCreated\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Cancel' | translate }}\"\n    translate\n    type=\"button\"\n  >\n    Cancel\n  </button>\n  <button\n    (click)=\"done()\"\n    *ngIf=\"isAppCreated\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Done' | translate }}\"\n    translate\n    type=\"button\"\n  >\n    Done\n  </button>\n  <a\n    (click)=\"$event.stopPropagation()\"\n    *ngIf=\"isAppCreated && canOpenInBrowser\"\n    [href]=\"getHref(createdApp)\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n    class=\"btn btn-primary\"\n    title=\"{{ 'Open' | translate }}\"\n  >\n    <i c8yIcon=\"external-link\" class=\"m-r-4\"></i>\n    {{ 'Open' | translate }}\n  </a>\n</c8y-wizard-footer>\n", dependencies: [{ kind: "directive", type: i2.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i2.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i3$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.OperationResultComponent, selector: "c8y-operation-result", inputs: ["text", "vertical", "size", "type"] }, { kind: "component", type: i2.DropAreaComponent, selector: "c8y-drop-area", inputs: ["formControl", "title", "message", "icon", "loadingMessage", "forceHideList", "alwaysShow", "clickToOpen", "loading", "progress", "maxAllowedFiles", "files", "maxFileSizeInMegaBytes", "accept"], outputs: ["dropped"] }, { kind: "component", type: i2.FormGroupComponent, selector: "c8y-form-group", inputs: ["hasError", "hasWarning", "hasSuccess", "novalidation", "status"] }, { kind: "directive", type: i2.MessageDirective, selector: "c8y-message", inputs: ["name", "text"] }, { kind: "component", type: i2.MessagesComponent, selector: "c8y-messages", inputs: ["show", "defaults"] }, { kind: "component", type: i2.WizardHeaderComponent, selector: "c8y-wizard-header" }, { kind: "component", type: i2.WizardBodyComponent, selector: "c8y-wizard-body" }, { kind: "component", type: i2.WizardFooterComponent, selector: "c8y-wizard-footer" }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3$1.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: AddApplicationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-add-application', template: "<c8y-wizard-header>\n  <i [c8yIcon]=\"headerIcon\"></i>\n  <h4 id=\"modal-title\">{{ headerText | translate }}</h4>\n</c8y-wizard-header>\n\n<c8y-wizard-body>\n  <p class=\"p-16 text-center text-medium separator-bottom sticky-top bg-component\">\n    {{ 'Upload a *.zip file' | translate }}\n  </p>\n  <c8y-form-group\n    *ngIf=\"!isAppCreated; else appCreated\"\n    [hasError]=\"!!errorMessage\"\n    class=\"m-t-16 m-l-auto m-r-auto\"\n    style=\"max-width: 285px\"\n    id=\"modal-body\"\n  >\n    <c8y-drop-area\n      (dropped)=\"onFileDroppedEvent($event)\"\n      [accept]=\"'.zip'\"\n      [loading]=\"isLoading\"\n      [maxAllowedFiles]=\"1\"\n      [progress]=\"progress | async\"\n      class=\"drop-area\"\n    ></c8y-drop-area>\n    <c8y-messages>\n      <c8y-message *ngIf=\"errorMessage\">\n        {{ errorMessage | translate }}\n      </c8y-message>\n    </c8y-messages>\n  </c8y-form-group>\n  <ng-template #appCreated>\n    <div class=\"d-flex a-i-center j-c-center\" style=\"min-height: 285px\">\n      <c8y-operation-result\n        text=\"{{ successText | translate }}\"\n        [vertical]=\"true\"\n        [size]=\"84\"\n        class=\"lead\"\n        type=\"success\"\n      ></c8y-operation-result>\n    </div>\n  </ng-template>\n</c8y-wizard-body>\n\n<c8y-wizard-footer>\n  <button\n    (click)=\"back()\"\n    *ngIf=\"!isAppCreated && canGoBack\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Back' | translate }}\"\n    translate\n    type=\"button\"\n  >\n    Back\n  </button>\n  <button\n    (click)=\"cancel()\"\n    *ngIf=\"!isAppCreated\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Cancel' | translate }}\"\n    translate\n    type=\"button\"\n  >\n    Cancel\n  </button>\n  <button\n    (click)=\"done()\"\n    *ngIf=\"isAppCreated\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Done' | translate }}\"\n    translate\n    type=\"button\"\n  >\n    Done\n  </button>\n  <a\n    (click)=\"$event.stopPropagation()\"\n    *ngIf=\"isAppCreated && canOpenInBrowser\"\n    [href]=\"getHref(createdApp)\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n    class=\"btn btn-primary\"\n    title=\"{{ 'Open' | translate }}\"\n  >\n    <i c8yIcon=\"external-link\" class=\"m-r-4\"></i>\n    {{ 'Open' | translate }}\n  </a>\n</c8y-wizard-footer>\n" }]
        }], ctorParameters: function () { return [{ type: EcosystemService }, { type: i2.AlertService }, { type: i3.ApplicationService }, { type: i2.WizardComponent }, { type: i2$1.TranslateService }]; }, propDecorators: { headerText: [{
                type: Input
            }], headerIcon: [{
                type: Input
            }], successText: [{
                type: Input
            }], createApplicationHandler: [{
                type: Input
            }], uploadApplicationHandler: [{
                type: Input
            }], canGoBack: [{
                type: Input
            }], dropAreaComponent: [{
                type: ViewChild,
                args: [DropAreaComponent]
            }] } });

class TranslatePackageLabelPipe {
    constructor(translate) {
        this.translate = translate;
    }
    transform(rawPackageLabel) {
        const isOneOfTheKnownOnes = !!PACKAGE_TYPE_LABELS[rawPackageLabel];
        if (isOneOfTheKnownOnes) {
            return this.translate.instant(PACKAGE_TYPE_LABELS[rawPackageLabel].label);
        }
        return rawPackageLabel;
    }
}
TranslatePackageLabelPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TranslatePackageLabelPipe, deps: [{ token: i2$1.TranslateService }], target: i0.ɵɵFactoryTarget.Pipe });
TranslatePackageLabelPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: TranslatePackageLabelPipe, name: "translatePackageLabel" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TranslatePackageLabelPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'translatePackageLabel' }]
        }], ctorParameters: function () { return [{ type: i2$1.TranslateService }]; } });

class ApplicationCardComponent {
    get openButtonTitle() {
        return !this.disableOpenInBrowser
            ? gettext('Open')
            : gettext('This application is overridden.');
    }
    constructor(applicationService, ecosystemService, alertService, router, wizardModalService, alert, pluginService, gainsightService) {
        this.applicationService = applicationService;
        this.ecosystemService = ecosystemService;
        this.alertService = alertService;
        this.router = router;
        this.wizardModalService = wizardModalService;
        this.alert = alert;
        this.pluginService = pluginService;
        this.gainsightService = gainsightService;
        this.CURRENT_LOCATION = location.href;
        this.canEdit = true;
        this.onAppDeleted = new EventEmitter();
        this.onAppCloned = new EventEmitter();
        this.packageTypeLabels = PACKAGE_TYPE_LABELS;
        this.PACKAGE_TYPE = PackageType;
        this.UNPACKED_LABEL = APP_STATE.UNPACKED.label;
        this.CANNOT_DELETE_HINT = gettext(`Subscribed or current applications can't be deleted. Delete the application on the parent tenant or unsubscribe it from the current.`);
        this.PACKAGE_CONTENT_UNDETERMINED_LABEL = gettext('Package contents could not be determined.');
    }
    ngOnInit() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.appState = this.ecosystemService.getAppState(this.app);
            this.canOpenInBrowser = this.ecosystemService.canOpenAppInBrowser(this.app);
            this.packageType = this.pluginService.getPackageType(this.app);
            this.disableOpenInBrowser =
                this.canOpenInBrowser && (yield this.ecosystemService.isOverwrittenByCustomApp(this.app));
            this.canDelete = yield this.ecosystemService.canDeleteApp(this.app);
            this.isPackage = this.ecosystemService.isPackage(this.app);
            this.packageContentState = this.ecosystemService.getPackageContentState(this.app);
            this.isPlugin = this.ecosystemService.isPlugin(this.app);
            this.isFeature = this.ecosystemService.isFeature(this.app);
            this.isMicroservice = this.ecosystemService.isMicroservice(this.app);
            this.isExternal = this.ecosystemService.isExternal(this.app);
            this.canClone = !this.isMicroservice && !this.isPlugin;
            this.isUnpacked = this.ecosystemService.isUnpacked(this.app);
            this.isShowVersion = this.shouldShowVersion();
            this.app.filterProps = {
                availability: (_a = this.appState) === null || _a === void 0 ? void 0 : _a.label,
                content: (_b = this.packageContentState) === null || _b === void 0 ? void 0 : _b.label,
                type: this.packageType
            };
            yield this.applicationUpdateCheck();
        });
    }
    shouldShowVersion() {
        var _a, _b, _c;
        return (((_a = this.app.manifest) === null || _a === void 0 ? void 0 : _a.version) &&
            (!!((_b = this.app.manifest) === null || _b === void 0 ? void 0 : _b.isPackage) || this.isMicroservice || !!((_c = this.app.manifest) === null || _c === void 0 ? void 0 : _c.source)));
    }
    detail() {
        this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.APPLICATION_CARD, {
            component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.APPLICATION_CARD,
            action: PRODUCT_EXPERIENCE.APPLICATIONS.ACTIONS.EDIT,
            url: this.CURRENT_LOCATION
        });
        if (this.isMicroservice) {
            this.router.navigateByUrl(`/ecosystem/microservice/microservices/${this.app.id}`);
            return;
        }
        if (this.isPackage) {
            this.router.navigateByUrl(`/ecosystem/extension/extensions/${this.app.id}`);
            return;
        }
        if (this.isFeature) {
            this.router.navigateByUrl(`/ecosystem/application/features/${this.app.id}`);
            return;
        }
        this.router.navigateByUrl(`/ecosystem/application/applications/${this.app.id}`);
    }
    openApp() {
        this.ecosystemService.openApp(this.app);
    }
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.ecosystemService.deleteApp(this.app);
                this.onAppDeleted.emit();
                this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.APPLICATION_CARD, {
                    component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.APPLICATION_CARD,
                    action: PRODUCT_EXPERIENCE.APPLICATIONS.ACTIONS.DELETE,
                    url: this.CURRENT_LOCATION
                });
            }
            catch (ex) {
                if (ex) {
                    this.alertService.addServerFailure(ex);
                    this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.APPLICATION_CARD, {
                        component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.APPLICATION_CARD,
                        result: PRODUCT_EXPERIENCE.APPLICATIONS.RESULTS.SERVER_FAILURE,
                        url: this.CURRENT_LOCATION
                    });
                }
            }
        });
    }
    clone() {
        return __awaiter(this, void 0, void 0, function* () {
            const wizardConfig = {
                headerText: 'Add Application',
                headerIcon: 'c8y-atom'
            };
            const initialState = {
                wizardConfig,
                componentInitialState: {
                    selectedApp: new BehaviorSubject(this.app)
                },
                id: 'duplicateApplication'
            };
            const modalOptions = { initialState };
            const modalRef = this.wizardModalService.show(modalOptions);
            modalRef.content.onClose.subscribe(() => {
                this.onAppCloned.next();
            });
            this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.APPLICATION_CARD, {
                component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.APPLICATION_CARD,
                action: PRODUCT_EXPERIENCE.APPLICATIONS.ACTIONS.CLONE,
                url: this.CURRENT_LOCATION
            });
        });
    }
    applicationUpdateCheck() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.app.manifest) === null || _a === void 0 ? void 0 : _a.source) {
                try {
                    this.blueprintApplicationVersion = (yield this.applicationService.listVersions((_b = this.app.manifest) === null || _b === void 0 ? void 0 : _b.source)).data;
                    this.latestApplicationVersion = this.ecosystemService.getApplicationVersionObjectByTag(this.blueprintApplicationVersion, 'latest');
                    this.shouldUpgradePackage = this.ecosystemService.shouldUpgradePackage((_c = this.app.manifest) === null || _c === void 0 ? void 0 : _c.version, this.latestApplicationVersion);
                }
                catch (error) {
                    if (!this.blueprintApplicationVersion) {
                        return;
                    }
                    this.alert.addServerFailure(error);
                }
            }
        });
    }
}
ApplicationCardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ApplicationCardComponent, deps: [{ token: i3.ApplicationService }, { token: EcosystemService }, { token: i2.AlertService }, { token: i4.Router }, { token: i2.WizardModalService }, { token: i2.AlertService }, { token: i2.PluginsService }, { token: i2.GainsightService }], target: i0.ɵɵFactoryTarget.Component });
ApplicationCardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ApplicationCardComponent, selector: "c8y-application-card", inputs: { app: "app", canEdit: "canEdit" }, outputs: { onAppDeleted: "onAppDeleted", onAppCloned: "onAppCloned" }, ngImport: i0, template: "<div class=\"card pointer card--d-col notFeature\" *ngIf=\"!isFeature\">\n  <div (click)=\"detail()\" class=\"card-block text-center card-column-40\">\n    <button\n      type=\"button\"\n      *ngIf=\"packageType !== PACKAGE_TYPE.CUSTOM\"\n      class=\"card__ribbon btn-clean\"\n      [attr.aria-label]=\"\n        (app.label | translatePackageLabel) +\n        ': ' +\n        (packageTypeLabels[packageType].tooltip | translate)\n      \"\n      tooltip=\"{{ packageTypeLabels[packageType].tooltip | translate }}\"\n      placement=\"right\"\n      [delay]=\"500\"\n    >\n      <span\n        [ngClass]=\"{\n          'bg-info': packageType === PACKAGE_TYPE.COMMUNITY,\n          'bg-primary': packageType === PACKAGE_TYPE.OFFICIAL\n        }\"\n      >\n        {{ app.label | translatePackageLabel }}\n      </span>\n    </button>\n    <div class=\"card-appicon\">\n      <c8y-app-icon\n        *ngIf=\"!isPackage && !isFeature && !isMicroservice && !isExternal\"\n        [app]=\"app\"\n        [contextPath]=\"app.contextPath\"\n        [name]=\"app.name\"\n      ></c8y-app-icon>\n      <i *ngIf=\"isPackage\" c8yIcon=\"big-parcel\"></i>\n      <i *ngIf=\"isMicroservice\" c8yIcon=\"microchip\"></i>\n      <i *ngIf=\"isExternal\" c8yIcon=\"globe1\"></i>\n    </div>\n    <div style=\"line-height: 1.3\">\n      <p class=\"e2e-appCardName text-medium\" title=\"{{ app | humanizeAppName | async }}\">\n        {{ app | humanizeAppName | async }}\n      </p>\n      <ng-container *ngIf=\"isShowVersion\">\n        <p class=\"small text-muted\">\n          <em>{{ app.manifest.version }}</em>\n          <button\n            class=\"btn-clean m-l-4\"\n            *ngIf=\"shouldUpgradePackage && isUnpacked\"\n            [attr.aria-label]=\"'Update available' | translate\"\n            [tooltip]=\"'Update available' | translate\"\n          >\n            <i c8yIcon=\"exclamation-triangle\" class=\"text-warning icon-16\"></i>\n          </button>\n        </p>\n      </ng-container>\n      <p *ngIf=\"app.manifest?.author\" class=\"small\">{{ app.manifest.author }}</p>\n    </div>\n  </div>\n  <div (click)=\"detail()\" class=\"card-block p-0 no-min-height card--d-col card-column-80 flex-grow\">\n    <div class=\"card-block no-min-height p-t-0 p-b-0 card-column-80\">\n      <div class=\"text-center-grid\">\n        <div class=\"p-b-8 card-hidden-grid\"></div>\n        <p\n          class=\"small l-h-tight p-b-8 p-l-0 p-r-0\"\n          *ngIf=\"app.description || app.manifest?.description\"\n        >\n          {{ app.description || app.manifest?.description | translate }}\n        </p>\n        <p\n          class=\"small l-h-tight p-b-8 p-l-0 p-r-0\"\n          *ngIf=\"!app.description && !app.manifest?.description\"\n        >\n          <em class=\"text-muted\">{{ 'No description available.' | translate }}</em>\n        </p>\n      </div>\n    </div>\n    <div class=\"card-block no-min-height p-t-0 p-b-0 d-flex card-column-20 text-center-grid flex-wrap gap-8\">\n      <button\n        class=\"btn-clean\"\n        [tooltip]=\"appState?.tooltip | translate\"\n        [attr.aria-label]=\"\n          ((isUnpacked ? UNPACKED_LABEL : appState?.label) | translate) +\n          ': ' +\n          (appState?.tooltip | translate)\n        \"\n        placement=\"top\"\n        [delay]=\"500\"\n      >\n        <span [ngClass]=\"appState?.class\" class=\"label\">\n          {{ appState?.label | translate }}\n        </span>\n      </button>\n      <button\n        *ngIf=\"isPackage\"\n        class=\"btn-clean\"\n        [attr.aria-label]=\"\n          (packageContentState?.label | translate) +\n            ': ' +\n            (packageContentState?.tooltip\n              ? packageContentState?.tooltip\n              : PACKAGE_CONTENT_UNDETERMINED_LABEL) | translate\n        \"\n        [tooltip]=\"\n          (packageContentState?.tooltip\n            ? packageContentState?.tooltip\n            : PACKAGE_CONTENT_UNDETERMINED_LABEL\n          ) | translate\n        \"\n        placement=\"top\"\n      >\n        <span\n          [ngClass]=\"packageContentState?.class ? packageContentState?.class : 'label-danger'\"\n          class=\"label\"\n        >\n          {{\n            packageContentState?.label || packageTypeLabels[PACKAGE_TYPE.UNKNOWN].label | translate\n          }}\n        </span>\n      </button>\n    </div>\n    <div class=\"card-footer no-min-height p-t-0 p-b-0 card-column-20 text-center-grid\">\n      <div class=\"p-b-16 card-hidden-list\"></div>\n      <button\n        class=\"btn btn-sm btn-default\"\n        type=\"button\"\n        [title]=\"openButtonTitle | translate\"\n        (click)=\"openApp(); $event.stopPropagation()\"\n        *ngIf=\"canOpenInBrowser\"\n        [disabled]=\"disableOpenInBrowser\"\n      >\n        <i c8yIcon=\"external-link\" class=\"m-r-4\"></i>\n        {{ 'Open' | translate }}\n      </button>\n      <div class=\"p-b-32 card-hidden-list\"></div>\n    </div>\n  </div>\n  <div class=\"p-r-40 card-hidden-grid\"></div>\n  <div *ngIf=\"canEdit || canOpenInBrowser || canDelete\" class=\"card-actions m-t-0\">\n    <div\n      class=\"dropdown\"\n      #appCardDropdown=\"bs-dropdown\"\n      dropdown\n      [cdkTrapFocus]=\"appCardDropdown.isOpen\"\n    >\n      <button\n        class=\"dropdown-toggle c8y-dropdown\"\n        type=\"button\"\n        title=\"{{ 'Settings' | translate }}\"\n        dropdownToggle\n      >\n        <i c8yIcon=\"ellipsis-v\"></i>\n      </button>\n      <ul *dropdownMenu class=\"dropdown-menu dropdown-menu-right\">\n        <li *ngIf=\"canEdit\">\n          <button (click)=\"detail()\" title=\"{{ 'Edit' | translate }}\">\n            <i c8yIcon=\"pencil\" class=\"m-r-4\"></i>\n            {{ 'Edit' | translate }}\n          </button>\n        </li>\n        <ng-container *c8yIfAllowed=\"['ROLE_APPLICATION_MANAGEMENT_ADMIN']\">\n          <li>\n            <button\n              type=\"button\"\n              [title]=\"canDelete ? ('Delete' | translate) : (CANNOT_DELETE_HINT | translate)\"\n              [disabled]=\"!canDelete\"\n              (click)=\"delete()\"\n            >\n              <i c8yIcon=\"delete\" class=\"m-r-4\"></i>\n              {{ 'Delete' | translate }}\n            </button>\n          </li>\n          <li *ngIf=\"canClone\">\n            <button\n              type=\"button\"\n              [title]=\"'Clone`package,verb`' | translate\"\n              *ngIf=\"isPackage\"\n              (click)=\"clone()\"\n            >\n              <i c8yIcon=\"copy\" class=\"m-r-4\"></i>\n              {{ 'Clone`package,verb`' | translate }}\n            </button>\n            <button\n              type=\"button\"\n              [title]=\"'Clone`application,verb`' | translate\"\n              *ngIf=\"!isPackage\"\n              (click)=\"clone()\"\n            >\n              <i c8yIcon=\"copy\" class=\"m-r-4\"></i>\n              {{ 'Clone`application,verb`' | translate }}\n            </button>\n          </li>\n        </ng-container>\n      </ul>\n    </div>\n  </div>\n</div>\n\n<button class=\"card pointer card--d-col\" type=\"button\" (click)=\"detail()\" *ngIf=\"isFeature\">\n  <div class=\"card-block text-center card-column-40\">\n    <div class=\"card-appicon\">\n      <c8y-app-icon\n        *ngIf=\"!isPackage && !isFeature && !isMicroservice && !isExternal\"\n        [app]=\"app\"\n        [contextPath]=\"app.contextPath\"\n        [name]=\"app.name\"\n      ></c8y-app-icon>\n      <i c8yIcon=\"tab\"></i>\n    </div>\n    <div>\n      <p class=\"e2e-appCardName text-medium\" title=\"{{ app | humanizeAppName | async }}\">\n        {{ app | humanizeAppName | async }}\n      </p>\n      <ng-container *ngIf=\"isShowVersion\">\n        <p class=\"small text-muted\">\n          <em>{{ app.manifest.version }}</em>\n          <i\n            *ngIf=\"shouldUpgradePackage && isUnpacked\"\n            [tooltip]=\"'Update available' | translate\"\n            c8yIcon=\"exclamation-triangle\"\n            class=\"text-warning m-l-4\"\n          ></i>\n        </p>\n      </ng-container>\n    </div>\n  </div>\n  <div class=\"card-block p-0 no-min-height card--d-col card-column-80 flex-grow\">\n    <div class=\"card-block no-min-height p-t-0 p-b-0 card-column-80\">\n      <div *ngIf=\"app.description || app.manifest?.description\" class=\"text-center-grid\">\n        <div class=\"p-b-8 card-hidden-grid\"></div>\n        <p class=\"small l-h-tight p-b-8 p-l-0 p-r-0\">\n          {{ app.description || app.manifest?.description | translate }}\n        </p>\n      </div>\n    </div>\n    <div class=\"card-block no-min-height p-t-0 p-b-0 card-column-20 text-center-grid\">\n      <span [ngClass]=\"appState.class\" class=\"label\">\n        {{ appState.label | translate }}\n      </span>\n    </div>\n    <div\n      *ngIf=\"isPackage\"\n      class=\"card-block no-min-height p-t-0 p-b-0 card-column-20 text-center-grid\"\n    >\n      <span [ngClass]=\"packageContentState.class\" class=\"label\">\n        {{ packageContentState.label | translate }}\n      </span>\n    </div>\n    <div class=\"p-b-32 card-hidden-list\"></div>\n  </div>\n</button>\n", dependencies: [{ kind: "component", type: i2.AppIconComponent, selector: "c8y-app-icon", inputs: ["contextPath", "name", "app"] }, { kind: "directive", type: i2.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i3$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.IfAllowedDirective, selector: "[c8yIfAllowed]", inputs: ["c8yIfAllowed", "c8yIfAllowedAllowAny"] }, { kind: "directive", type: i6.BsDropdownMenuDirective, selector: "[bsDropdownMenu],[dropdownMenu]", exportAs: ["bs-dropdown-menu"] }, { kind: "directive", type: i6.BsDropdownToggleDirective, selector: "[bsDropdownToggle],[dropdownToggle]", exportAs: ["bs-dropdown-toggle"] }, { kind: "directive", type: i6.BsDropdownDirective, selector: "[bsDropdown], [dropdown]", inputs: ["placement", "triggers", "container", "dropup", "autoClose", "isAnimated", "insideClick", "isDisabled", "isOpen"], outputs: ["isOpenChange", "onShown", "onHidden"], exportAs: ["bs-dropdown"] }, { kind: "directive", type: i7.TooltipDirective, selector: "[tooltip], [tooltipHtml]", inputs: ["adaptivePosition", "tooltip", "placement", "triggers", "container", "containerClass", "boundariesElement", "isOpen", "isDisabled", "delay", "tooltipHtml", "tooltipPlacement", "tooltipIsOpen", "tooltipEnable", "tooltipAppendToBody", "tooltipAnimation", "tooltipClass", "tooltipContext", "tooltipPopupDelay", "tooltipFadeDuration", "tooltipTrigger"], outputs: ["tooltipChange", "onShown", "onHidden", "tooltipStateChanged"], exportAs: ["bs-tooltip"] }, { kind: "directive", type: i8.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3$1.AsyncPipe, name: "async" }, { kind: "pipe", type: i2.HumanizeAppNamePipe, name: "humanizeAppName" }, { kind: "pipe", type: TranslatePackageLabelPipe, name: "translatePackageLabel" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ApplicationCardComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-application-card', template: "<div class=\"card pointer card--d-col notFeature\" *ngIf=\"!isFeature\">\n  <div (click)=\"detail()\" class=\"card-block text-center card-column-40\">\n    <button\n      type=\"button\"\n      *ngIf=\"packageType !== PACKAGE_TYPE.CUSTOM\"\n      class=\"card__ribbon btn-clean\"\n      [attr.aria-label]=\"\n        (app.label | translatePackageLabel) +\n        ': ' +\n        (packageTypeLabels[packageType].tooltip | translate)\n      \"\n      tooltip=\"{{ packageTypeLabels[packageType].tooltip | translate }}\"\n      placement=\"right\"\n      [delay]=\"500\"\n    >\n      <span\n        [ngClass]=\"{\n          'bg-info': packageType === PACKAGE_TYPE.COMMUNITY,\n          'bg-primary': packageType === PACKAGE_TYPE.OFFICIAL\n        }\"\n      >\n        {{ app.label | translatePackageLabel }}\n      </span>\n    </button>\n    <div class=\"card-appicon\">\n      <c8y-app-icon\n        *ngIf=\"!isPackage && !isFeature && !isMicroservice && !isExternal\"\n        [app]=\"app\"\n        [contextPath]=\"app.contextPath\"\n        [name]=\"app.name\"\n      ></c8y-app-icon>\n      <i *ngIf=\"isPackage\" c8yIcon=\"big-parcel\"></i>\n      <i *ngIf=\"isMicroservice\" c8yIcon=\"microchip\"></i>\n      <i *ngIf=\"isExternal\" c8yIcon=\"globe1\"></i>\n    </div>\n    <div style=\"line-height: 1.3\">\n      <p class=\"e2e-appCardName text-medium\" title=\"{{ app | humanizeAppName | async }}\">\n        {{ app | humanizeAppName | async }}\n      </p>\n      <ng-container *ngIf=\"isShowVersion\">\n        <p class=\"small text-muted\">\n          <em>{{ app.manifest.version }}</em>\n          <button\n            class=\"btn-clean m-l-4\"\n            *ngIf=\"shouldUpgradePackage && isUnpacked\"\n            [attr.aria-label]=\"'Update available' | translate\"\n            [tooltip]=\"'Update available' | translate\"\n          >\n            <i c8yIcon=\"exclamation-triangle\" class=\"text-warning icon-16\"></i>\n          </button>\n        </p>\n      </ng-container>\n      <p *ngIf=\"app.manifest?.author\" class=\"small\">{{ app.manifest.author }}</p>\n    </div>\n  </div>\n  <div (click)=\"detail()\" class=\"card-block p-0 no-min-height card--d-col card-column-80 flex-grow\">\n    <div class=\"card-block no-min-height p-t-0 p-b-0 card-column-80\">\n      <div class=\"text-center-grid\">\n        <div class=\"p-b-8 card-hidden-grid\"></div>\n        <p\n          class=\"small l-h-tight p-b-8 p-l-0 p-r-0\"\n          *ngIf=\"app.description || app.manifest?.description\"\n        >\n          {{ app.description || app.manifest?.description | translate }}\n        </p>\n        <p\n          class=\"small l-h-tight p-b-8 p-l-0 p-r-0\"\n          *ngIf=\"!app.description && !app.manifest?.description\"\n        >\n          <em class=\"text-muted\">{{ 'No description available.' | translate }}</em>\n        </p>\n      </div>\n    </div>\n    <div class=\"card-block no-min-height p-t-0 p-b-0 d-flex card-column-20 text-center-grid flex-wrap gap-8\">\n      <button\n        class=\"btn-clean\"\n        [tooltip]=\"appState?.tooltip | translate\"\n        [attr.aria-label]=\"\n          ((isUnpacked ? UNPACKED_LABEL : appState?.label) | translate) +\n          ': ' +\n          (appState?.tooltip | translate)\n        \"\n        placement=\"top\"\n        [delay]=\"500\"\n      >\n        <span [ngClass]=\"appState?.class\" class=\"label\">\n          {{ appState?.label | translate }}\n        </span>\n      </button>\n      <button\n        *ngIf=\"isPackage\"\n        class=\"btn-clean\"\n        [attr.aria-label]=\"\n          (packageContentState?.label | translate) +\n            ': ' +\n            (packageContentState?.tooltip\n              ? packageContentState?.tooltip\n              : PACKAGE_CONTENT_UNDETERMINED_LABEL) | translate\n        \"\n        [tooltip]=\"\n          (packageContentState?.tooltip\n            ? packageContentState?.tooltip\n            : PACKAGE_CONTENT_UNDETERMINED_LABEL\n          ) | translate\n        \"\n        placement=\"top\"\n      >\n        <span\n          [ngClass]=\"packageContentState?.class ? packageContentState?.class : 'label-danger'\"\n          class=\"label\"\n        >\n          {{\n            packageContentState?.label || packageTypeLabels[PACKAGE_TYPE.UNKNOWN].label | translate\n          }}\n        </span>\n      </button>\n    </div>\n    <div class=\"card-footer no-min-height p-t-0 p-b-0 card-column-20 text-center-grid\">\n      <div class=\"p-b-16 card-hidden-list\"></div>\n      <button\n        class=\"btn btn-sm btn-default\"\n        type=\"button\"\n        [title]=\"openButtonTitle | translate\"\n        (click)=\"openApp(); $event.stopPropagation()\"\n        *ngIf=\"canOpenInBrowser\"\n        [disabled]=\"disableOpenInBrowser\"\n      >\n        <i c8yIcon=\"external-link\" class=\"m-r-4\"></i>\n        {{ 'Open' | translate }}\n      </button>\n      <div class=\"p-b-32 card-hidden-list\"></div>\n    </div>\n  </div>\n  <div class=\"p-r-40 card-hidden-grid\"></div>\n  <div *ngIf=\"canEdit || canOpenInBrowser || canDelete\" class=\"card-actions m-t-0\">\n    <div\n      class=\"dropdown\"\n      #appCardDropdown=\"bs-dropdown\"\n      dropdown\n      [cdkTrapFocus]=\"appCardDropdown.isOpen\"\n    >\n      <button\n        class=\"dropdown-toggle c8y-dropdown\"\n        type=\"button\"\n        title=\"{{ 'Settings' | translate }}\"\n        dropdownToggle\n      >\n        <i c8yIcon=\"ellipsis-v\"></i>\n      </button>\n      <ul *dropdownMenu class=\"dropdown-menu dropdown-menu-right\">\n        <li *ngIf=\"canEdit\">\n          <button (click)=\"detail()\" title=\"{{ 'Edit' | translate }}\">\n            <i c8yIcon=\"pencil\" class=\"m-r-4\"></i>\n            {{ 'Edit' | translate }}\n          </button>\n        </li>\n        <ng-container *c8yIfAllowed=\"['ROLE_APPLICATION_MANAGEMENT_ADMIN']\">\n          <li>\n            <button\n              type=\"button\"\n              [title]=\"canDelete ? ('Delete' | translate) : (CANNOT_DELETE_HINT | translate)\"\n              [disabled]=\"!canDelete\"\n              (click)=\"delete()\"\n            >\n              <i c8yIcon=\"delete\" class=\"m-r-4\"></i>\n              {{ 'Delete' | translate }}\n            </button>\n          </li>\n          <li *ngIf=\"canClone\">\n            <button\n              type=\"button\"\n              [title]=\"'Clone`package,verb`' | translate\"\n              *ngIf=\"isPackage\"\n              (click)=\"clone()\"\n            >\n              <i c8yIcon=\"copy\" class=\"m-r-4\"></i>\n              {{ 'Clone`package,verb`' | translate }}\n            </button>\n            <button\n              type=\"button\"\n              [title]=\"'Clone`application,verb`' | translate\"\n              *ngIf=\"!isPackage\"\n              (click)=\"clone()\"\n            >\n              <i c8yIcon=\"copy\" class=\"m-r-4\"></i>\n              {{ 'Clone`application,verb`' | translate }}\n            </button>\n          </li>\n        </ng-container>\n      </ul>\n    </div>\n  </div>\n</div>\n\n<button class=\"card pointer card--d-col\" type=\"button\" (click)=\"detail()\" *ngIf=\"isFeature\">\n  <div class=\"card-block text-center card-column-40\">\n    <div class=\"card-appicon\">\n      <c8y-app-icon\n        *ngIf=\"!isPackage && !isFeature && !isMicroservice && !isExternal\"\n        [app]=\"app\"\n        [contextPath]=\"app.contextPath\"\n        [name]=\"app.name\"\n      ></c8y-app-icon>\n      <i c8yIcon=\"tab\"></i>\n    </div>\n    <div>\n      <p class=\"e2e-appCardName text-medium\" title=\"{{ app | humanizeAppName | async }}\">\n        {{ app | humanizeAppName | async }}\n      </p>\n      <ng-container *ngIf=\"isShowVersion\">\n        <p class=\"small text-muted\">\n          <em>{{ app.manifest.version }}</em>\n          <i\n            *ngIf=\"shouldUpgradePackage && isUnpacked\"\n            [tooltip]=\"'Update available' | translate\"\n            c8yIcon=\"exclamation-triangle\"\n            class=\"text-warning m-l-4\"\n          ></i>\n        </p>\n      </ng-container>\n    </div>\n  </div>\n  <div class=\"card-block p-0 no-min-height card--d-col card-column-80 flex-grow\">\n    <div class=\"card-block no-min-height p-t-0 p-b-0 card-column-80\">\n      <div *ngIf=\"app.description || app.manifest?.description\" class=\"text-center-grid\">\n        <div class=\"p-b-8 card-hidden-grid\"></div>\n        <p class=\"small l-h-tight p-b-8 p-l-0 p-r-0\">\n          {{ app.description || app.manifest?.description | translate }}\n        </p>\n      </div>\n    </div>\n    <div class=\"card-block no-min-height p-t-0 p-b-0 card-column-20 text-center-grid\">\n      <span [ngClass]=\"appState.class\" class=\"label\">\n        {{ appState.label | translate }}\n      </span>\n    </div>\n    <div\n      *ngIf=\"isPackage\"\n      class=\"card-block no-min-height p-t-0 p-b-0 card-column-20 text-center-grid\"\n    >\n      <span [ngClass]=\"packageContentState.class\" class=\"label\">\n        {{ packageContentState.label | translate }}\n      </span>\n    </div>\n    <div class=\"p-b-32 card-hidden-list\"></div>\n  </div>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: i3.ApplicationService }, { type: EcosystemService }, { type: i2.AlertService }, { type: i4.Router }, { type: i2.WizardModalService }, { type: i2.AlertService }, { type: i2.PluginsService }, { type: i2.GainsightService }]; }, propDecorators: { app: [{
                type: Input
            }], canEdit: [{
                type: Input
            }], onAppDeleted: [{
                type: Output
            }], onAppCloned: [{
                type: Output
            }] } });

class ApplicationPropertiesFormComponent {
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.disabled = false;
        this.initForm();
    }
    ngOnChanges(changes) {
        if (changes.application &&
            changes.application.currentValue !== changes.application.previousValue) {
            this.setForm(this.application);
        }
        if (changes.disabled && changes.disabled.currentValue !== changes.disabled.previousValue) {
            changes.disabled.currentValue ? this.formGroup.disable() : this.formGroup.enable();
        }
    }
    initForm() {
        this.formGroup = this.formBuilder.group({
            name: [Validators.required, Validators.maxLength(120)],
            key: [Validators.required, Validators.maxLength(120)],
            contextPath: [Validators.required, Validators.maxLength(120)]
        });
    }
    setForm(applicationConfig) {
        this.formGroup.patchValue(Object.assign({}, applicationConfig));
    }
}
ApplicationPropertiesFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ApplicationPropertiesFormComponent, deps: [{ token: i1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component });
ApplicationPropertiesFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ApplicationPropertiesFormComponent, selector: "c8y-application-properties-form", inputs: { application: "application", disabled: "disabled" }, usesOnChanges: true, ngImport: i0, template: "<form\n  (ngSubmit)=\"(formGroup.valid)\"\n  [formGroup]=\"formGroup\"\n  class=\"c8y-wizard-form text-left\"\n  name=\"appDeployForm\"\n  novalidate\n>\n  <c8y-form-group>\n    <label for=\"name\" translate>Name</label>\n    <input\n      class=\"form-control\"\n      formControlName=\"name\"\n      name=\"name\"\n      placeholder=\"{{ 'e.g. My application' | translate }}\"\n      required\n      type=\"text\"\n    />\n  </c8y-form-group>\n  <c8y-form-group>\n    <label for=\"key\" translate>Application key</label>\n    <input\n      class=\"form-control\"\n      formControlName=\"key\"\n      name=\"key\"\n      placeholder=\"{{ 'e.g. my-application-key' | translate }}\"\n      required\n      type=\"text\"\n    />\n  </c8y-form-group>\n  <c8y-form-group>\n    <label for=\"contextPath\" translate>Path</label>\n    <div class=\"input-group\">\n      <span class=\"input-group-addon\">/apps/</span>\n      <input\n        class=\"form-control\"\n        formControlName=\"contextPath\"\n        name=\"contextPath\"\n        placeholder=\"{{ 'e.g. my-application' | translate }}\"\n        required\n        type=\"text\"\n      />\n    </div>\n  </c8y-form-group>\n</form>\n", dependencies: [{ kind: "directive", type: i2.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "component", type: i2.FormGroupComponent, selector: "c8y-form-group", inputs: ["hasError", "hasWarning", "hasSuccess", "novalidation", "status"] }, { kind: "directive", type: i2.RequiredInputPlaceholderDirective, selector: "input[required], input[formControlName]" }, { kind: "directive", type: i1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ApplicationPropertiesFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-application-properties-form', template: "<form\n  (ngSubmit)=\"(formGroup.valid)\"\n  [formGroup]=\"formGroup\"\n  class=\"c8y-wizard-form text-left\"\n  name=\"appDeployForm\"\n  novalidate\n>\n  <c8y-form-group>\n    <label for=\"name\" translate>Name</label>\n    <input\n      class=\"form-control\"\n      formControlName=\"name\"\n      name=\"name\"\n      placeholder=\"{{ 'e.g. My application' | translate }}\"\n      required\n      type=\"text\"\n    />\n  </c8y-form-group>\n  <c8y-form-group>\n    <label for=\"key\" translate>Application key</label>\n    <input\n      class=\"form-control\"\n      formControlName=\"key\"\n      name=\"key\"\n      placeholder=\"{{ 'e.g. my-application-key' | translate }}\"\n      required\n      type=\"text\"\n    />\n  </c8y-form-group>\n  <c8y-form-group>\n    <label for=\"contextPath\" translate>Path</label>\n    <div class=\"input-group\">\n      <span class=\"input-group-addon\">/apps/</span>\n      <input\n        class=\"form-control\"\n        formControlName=\"contextPath\"\n        name=\"contextPath\"\n        placeholder=\"{{ 'e.g. my-application' | translate }}\"\n        required\n        type=\"text\"\n      />\n    </div>\n  </c8y-form-group>\n</form>\n" }]
        }], ctorParameters: function () { return [{ type: i1.FormBuilder }]; }, propDecorators: { application: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });

class DuplicateApplicationListComponent {
    constructor(ecosystemService, wizardComponent) {
        this.ecosystemService = ecosystemService;
        this.wizardComponent = wizardComponent;
        this.onSelectedApp = new EventEmitter();
    }
    select(selectedApp) {
        this.onSelectedApp.emit(selectedApp);
        this.stepper.next();
    }
    cancel() {
        this.wizardComponent.close();
    }
    back() {
        this.wizardComponent.reset();
    }
}
DuplicateApplicationListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DuplicateApplicationListComponent, deps: [{ token: EcosystemService }, { token: i2.WizardComponent }], target: i0.ɵɵFactoryTarget.Component });
DuplicateApplicationListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: DuplicateApplicationListComponent, selector: "c8y-duplicate-application-list", inputs: { stepper: "stepper", existingApps: "existingApps" }, outputs: { onSelectedApp: "onSelectedApp" }, ngImport: i0, template: "<div class=\"c8y-wizard-list-nav\">\n  <button\n    (click)=\"select(app)\"\n    *ngFor=\"let app of existingApps\"\n    class=\"list-group-item text-truncate p-t-8 p-b-8 bg-level-0\"\n    type=\"button\"\n  >\n    <c8y-app-icon\n      [app]=\"app\"\n      [contextPath]=\"app.contextPath\"\n      [name]=\"app.name\"\n      class=\"list-group-icon\"\n    ></c8y-app-icon>\n    <span [innerText]=\"app | humanizeAppName | async\" class=\"pointer\"></span>\n    <span [ngClass]=\"ecosystemService.getAppState(app).class\" class=\"label m-l-16\">\n      {{ ecosystemService.getAppState(app).label | translate }}\n    </span>\n  </button>\n</div>\n<c8y-wizard-footer>\n  <button (click)=\"back()\" class=\"btn btn-default\" title=\"{{ 'Back' | translate }}\" type=\"button\">\n    {{ 'Back' | translate }}\n  </button>\n  <button\n    (click)=\"cancel()\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Cancel' | translate }}\"\n    type=\"button\"\n  >\n    {{ 'Cancel' | translate }}\n  </button>\n</c8y-wizard-footer>\n", dependencies: [{ kind: "component", type: i2.AppIconComponent, selector: "c8y-app-icon", inputs: ["contextPath", "name", "app"] }, { kind: "directive", type: i3$1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i2.WizardFooterComponent, selector: "c8y-wizard-footer" }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3$1.AsyncPipe, name: "async" }, { kind: "pipe", type: i2.HumanizeAppNamePipe, name: "humanizeAppName" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DuplicateApplicationListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-duplicate-application-list', template: "<div class=\"c8y-wizard-list-nav\">\n  <button\n    (click)=\"select(app)\"\n    *ngFor=\"let app of existingApps\"\n    class=\"list-group-item text-truncate p-t-8 p-b-8 bg-level-0\"\n    type=\"button\"\n  >\n    <c8y-app-icon\n      [app]=\"app\"\n      [contextPath]=\"app.contextPath\"\n      [name]=\"app.name\"\n      class=\"list-group-icon\"\n    ></c8y-app-icon>\n    <span [innerText]=\"app | humanizeAppName | async\" class=\"pointer\"></span>\n    <span [ngClass]=\"ecosystemService.getAppState(app).class\" class=\"label m-l-16\">\n      {{ ecosystemService.getAppState(app).label | translate }}\n    </span>\n  </button>\n</div>\n<c8y-wizard-footer>\n  <button (click)=\"back()\" class=\"btn btn-default\" title=\"{{ 'Back' | translate }}\" type=\"button\">\n    {{ 'Back' | translate }}\n  </button>\n  <button\n    (click)=\"cancel()\"\n    class=\"btn btn-default\"\n    title=\"{{ 'Cancel' | translate }}\"\n    type=\"button\"\n  >\n    {{ 'Cancel' | translate }}\n  </button>\n</c8y-wizard-footer>\n" }]
        }], ctorParameters: function () { return [{ type: EcosystemService }, { type: i2.WizardComponent }]; }, propDecorators: { stepper: [{
                type: Input
            }], existingApps: [{
                type: Input
            }], onSelectedApp: [{
                type: Output
            }] } });

class DuplicateApplicationPropertiesComponent {
    constructor(bsModalRef, ecosystemService, applicationService, gainsightService) {
        this.bsModalRef = bsModalRef;
        this.ecosystemService = ecosystemService;
        this.applicationService = applicationService;
        this.gainsightService = gainsightService;
        this.CURRENT_LOCATION = location.href;
        this.isFirstStep = false;
        this.duplicatedApp = new EventEmitter();
        this.disableForm = false;
        this.inProgress = false;
    }
    ngOnInit() {
        this.isSubscribedApp$ = this.selectedApp.pipe(distinctUntilKeyChanged('id'), map(app => (app ? this.ecosystemService.getAppState(app) === APP_STATE.SUBSCRIBED : true)), tap(isSubscribed => {
            this.disableForm = isSubscribed;
            this.getAppConfig();
        }));
        this.getAppConfig();
    }
    duplicateApp() {
        return __awaiter(this, void 0, void 0, function* () {
            const formGroupValue = this.applicationPropertiesForm.formGroup.getRawValue();
            this.inProgress = true;
            let { data: clonedApp } = yield this.applicationService.clone(this.selectedApp.value);
            // TODO: remove once MTM-48474 has been merged
            clonedApp = this.ecosystemService.setAvailabilityToPrivateIfNotSetAlready(clonedApp);
            Object.assign(clonedApp, formGroupValue);
            delete clonedApp.type;
            yield this.updateApp(clonedApp);
            this.inProgress = false;
            this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.DUPLICATE_APPLICATION, {
                component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.DUPLICATE_APPLICATION_PROPERTIES,
                result: PRODUCT_EXPERIENCE.APPLICATIONS.RESULTS.DUPLICATED,
                url: this.CURRENT_LOCATION
            });
        });
    }
    cancel() {
        this.bsModalRef.hide();
        this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.DUPLICATE_APPLICATION, {
            component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.DUPLICATE_APPLICATION_PROPERTIES,
            action: PRODUCT_EXPERIENCE.APPLICATIONS.ACTIONS.CANCEL,
            url: this.CURRENT_LOCATION
        });
    }
    back() {
        this.stepper.previous();
    }
    getAppConfig() {
        if (this.disableForm) {
            const { name, key, contextPath } = this.selectedApp.value;
            this.newAppConfig = { name, key, contextPath };
        }
        else {
            this.newAppConfig = this.ecosystemService.getUniqueAppConfig(this.selectedApp.value, this.existingApps);
        }
    }
    updateApp(clonedAppConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { data: app } = yield this.ecosystemService.updateApp(clonedAppConfig, true);
                const manifest = yield this.getAppManifest(app);
                if (manifest) {
                    yield this.updateManifest(app, manifest);
                }
                this.duplicatedApp.emit(app);
                this.stepper.next();
            }
            catch (err) {
                this.inProgress = false;
            }
        });
    }
    updateManifest(app, manifest) {
        return __awaiter(this, void 0, void 0, function* () {
            const keysToUpdate = ['name', 'key', 'contextPath'];
            const someKeyDiffers = keysToUpdate.some(key => app[key] !== manifest[key]);
            if (someKeyDiffers) {
                keysToUpdate.forEach(key => {
                    manifest[key] = app[key];
                });
                yield this.applicationService.storeAppManifest(app, manifest);
            }
        });
    }
    getAppManifest(app) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(app === null || app === void 0 ? void 0 : app.contextPath)) {
                return;
            }
            try {
                const manifest = yield this.applicationService.getAppManifest(app);
                return manifest;
            }
            catch (ex) {
                return;
            }
        });
    }
}
DuplicateApplicationPropertiesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DuplicateApplicationPropertiesComponent, deps: [{ token: i1$1.BsModalRef }, { token: EcosystemService }, { token: i3.ApplicationService }, { token: i2.GainsightService }], target: i0.ɵɵFactoryTarget.Component });
DuplicateApplicationPropertiesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: DuplicateApplicationPropertiesComponent, selector: "c8y-duplicate-application-properties", inputs: { stepper: "stepper", existingApps: "existingApps", selectedApp: "selectedApp", isFirstStep: "isFirstStep" }, outputs: { duplicatedApp: "duplicatedApp" }, viewQueries: [{ propertyName: "applicationPropertiesForm", first: true, predicate: ApplicationPropertiesFormComponent, descendants: true }], ngImport: i0, template: "<p\n  class=\"p-16 text-center text-medium separator-bottom sticky-top bg-level-0 fit-w\"\n  *ngIf=\"!inProgress\"\n>\n  {{ 'Provide application details' | translate }}\n</p>\n\n<ng-container *ngIf=\"!inProgress\">\n  <label class=\"c8y-switch\" *ngIf=\"isSubscribedApp$ | async\">\n    <input type=\"checkbox\" [(ngModel)]=\"disableForm\" (change)=\"getAppConfig()\" />\n    <span></span> {{ 'Overrule subscribed application' | translate }}\n  </label>\n\n  <c8y-application-properties-form\n    [application]=\"newAppConfig\"\n    class=\"d-block fit-w\"\n    [disabled]=\"disableForm\"\n  ></c8y-application-properties-form>\n</ng-container>\n<c8y-progress-bar\n  *ngIf=\"inProgress\"\n  [message]=\"'Duplicating\u2026' | translate\"\n  class=\"text-center d-block\"\n></c8y-progress-bar>\n\n<c8y-wizard-footer>\n  <button\n    *ngIf=\"!isFirstStep\"\n    (click)=\"back()\"\n    [disabled]=\"inProgress\"\n    class=\"btn btn-default\"\n    type=\"button\"\n    title=\"{{ 'Back' | translate }}\"\n  >\n    {{ 'Back' | translate }}\n  </button>\n  <button (click)=\"cancel()\" class=\"btn btn-default\" title=\"{{ 'Cancel' | translate }}\">\n    {{ 'Cancel' | translate }}\n  </button>\n  <button\n    (click)=\"duplicateApp()\"\n    [disabled]=\"inProgress\"\n    class=\"btn btn-primary\"\n    type=\"button\"\n    title=\"{{ 'Duplicate' | translate }}\"\n  >\n    {{ 'Duplicate' | translate }}\n  </button>\n</c8y-wizard-footer>\n", dependencies: [{ kind: "directive", type: i3$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.ProgressBarComponent, selector: "c8y-progress-bar", inputs: ["message", "progress"] }, { kind: "directive", type: i1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2.WizardFooterComponent, selector: "c8y-wizard-footer" }, { kind: "component", type: ApplicationPropertiesFormComponent, selector: "c8y-application-properties-form", inputs: ["application", "disabled"] }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3$1.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DuplicateApplicationPropertiesComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-duplicate-application-properties', template: "<p\n  class=\"p-16 text-center text-medium separator-bottom sticky-top bg-level-0 fit-w\"\n  *ngIf=\"!inProgress\"\n>\n  {{ 'Provide application details' | translate }}\n</p>\n\n<ng-container *ngIf=\"!inProgress\">\n  <label class=\"c8y-switch\" *ngIf=\"isSubscribedApp$ | async\">\n    <input type=\"checkbox\" [(ngModel)]=\"disableForm\" (change)=\"getAppConfig()\" />\n    <span></span> {{ 'Overrule subscribed application' | translate }}\n  </label>\n\n  <c8y-application-properties-form\n    [application]=\"newAppConfig\"\n    class=\"d-block fit-w\"\n    [disabled]=\"disableForm\"\n  ></c8y-application-properties-form>\n</ng-container>\n<c8y-progress-bar\n  *ngIf=\"inProgress\"\n  [message]=\"'Duplicating\u2026' | translate\"\n  class=\"text-center d-block\"\n></c8y-progress-bar>\n\n<c8y-wizard-footer>\n  <button\n    *ngIf=\"!isFirstStep\"\n    (click)=\"back()\"\n    [disabled]=\"inProgress\"\n    class=\"btn btn-default\"\n    type=\"button\"\n    title=\"{{ 'Back' | translate }}\"\n  >\n    {{ 'Back' | translate }}\n  </button>\n  <button (click)=\"cancel()\" class=\"btn btn-default\" title=\"{{ 'Cancel' | translate }}\">\n    {{ 'Cancel' | translate }}\n  </button>\n  <button\n    (click)=\"duplicateApp()\"\n    [disabled]=\"inProgress\"\n    class=\"btn btn-primary\"\n    type=\"button\"\n    title=\"{{ 'Duplicate' | translate }}\"\n  >\n    {{ 'Duplicate' | translate }}\n  </button>\n</c8y-wizard-footer>\n" }]
        }], ctorParameters: function () { return [{ type: i1$1.BsModalRef }, { type: EcosystemService }, { type: i3.ApplicationService }, { type: i2.GainsightService }]; }, propDecorators: { stepper: [{
                type: Input
            }], existingApps: [{
                type: Input
            }], selectedApp: [{
                type: Input
            }], isFirstStep: [{
                type: Input
            }], duplicatedApp: [{
                type: Output
            }], applicationPropertiesForm: [{
                type: ViewChild,
                args: [ApplicationPropertiesFormComponent]
            }] } });

class DuplicateApplicationComponent {
    constructor(ecosystemService, applicationService, wizardComponent) {
        this.ecosystemService = ecosystemService;
        this.applicationService = applicationService;
        this.wizardComponent = wizardComponent;
        this.selectedApp = new BehaviorSubject(null);
        this.existingApps = [];
        this.directlyMoveToSecondStep = false;
    }
    ngOnInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.existingApps = yield this.ecosystemService.getWebApplications();
            if (this.selectedApp.value) {
                this.directlyMoveToSecondStep = true;
            }
        });
    }
    onSelectedApp(app) {
        this.selectedApp.next(app);
    }
    getHref(app) {
        return this.applicationService.getHref(app);
    }
    done() {
        this.wizardComponent.close();
    }
}
DuplicateApplicationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DuplicateApplicationComponent, deps: [{ token: EcosystemService }, { token: i3.ApplicationService }, { token: i2.WizardComponent }], target: i0.ɵɵFactoryTarget.Component });
DuplicateApplicationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: DuplicateApplicationComponent, selector: "c8y-duplicate-application", viewQueries: [{ propertyName: "stepper", first: true, predicate: C8yStepper, descendants: true, static: true }], ngImport: i0, template: "<c8y-wizard-header>\n  <i [c8yIcon]=\"'copy'\"></i>\n  <h4 id=\"modal-title\" translate>Duplicate application</h4>\n</c8y-wizard-header>\n\n<c8y-wizard-body id=\"modal-body\">\n  <c8y-stepper\n    [customClasses]=\"['hidden']\"\n    [disableDefaultIcons]=\"{ edit: true, done: false }\"\n    linear\n  >\n    <!-- 1st step -->\n    <cdk-step *ngIf=\"!directlyMoveToSecondStep\">\n      <p class=\"p-16 text-center text-medium separator-bottom sticky-top bg-level-0\">\n        {{ 'Select application to duplicate' | translate }}\n      </p>\n      <c8y-duplicate-application-list\n        (onSelectedApp)=\"onSelectedApp($event)\"\n        *ngIf=\"stepper.selectedIndex === 0\"\n        [existingApps]=\"existingApps\"\n        [stepper]=\"stepper\"\n        class=\"d-block\"\n        style=\"min-height: 257px\"\n      ></c8y-duplicate-application-list>\n    </cdk-step>\n    <!-- 2nd step -->\n    <cdk-step>\n      <c8y-duplicate-application-properties\n        class=\"d-flex d-col j-c-center a-i-center\"\n        style=\"min-height: 257px\"\n        (duplicatedApp)=\"duplicatedApp = $event\"\n        *ngIf=\"\n          stepper.selectedIndex === 1 || (stepper.selectedIndex === 0 && directlyMoveToSecondStep)\n        \"\n        [existingApps]=\"existingApps\"\n        [selectedApp]=\"selectedApp\"\n        [stepper]=\"stepper\"\n        [isFirstStep]=\"directlyMoveToSecondStep\"\n      ></c8y-duplicate-application-properties>\n    </cdk-step>\n    <!-- Final step -->\n    <cdk-step>\n      <ng-container\n        *ngIf=\"\n          stepper.selectedIndex === 2 || (stepper.selectedIndex === 1 && directlyMoveToSecondStep)\n        \"\n      >\n        <div\n          *ngIf=\"duplicatedApp; else duplicateAppFailed\"\n          style=\"min-height: 257px\"\n          class=\"d-flex a-i-center j-c-center\"\n        >\n          <c8y-operation-result\n            text=\"{{ 'Application created' | translate }}\"\n            [size]=\"84\"\n            [vertical]=\"true\"\n            type=\"success\"\n          ></c8y-operation-result>\n        </div>\n        <ng-template #duplicateAppFailed>\n          <div style=\"min-height: 257px\" class=\"d-flex a-i-center j-c-center\">\n            <c8y-operation-result\n              text=\"{{ 'Application creation failed' | translate }}\"\n              [size]=\"84\"\n              [vertical]=\"true\"\n              type=\"error\"\n            ></c8y-operation-result>\n          </div>\n        </ng-template>\n      </ng-container>\n    </cdk-step>\n  </c8y-stepper>\n</c8y-wizard-body>\n\n<c8y-wizard-footer\n  *ngIf=\"stepper.selectedIndex === 2 || (stepper.selectedIndex === 1 && directlyMoveToSecondStep)\"\n>\n  <button (click)=\"done()\" class=\"btn btn-default\" title=\"{{ 'Done' | translate }}\" type=\"button\">\n    {{ 'Done' | translate }}\n  </button>\n  <a\n    (click)=\"$event.stopPropagation()\"\n    [href]=\"getHref(duplicatedApp)\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n    class=\"btn btn-primary\"\n    title=\"{{ 'Open' | translate }}\"\n  >\n    <i c8yIcon=\"external-link\" class=\"m-r-4\"></i>\n    {{ 'Open' | translate }}\n  </a>\n</c8y-wizard-footer>\n", dependencies: [{ kind: "directive", type: i2.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i2.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i3$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.OperationResultComponent, selector: "c8y-operation-result", inputs: ["text", "vertical", "size", "type"] }, { kind: "component", type: i2.C8yStepper, selector: "c8y-stepper", inputs: ["disableDefaultIcons", "disableProgressButtons", "customClasses", "hideStepProgress", "useStepLabelsAsTitlesOnly"], outputs: ["onStepChange"] }, { kind: "component", type: i5.CdkStep, selector: "cdk-step", inputs: ["stepControl", "label", "errorMessage", "aria-label", "aria-labelledby", "state", "editable", "optional", "completed", "hasError"], outputs: ["interacted"], exportAs: ["cdkStep"] }, { kind: "component", type: i2.WizardHeaderComponent, selector: "c8y-wizard-header" }, { kind: "component", type: i2.WizardBodyComponent, selector: "c8y-wizard-body" }, { kind: "component", type: i2.WizardFooterComponent, selector: "c8y-wizard-footer" }, { kind: "component", type: DuplicateApplicationListComponent, selector: "c8y-duplicate-application-list", inputs: ["stepper", "existingApps"], outputs: ["onSelectedApp"] }, { kind: "component", type: DuplicateApplicationPropertiesComponent, selector: "c8y-duplicate-application-properties", inputs: ["stepper", "existingApps", "selectedApp", "isFirstStep"], outputs: ["duplicatedApp"] }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DuplicateApplicationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-duplicate-application', template: "<c8y-wizard-header>\n  <i [c8yIcon]=\"'copy'\"></i>\n  <h4 id=\"modal-title\" translate>Duplicate application</h4>\n</c8y-wizard-header>\n\n<c8y-wizard-body id=\"modal-body\">\n  <c8y-stepper\n    [customClasses]=\"['hidden']\"\n    [disableDefaultIcons]=\"{ edit: true, done: false }\"\n    linear\n  >\n    <!-- 1st step -->\n    <cdk-step *ngIf=\"!directlyMoveToSecondStep\">\n      <p class=\"p-16 text-center text-medium separator-bottom sticky-top bg-level-0\">\n        {{ 'Select application to duplicate' | translate }}\n      </p>\n      <c8y-duplicate-application-list\n        (onSelectedApp)=\"onSelectedApp($event)\"\n        *ngIf=\"stepper.selectedIndex === 0\"\n        [existingApps]=\"existingApps\"\n        [stepper]=\"stepper\"\n        class=\"d-block\"\n        style=\"min-height: 257px\"\n      ></c8y-duplicate-application-list>\n    </cdk-step>\n    <!-- 2nd step -->\n    <cdk-step>\n      <c8y-duplicate-application-properties\n        class=\"d-flex d-col j-c-center a-i-center\"\n        style=\"min-height: 257px\"\n        (duplicatedApp)=\"duplicatedApp = $event\"\n        *ngIf=\"\n          stepper.selectedIndex === 1 || (stepper.selectedIndex === 0 && directlyMoveToSecondStep)\n        \"\n        [existingApps]=\"existingApps\"\n        [selectedApp]=\"selectedApp\"\n        [stepper]=\"stepper\"\n        [isFirstStep]=\"directlyMoveToSecondStep\"\n      ></c8y-duplicate-application-properties>\n    </cdk-step>\n    <!-- Final step -->\n    <cdk-step>\n      <ng-container\n        *ngIf=\"\n          stepper.selectedIndex === 2 || (stepper.selectedIndex === 1 && directlyMoveToSecondStep)\n        \"\n      >\n        <div\n          *ngIf=\"duplicatedApp; else duplicateAppFailed\"\n          style=\"min-height: 257px\"\n          class=\"d-flex a-i-center j-c-center\"\n        >\n          <c8y-operation-result\n            text=\"{{ 'Application created' | translate }}\"\n            [size]=\"84\"\n            [vertical]=\"true\"\n            type=\"success\"\n          ></c8y-operation-result>\n        </div>\n        <ng-template #duplicateAppFailed>\n          <div style=\"min-height: 257px\" class=\"d-flex a-i-center j-c-center\">\n            <c8y-operation-result\n              text=\"{{ 'Application creation failed' | translate }}\"\n              [size]=\"84\"\n              [vertical]=\"true\"\n              type=\"error\"\n            ></c8y-operation-result>\n          </div>\n        </ng-template>\n      </ng-container>\n    </cdk-step>\n  </c8y-stepper>\n</c8y-wizard-body>\n\n<c8y-wizard-footer\n  *ngIf=\"stepper.selectedIndex === 2 || (stepper.selectedIndex === 1 && directlyMoveToSecondStep)\"\n>\n  <button (click)=\"done()\" class=\"btn btn-default\" title=\"{{ 'Done' | translate }}\" type=\"button\">\n    {{ 'Done' | translate }}\n  </button>\n  <a\n    (click)=\"$event.stopPropagation()\"\n    [href]=\"getHref(duplicatedApp)\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n    class=\"btn btn-primary\"\n    title=\"{{ 'Open' | translate }}\"\n  >\n    <i c8yIcon=\"external-link\" class=\"m-r-4\"></i>\n    {{ 'Open' | translate }}\n  </a>\n</c8y-wizard-footer>\n" }]
        }], ctorParameters: function () { return [{ type: EcosystemService }, { type: i3.ApplicationService }, { type: i2.WizardComponent }]; }, propDecorators: { stepper: [{
                type: ViewChild,
                args: [C8yStepper, { static: true }]
            }] } });

class PackageVersionSelectComponent {
    constructor(applicationService, pluginsService) {
        this.applicationService = applicationService;
        this.pluginsService = pluginsService;
        this.label = gettext('Use plugin version');
        this.onInput$ = new BehaviorSubject('');
        this.isDisabled = false;
        this.packageContextPath$ = new BehaviorSubject('');
        this.packageId$ = new BehaviorSubject('');
        const packageIdFromContextPath$ = this.packageContextPath$.pipe(filter(path => !!path), switchMap(path => this.getPackageIdForContextPath(path)));
        const packageId$ = merge(packageIdFromContextPath$, this.packageId$.pipe(filter(id => !!id)));
        const packageVersions$ = packageId$.pipe(switchMap(id => this.getPackageVersions(id)), shareReplay(1));
        this.versions$ = combineLatest([packageVersions$, this.onInput$.asObservable()]).pipe(map(([resultList, filterStr]) => this.applyFilterToResultList(resultList, filterStr)));
    }
    writeValue(obj) {
        this.selectedVersion = obj;
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.isDisabled = isDisabled;
    }
    ngOnChanges(changes) {
        if (changes.packageContextPath) {
            this.packageContextPath$.next(this.packageContextPath);
        }
        if (changes.packageId) {
            this.packageId$.next(this.packageId);
        }
    }
    getPackageVersions(packageId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.applicationService.listVersions(packageId);
        });
    }
    onVersionSelect(version) {
        this.selectedVersion = version;
        if (this.onChange) {
            this.onChange(version);
        }
        if (this.onTouched) {
            this.onTouched();
        }
    }
    getPackageIdForContextPath(contextPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data: application } = yield this.applicationService.getManifestOfContextPath(contextPath);
            const packageAppId = application.id;
            return packageAppId;
        });
    }
    setInitialValueForInput(versions) {
        if (!this.selectedVersion && versions.length > 0) {
            const latest = versions.find(v => v.tags.includes('latest'));
            this.selectedVersion = latest || versions[0];
            if (this.onChange) {
                this.onChange(this.selectedVersion);
            }
        }
    }
    filterAppVersions(appVersions, filterStr) {
        return filterStr === ''
            ? appVersions
            : appVersions.filter(appVersion => {
                var _a;
                return appVersion.version.includes(filterStr) ||
                    ((_a = appVersion.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tag.includes(filterStr)));
            });
    }
    applyFilterToResultList(resultList, filterStr) {
        const versionsFilteredByStr = this.filterAppVersions(resultList.data, filterStr);
        const sortedAppVersions = this.pluginsService.sortVersions({
            list: versionsFilteredByStr,
            path: ['version']
        }, 'desc');
        this.setInitialValueForInput(sortedAppVersions);
        return { data: sortedAppVersions, res: resultList.res };
    }
}
PackageVersionSelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: PackageVersionSelectComponent, deps: [{ token: i3.ApplicationService }, { token: i2.PluginsService }], target: i0.ɵɵFactoryTarget.Component });
PackageVersionSelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: PackageVersionSelectComponent, selector: "c8y-package-version-select", inputs: { label: "label", packageContextPath: "packageContextPath", packageId: "packageId" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            multi: true,
            useExisting: forwardRef(() => PackageVersionSelectComponent)
        }
    ], usesOnChanges: true, ngImport: i0, template: "<label for=\"packageVersion\">{{ label | translate }}</label>\n<c8y-form-group>\n  <c8y-typeahead\n    [(ngModel)]=\"selectedVersion\"\n    name=\"packageVersion\"\n    (onSearch)=\"onInput$.next($event)\"\n    placeholder=\"{{ 'Select below or start typing' | translate }}\"\n    [displayProperty]=\"'version'\"\n    [required]=\"true\"\n    [disabled]=\"isDisabled\"\n    [hideNew]=\"true\"\n    [container]=\"'body'\"\n  >\n    <c8y-li\n      *c8yFor=\"let appVersion of versions$; loadMore: 'auto'; notFound: notFoundTemplate\"\n      (click)=\"onVersionSelect(appVersion)\"\n      class=\"p-l-8 p-r-8 c8y-list__item--link\"\n      [active]=\"selectedVersion === appVersion\"\n    >\n      <c8y-li-icon icon=\"big-parcel\"></c8y-li-icon>\n      <span\n        [ngStyle]=\"{\n          display: 'flex',\n          'flex-direction': 'row',\n          'align-content': 'center',\n          'justify-content': 'space-between',\n          'align-items': 'center'\n        }\"\n      >\n        <c8y-highlight\n          [text]=\"appVersion.version || '--'\"\n          [pattern]=\"onInput$ | async\"\n        ></c8y-highlight>\n        <span>\n          <span *ngFor=\"let tag of appVersion.tags\" class=\"label label-info m-l-4\">\n            {{ tag }}\n          </span>\n        </span>\n      </span>\n    </c8y-li>\n    <ng-template #notFoundTemplate>\n      <c8y-li\n        class=\"bg-gray-lighter p-8\"\n        *ngIf=\"(onInput$ | async)?.length > 0 && (versions$ | async)?.data?.length === 0\"\n      >\n        <span translate>No match found.</span>\n      </c8y-li>\n    </ng-template>\n  </c8y-typeahead>\n</c8y-form-group>\n", dependencies: [{ kind: "directive", type: i2.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i3$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2.ForOfDirective, selector: "[c8yFor]", inputs: ["c8yForOf", "c8yForLoadMore", "c8yForPipe", "c8yForNotFound", "c8yForMaxIterations", "c8yForLoadingTemplate", "c8yForLoadNextLabel", "c8yForRealtime", "c8yForRealtimeOptions", "c8yForComparator", "c8yForEnableVirtualScroll", "c8yForVirtualScrollElementSize", "c8yForVirtualScrollStrategy", "c8yForVirtualScrollContainerHeight"], outputs: ["c8yForCount"] }, { kind: "component", type: i2.HighlightComponent, selector: "c8y-highlight", inputs: ["pattern", "text", "elementClass", "shouldTrimPattern"] }, { kind: "component", type: i2.TypeaheadComponent, selector: "c8y-typeahead", inputs: ["required", "maxlength", "disabled", "allowFreeEntries", "placeholder", "displayProperty", "icon", "name", "autoClose", "hideNew", "container", "selected"], outputs: ["onSearch", "onIconClick"] }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { kind: "directive", type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2.FormGroupComponent, selector: "c8y-form-group", inputs: ["hasError", "hasWarning", "hasSuccess", "novalidation", "status"] }, { kind: "component", type: i2.ListItemComponent, selector: "c8y-list-item, c8y-li", inputs: ["active", "emptyActions", "collapsed", "selectable"], outputs: ["collapsedChange"] }, { kind: "component", type: i2.ListItemIconComponent, selector: "c8y-list-item-icon, c8y-li-icon", inputs: ["icon", "status"] }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3$1.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: PackageVersionSelectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-package-version-select', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            multi: true,
                            useExisting: forwardRef(() => PackageVersionSelectComponent)
                        }
                    ], template: "<label for=\"packageVersion\">{{ label | translate }}</label>\n<c8y-form-group>\n  <c8y-typeahead\n    [(ngModel)]=\"selectedVersion\"\n    name=\"packageVersion\"\n    (onSearch)=\"onInput$.next($event)\"\n    placeholder=\"{{ 'Select below or start typing' | translate }}\"\n    [displayProperty]=\"'version'\"\n    [required]=\"true\"\n    [disabled]=\"isDisabled\"\n    [hideNew]=\"true\"\n    [container]=\"'body'\"\n  >\n    <c8y-li\n      *c8yFor=\"let appVersion of versions$; loadMore: 'auto'; notFound: notFoundTemplate\"\n      (click)=\"onVersionSelect(appVersion)\"\n      class=\"p-l-8 p-r-8 c8y-list__item--link\"\n      [active]=\"selectedVersion === appVersion\"\n    >\n      <c8y-li-icon icon=\"big-parcel\"></c8y-li-icon>\n      <span\n        [ngStyle]=\"{\n          display: 'flex',\n          'flex-direction': 'row',\n          'align-content': 'center',\n          'justify-content': 'space-between',\n          'align-items': 'center'\n        }\"\n      >\n        <c8y-highlight\n          [text]=\"appVersion.version || '--'\"\n          [pattern]=\"onInput$ | async\"\n        ></c8y-highlight>\n        <span>\n          <span *ngFor=\"let tag of appVersion.tags\" class=\"label label-info m-l-4\">\n            {{ tag }}\n          </span>\n        </span>\n      </span>\n    </c8y-li>\n    <ng-template #notFoundTemplate>\n      <c8y-li\n        class=\"bg-gray-lighter p-8\"\n        *ngIf=\"(onInput$ | async)?.length > 0 && (versions$ | async)?.data?.length === 0\"\n      >\n        <span translate>No match found.</span>\n      </c8y-li>\n    </ng-template>\n  </c8y-typeahead>\n</c8y-form-group>\n" }]
        }], ctorParameters: function () { return [{ type: i3.ApplicationService }, { type: i2.PluginsService }]; }, propDecorators: { label: [{
                type: Input
            }], packageContextPath: [{
                type: Input
            }], packageId: [{
                type: Input
            }] } });

class UploadArchiveComponent {
    constructor(ecosystemService, alertService) {
        this.ecosystemService = ecosystemService;
        this.alertService = alertService;
        this.uploadNewVersion = false;
        this.applicationChange = new EventEmitter();
        this.refresh = new EventEmitter();
        this.archives = [];
        this.uploadInProgress = false;
        this.canReactivate = false;
    }
    get uploadProgress() {
        return this.ecosystemService.progress;
    }
    onFileDroppedEvent(event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.preUploadCallback) {
                try {
                    yield this.preUploadCallback();
                }
                catch (e) {
                    // do nothing, i.e. when confirm modal cancels and throws undefined
                    return;
                }
            }
            if (event && event.length > 0) {
                const file = event[0].file;
                this.onFile(file);
            }
        });
    }
    onFile(file) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.ecosystemService.validateArchiveToAppCompatibility(file, this.application);
                const isCustomMicroservice = this.ecosystemService.isCustomMicroservice(this.application);
                this.archives = isCustomMicroservice
                    ? []
                    : yield this.ecosystemService.listArchives(this.application.id);
                this.archives.sort((a, b) => {
                    return new Date(b.created) - new Date(a.created);
                });
                this.uploadInProgress = true;
                this.uploadProgress.next(0);
                if (this.archives.length === 6 && !isCustomMicroservice) {
                    yield this.ecosystemService.removeOldestArchive(this.application, this.archives);
                }
                const app = yield this.ecosystemService.uploadArchiveToApp(file, this.application, this.uploadNewVersion);
                this.applicationChange.emit(app);
                this.uploadProgress.next(100);
                this.uploadInProgress = false;
                this.refresh.emit();
                if (this.uploadNewVersion) {
                    return;
                }
                this.alertService.success(gettext('Archive uploaded and activated.'));
            }
            catch (ex) {
                this.uploadInProgress = false;
                this.ecosystemService.alertError(ex);
            }
        });
    }
}
UploadArchiveComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: UploadArchiveComponent, deps: [{ token: EcosystemService }, { token: i2.AlertService }], target: i0.ɵɵFactoryTarget.Component });
UploadArchiveComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: UploadArchiveComponent, selector: "c8y-upload-archive", inputs: { application: "application", uploadNewVersion: "uploadNewVersion", preUploadCallback: "preUploadCallback" }, outputs: { applicationChange: "applicationChange", refresh: "refresh" }, ngImport: i0, template: "<c8y-drop-area\n  (dropped)=\"onFileDroppedEvent($event)\"\n  [accept]=\"'.zip'\"\n  [loading]=\"uploadInProgress\"\n  [maxAllowedFiles]=\"1\"\n  [message]=\"'Upload a *.zip file' | translate\"\n  [progress]=\"uploadProgress | async\"\n  [forceHideList]=\"true\"\n  class=\"drop-area-sm\"\n>\n</c8y-drop-area>\n", dependencies: [{ kind: "component", type: i2.DropAreaComponent, selector: "c8y-drop-area", inputs: ["formControl", "title", "message", "icon", "loadingMessage", "forceHideList", "alwaysShow", "clickToOpen", "loading", "progress", "maxAllowedFiles", "files", "maxFileSizeInMegaBytes", "accept"], outputs: ["dropped"] }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3$1.AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: UploadArchiveComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-upload-archive', template: "<c8y-drop-area\n  (dropped)=\"onFileDroppedEvent($event)\"\n  [accept]=\"'.zip'\"\n  [loading]=\"uploadInProgress\"\n  [maxAllowedFiles]=\"1\"\n  [message]=\"'Upload a *.zip file' | translate\"\n  [progress]=\"uploadProgress | async\"\n  [forceHideList]=\"true\"\n  class=\"drop-area-sm\"\n>\n</c8y-drop-area>\n" }]
        }], ctorParameters: function () { return [{ type: EcosystemService }, { type: i2.AlertService }]; }, propDecorators: { application: [{
                type: Input
            }], uploadNewVersion: [{
                type: Input
            }], preUploadCallback: [{
                type: Input
            }], applicationChange: [{
                type: Output
            }], refresh: [{
                type: Output
            }] } });

class ListFiltersComponent {
    constructor(formBuilder, ui, translateService, gainsightService) {
        this.formBuilder = formBuilder;
        this.ui = ui;
        this.translateService = translateService;
        this.gainsightService = gainsightService;
        this.packageTypes = [];
        this.packageAvailabilities = [];
        this.packageContents = [];
        this.filterPipeChange = new EventEmitter();
        this.chips = [];
        this.CURRENT_LOCATION = location.href;
        this.formGroup = this.initForm();
    }
    ngOnInit() {
        var _a, _b, _c;
        this.currentFiltersState = this.formGroup.value;
        this.predefinedFiltersVisible =
            ((_a = this.packageTypes) === null || _a === void 0 ? void 0 : _a.length) > 0 ||
                ((_b = this.packageAvailabilities) === null || _b === void 0 ? void 0 : _b.length) > 0 ||
                ((_c = this.packageContents) === null || _c === void 0 ? void 0 : _c.length) > 0;
        this.currentLang = this.ui.state.lang;
    }
    setFilterTerm(filterTerm) {
        this.currentFilterTerm = filterTerm;
        this.setPipe();
        this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.FILTER_LIST, {
            component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.LIST_FILTERS,
            action: PRODUCT_EXPERIENCE.APPLICATIONS.ACTIONS.SET_FILTER_TERM,
            url: this.CURRENT_LOCATION
        });
    }
    applyPredefinedFilters() {
        this.currentFiltersState = this.formGroup.value;
        this.setChips();
        this.setPipe();
        this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.FILTER_LIST, {
            component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.LIST_FILTERS,
            action: PRODUCT_EXPERIENCE.APPLICATIONS.ACTIONS.SET_PREDEFINED_FILTERS,
            url: this.CURRENT_LOCATION,
            filters: this.currentFiltersState
        });
    }
    reset() {
        this.formGroup.reset();
        this.gainsightService.triggerEvent(PRODUCT_EXPERIENCE.APPLICATIONS.EVENTS.FILTER_LIST, {
            component: PRODUCT_EXPERIENCE.APPLICATIONS.COMPONENTS.LIST_FILTERS,
            action: PRODUCT_EXPERIENCE.APPLICATIONS.ACTIONS.RESET_FILTER,
            url: this.CURRENT_LOCATION
        });
        this.applyPredefinedFilters();
    }
    resetAllFilters() {
        this.reset();
        this.filterInput.reset();
    }
    toggleDropdown(isOpen) {
        if (!isOpen) {
            this.formGroup.patchValue(this.currentFiltersState);
        }
    }
    deselectChip(chip) {
        chip[1].setValue(false);
        this.applyPredefinedFilters();
    }
    initForm() {
        return this.formBuilder.group({
            type: this.formBuilder.group({
                [PackageType.OFFICIAL]: [false],
                [PackageType.COMMUNITY]: [false]
            }),
            availability: this.formBuilder.group({
                [APP_STATE.SUBSCRIBED.label]: [false],
                [APP_STATE.UNPACKED.label]: [false],
                [APP_STATE.EXTERNAL.label]: [false],
                [APP_STATE.CUSTOM.label]: [false]
            }),
            content: this.formBuilder.group({
                [APP_STATE.PACKAGE_BLUEPRINT.label]: [false],
                [APP_STATE.PACKAGE_PLUGIN.label]: [false]
            })
        });
    }
    setPipe() {
        const filterPipe = pipe(map((data) => {
            this.data = data.filter((app) => {
                var _a;
                let matchesByString;
                if (!this.currentFilterTerm || this.currentFilterTerm.trim().length === 0) {
                    matchesByString = true;
                }
                else {
                    const appName = this.currentLang === 'en' || !((_a = app.name) === null || _a === void 0 ? void 0 : _a.length) || !internalApps[app.name]
                        ? app.name
                        : this.translateService.instant(internalApps[app.name]);
                    matchesByString =
                        this.filterContainString(appName, this.currentFilterTerm) ||
                            this.filterContainString(app.description, this.currentFilterTerm);
                }
                const matchesByPredefinedProperty = this.appMatchesByPredefinedProperty(app, 'type') &&
                    this.appMatchesByPredefinedProperty(app, 'availability') &&
                    this.appMatchesByPredefinedProperty(app, 'content');
                return matchesByString && matchesByPredefinedProperty;
            });
            return this.data;
        }));
        this.filterPipeChange.emit(filterPipe);
    }
    filterContainString(name, filterTerm) {
        const term = filterTerm.toLowerCase().trim();
        return name && name.toLowerCase().indexOf(term) > -1;
    }
    appMatchesByPredefinedProperty(app, property) {
        var _a;
        // if filter object does not contain property filters or all filters are false, filter is inactive
        const filterForPropertyIsActive = ((_a = this.currentFiltersState) === null || _a === void 0 ? void 0 : _a[property]) &&
            !Object.values(this.currentFiltersState[property]).every(v => !v);
        if (!filterForPropertyIsActive) {
            return true;
        }
        else {
            return this.currentFiltersState[property][app.filterProps[property]];
        }
    }
    setChips() {
        this.chips = [];
        Object.values(this.formGroup.controls).forEach((controlsGroup) => {
            Object.entries(controlsGroup.controls).forEach((entry) => {
                if (entry[1].value) {
                    this.chips.push(entry);
                }
            });
        });
    }
}
ListFiltersComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ListFiltersComponent, deps: [{ token: i1.FormBuilder }, { token: i2.AppStateService }, { token: i2$1.TranslateService }, { token: i2.GainsightService }], target: i0.ɵɵFactoryTarget.Component });
ListFiltersComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ListFiltersComponent, selector: "c8y-list-filters", inputs: { packageTypes: "packageTypes", packageAvailabilities: "packageAvailabilities", packageContents: "packageContents" }, outputs: { filterPipeChange: "filterPipeChange" }, viewQueries: [{ propertyName: "filterInput", first: true, predicate: FilterInputComponent, descendants: true }], ngImport: i0, template: "<form class=\"d-flex a-i-center\" [formGroup]=\"formGroup\">\n  <c8y-filter (onSearch)=\"setFilterTerm($event)\"></c8y-filter>\n\n  <div\n    *ngIf=\"predefinedFiltersVisible\"\n    class=\"dropdown m-l-8 m-r-4\"\n    dropdown\n    (isOpenChange)=\"toggleDropdown($event)\"\n    #filtersDropdown=\"bs-dropdown\"\n    [cdkTrapFocus]=\"filtersDropdown.isOpen\"\n    [insideClick]=\"true\"\n  >\n    <div class=\"input-group d-inline-flex\">\n      <button\n        class=\"btn-clean form-control p-l-8 p-r-16 a-s-stretch d-flex a-i-center w-auto\"\n        title=\"{{ 'Filters' | translate }}\"\n        dropdownToggle\n      >\n        <span [ngPlural]=\"chips.length\">\n          <ng-template ngPluralCase=\"=0\">\n            {{ 'Filters' | translate }}\n          </ng-template>\n          <ng-template ngPluralCase=\"=1\">\n            <span class=\"badge badge-info\">{{ chips.length }}</span>\n            {{ 'Filter' | translate }}\n          </ng-template>\n          <ng-template ngPluralCase=\"other\">\n            <span class=\"badge badge-info\">{{ chips.length }}</span>\n            {{ 'Filters' | translate }}\n          </ng-template>\n        </span>\n        <span class=\"caret\"></span>\n      </button>\n      <div\n        class=\"input-group-addon p-t-0 p-b-0 d-flex gap-4 a-i-center inner-scroll\"\n        *ngIf=\"chips.length > 0\"\n      >\n        <ng-container *ngFor=\"let chip of chips\">\n          <span class=\"label label-info chip\" *ngIf=\"chip[1].value\">\n            <button\n              class=\"btn btn-xs btn-clean text-10\"\n              type=\"button\"\n              title=\"{{ 'Remove' | translate }} {{ chip[0] | translate | titlecase }}\"\n              (click)=\"deselectChip(chip)\"\n            >\n              <i c8yIcon=\"times\"></i>\n            </button>\n            {{ chip[0] | translate | titlecase }}\n          </span>\n        </ng-container>\n      </div>\n    </div>\n    <div class=\"dropdown-menu\" *dropdownMenu>\n      <div class=\"dropdown-form\">\n        <c8y-form-group *ngIf=\"packageTypes.length\" formGroupName=\"type\">\n          <label>\n            {{ 'Type' | translate }}\n          </label>\n          <label class=\"c8y-checkbox\" *ngFor=\"let type of packageTypes\" [title]=\"type | translate\">\n            <input type=\"checkbox\" [formControlName]=\"type\" [value]=\"type\" />\n            <span></span>\n            <span>{{ type | translate | titlecase }}</span>\n          </label>\n        </c8y-form-group>\n\n        <c8y-form-group *ngIf=\"packageAvailabilities.length\" formGroupName=\"availability\">\n          <label>\n            {{ 'Availability' | translate }}\n          </label>\n          <label\n            class=\"c8y-checkbox\"\n            *ngFor=\"let availability of packageAvailabilities\"\n            [title]=\"availability | translate\"\n          >\n            <input type=\"checkbox\" [formControlName]=\"availability\" [value]=\"availability\" />\n            <span></span>\n            <span>{{ availability | translate }}</span>\n          </label>\n        </c8y-form-group>\n\n        <c8y-form-group *ngIf=\"packageContents.length\" formGroupName=\"content\">\n          <label>\n            {{ 'Content' | translate }}\n          </label>\n          <label\n            class=\"c8y-checkbox\"\n            *ngFor=\"let content of packageContents\"\n            [title]=\"content | translate\"\n          >\n            <input type=\"checkbox\" [formControlName]=\"content\" [value]=\"content\" />\n            <span></span>\n            <span>{{ content | translate }}</span>\n          </label>\n        </c8y-form-group>\n      </div>\n      <div class=\"p-16 d-flex gap-8 separator-top\">\n        <button\n          class=\"btn btn-default btn-sm flex-grow\"\n          type=\"button\"\n          title=\"{{ 'Reset' | translate }}\"\n          (click)=\"reset(); filtersDropdown.isOpen = false\"\n          translate\n        >\n          Reset\n        </button>\n\n        <button\n          class=\"btn btn-primary btn-sm flex-grow\"\n          type=\"button\"\n          title=\"{{ 'Apply' | translate }}\"\n          (click)=\"applyPredefinedFilters(); filtersDropdown.isOpen = false\"\n          [disabled]=\"formGroup.pristine && formGroup.untouched\"\n          translate\n        >\n          Apply\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n", dependencies: [{ kind: "directive", type: i2.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i2.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i3$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3$1.NgPlural, selector: "[ngPlural]", inputs: ["ngPlural"] }, { kind: "directive", type: i3$1.NgPluralCase, selector: "[ngPluralCase]" }, { kind: "directive", type: i1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "component", type: i2.FormGroupComponent, selector: "c8y-form-group", inputs: ["hasError", "hasWarning", "hasSuccess", "novalidation", "status"] }, { kind: "directive", type: i2.RequiredInputPlaceholderDirective, selector: "input[required], input[formControlName]" }, { kind: "component", type: i2.FilterInputComponent, selector: "c8y-filter", inputs: ["icon"], outputs: ["onSearch"] }, { kind: "directive", type: i1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: i1.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { kind: "directive", type: i6.BsDropdownMenuDirective, selector: "[bsDropdownMenu],[dropdownMenu]", exportAs: ["bs-dropdown-menu"] }, { kind: "directive", type: i6.BsDropdownToggleDirective, selector: "[bsDropdownToggle],[dropdownToggle]", exportAs: ["bs-dropdown-toggle"] }, { kind: "directive", type: i6.BsDropdownDirective, selector: "[bsDropdown], [dropdown]", inputs: ["placement", "triggers", "container", "dropup", "autoClose", "isAnimated", "insideClick", "isDisabled", "isOpen"], outputs: ["isOpenChange", "onShown", "onHidden"], exportAs: ["bs-dropdown"] }, { kind: "directive", type: i8.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }, { kind: "pipe", type: i2.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3$1.TitleCasePipe, name: "titlecase" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ListFiltersComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-list-filters', template: "<form class=\"d-flex a-i-center\" [formGroup]=\"formGroup\">\n  <c8y-filter (onSearch)=\"setFilterTerm($event)\"></c8y-filter>\n\n  <div\n    *ngIf=\"predefinedFiltersVisible\"\n    class=\"dropdown m-l-8 m-r-4\"\n    dropdown\n    (isOpenChange)=\"toggleDropdown($event)\"\n    #filtersDropdown=\"bs-dropdown\"\n    [cdkTrapFocus]=\"filtersDropdown.isOpen\"\n    [insideClick]=\"true\"\n  >\n    <div class=\"input-group d-inline-flex\">\n      <button\n        class=\"btn-clean form-control p-l-8 p-r-16 a-s-stretch d-flex a-i-center w-auto\"\n        title=\"{{ 'Filters' | translate }}\"\n        dropdownToggle\n      >\n        <span [ngPlural]=\"chips.length\">\n          <ng-template ngPluralCase=\"=0\">\n            {{ 'Filters' | translate }}\n          </ng-template>\n          <ng-template ngPluralCase=\"=1\">\n            <span class=\"badge badge-info\">{{ chips.length }}</span>\n            {{ 'Filter' | translate }}\n          </ng-template>\n          <ng-template ngPluralCase=\"other\">\n            <span class=\"badge badge-info\">{{ chips.length }}</span>\n            {{ 'Filters' | translate }}\n          </ng-template>\n        </span>\n        <span class=\"caret\"></span>\n      </button>\n      <div\n        class=\"input-group-addon p-t-0 p-b-0 d-flex gap-4 a-i-center inner-scroll\"\n        *ngIf=\"chips.length > 0\"\n      >\n        <ng-container *ngFor=\"let chip of chips\">\n          <span class=\"label label-info chip\" *ngIf=\"chip[1].value\">\n            <button\n              class=\"btn btn-xs btn-clean text-10\"\n              type=\"button\"\n              title=\"{{ 'Remove' | translate }} {{ chip[0] | translate | titlecase }}\"\n              (click)=\"deselectChip(chip)\"\n            >\n              <i c8yIcon=\"times\"></i>\n            </button>\n            {{ chip[0] | translate | titlecase }}\n          </span>\n        </ng-container>\n      </div>\n    </div>\n    <div class=\"dropdown-menu\" *dropdownMenu>\n      <div class=\"dropdown-form\">\n        <c8y-form-group *ngIf=\"packageTypes.length\" formGroupName=\"type\">\n          <label>\n            {{ 'Type' | translate }}\n          </label>\n          <label class=\"c8y-checkbox\" *ngFor=\"let type of packageTypes\" [title]=\"type | translate\">\n            <input type=\"checkbox\" [formControlName]=\"type\" [value]=\"type\" />\n            <span></span>\n            <span>{{ type | translate | titlecase }}</span>\n          </label>\n        </c8y-form-group>\n\n        <c8y-form-group *ngIf=\"packageAvailabilities.length\" formGroupName=\"availability\">\n          <label>\n            {{ 'Availability' | translate }}\n          </label>\n          <label\n            class=\"c8y-checkbox\"\n            *ngFor=\"let availability of packageAvailabilities\"\n            [title]=\"availability | translate\"\n          >\n            <input type=\"checkbox\" [formControlName]=\"availability\" [value]=\"availability\" />\n            <span></span>\n            <span>{{ availability | translate }}</span>\n          </label>\n        </c8y-form-group>\n\n        <c8y-form-group *ngIf=\"packageContents.length\" formGroupName=\"content\">\n          <label>\n            {{ 'Content' | translate }}\n          </label>\n          <label\n            class=\"c8y-checkbox\"\n            *ngFor=\"let content of packageContents\"\n            [title]=\"content | translate\"\n          >\n            <input type=\"checkbox\" [formControlName]=\"content\" [value]=\"content\" />\n            <span></span>\n            <span>{{ content | translate }}</span>\n          </label>\n        </c8y-form-group>\n      </div>\n      <div class=\"p-16 d-flex gap-8 separator-top\">\n        <button\n          class=\"btn btn-default btn-sm flex-grow\"\n          type=\"button\"\n          title=\"{{ 'Reset' | translate }}\"\n          (click)=\"reset(); filtersDropdown.isOpen = false\"\n          translate\n        >\n          Reset\n        </button>\n\n        <button\n          class=\"btn btn-primary btn-sm flex-grow\"\n          type=\"button\"\n          title=\"{{ 'Apply' | translate }}\"\n          (click)=\"applyPredefinedFilters(); filtersDropdown.isOpen = false\"\n          [disabled]=\"formGroup.pristine && formGroup.untouched\"\n          translate\n        >\n          Apply\n        </button>\n      </div>\n    </div>\n  </div>\n</form>\n" }]
        }], ctorParameters: function () { return [{ type: i1.FormBuilder }, { type: i2.AppStateService }, { type: i2$1.TranslateService }, { type: i2.GainsightService }]; }, propDecorators: { packageTypes: [{
                type: Input
            }], packageAvailabilities: [{
                type: Input
            }], packageContents: [{
                type: Input
            }], filterPipeChange: [{
                type: Output
            }], filterInput: [{
                type: ViewChild,
                args: [FilterInputComponent]
            }] } });

class SharedEcosystemModule {
}
SharedEcosystemModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SharedEcosystemModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SharedEcosystemModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: SharedEcosystemModule, declarations: [AddApplicationComponent,
        ApplicationPropertiesFormComponent,
        UploadArchiveComponent,
        ApplicationCardComponent,
        DuplicateApplicationListComponent,
        DuplicateApplicationPropertiesComponent,
        DuplicateApplicationComponent,
        PackageVersionSelectComponent,
        TranslatePackageLabelPipe,
        ListFiltersComponent], imports: [CoreModule,
        BsDropdownModule,
        TooltipModule,
        A11yModule,
        FormsModule,
        ReactiveFormsModule], exports: [AddApplicationComponent,
        ApplicationPropertiesFormComponent,
        UploadArchiveComponent,
        ApplicationCardComponent,
        DuplicateApplicationListComponent,
        DuplicateApplicationPropertiesComponent,
        DuplicateApplicationComponent,
        PackageVersionSelectComponent,
        TranslatePackageLabelPipe,
        ListFiltersComponent] });
SharedEcosystemModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SharedEcosystemModule, providers: [
        hookWizard({
            wizardId: EcosystemWizards.APPLICATION_UPLOAD,
            component: DuplicateApplicationComponent,
            name: 'Duplicate existing application',
            c8yIcon: 'copy'
        }),
        hookWizard({
            wizardId: 'duplicateApplication',
            component: DuplicateApplicationComponent,
            name: 'Duplicate existing application',
            c8yIcon: 'copy'
        })
    ], imports: [CoreModule,
        BsDropdownModule,
        TooltipModule,
        A11yModule,
        FormsModule,
        ReactiveFormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SharedEcosystemModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CoreModule,
                        BsDropdownModule,
                        TooltipModule,
                        A11yModule,
                        FormsModule,
                        ReactiveFormsModule
                    ],
                    declarations: [
                        AddApplicationComponent,
                        ApplicationPropertiesFormComponent,
                        UploadArchiveComponent,
                        ApplicationCardComponent,
                        DuplicateApplicationListComponent,
                        DuplicateApplicationPropertiesComponent,
                        DuplicateApplicationComponent,
                        PackageVersionSelectComponent,
                        TranslatePackageLabelPipe,
                        ListFiltersComponent
                    ],
                    exports: [
                        AddApplicationComponent,
                        ApplicationPropertiesFormComponent,
                        UploadArchiveComponent,
                        ApplicationCardComponent,
                        DuplicateApplicationListComponent,
                        DuplicateApplicationPropertiesComponent,
                        DuplicateApplicationComponent,
                        PackageVersionSelectComponent,
                        TranslatePackageLabelPipe,
                        ListFiltersComponent
                    ],
                    providers: [
                        hookWizard({
                            wizardId: EcosystemWizards.APPLICATION_UPLOAD,
                            component: DuplicateApplicationComponent,
                            name: 'Duplicate existing application',
                            c8yIcon: 'copy'
                        }),
                        hookWizard({
                            wizardId: 'duplicateApplication',
                            component: DuplicateApplicationComponent,
                            name: 'Duplicate existing application',
                            c8yIcon: 'copy'
                        })
                    ]
                }]
        }] });

const defaultPackageTypes = [
    PackageType.OFFICIAL,
    PackageType.COMMUNITY
];
const defaultPackageAvailabilities = [
    APP_STATE.SUBSCRIBED.label,
    APP_STATE.UNPACKED.label,
    APP_STATE.EXTERNAL.label,
    APP_STATE.CUSTOM.label
];
const defaultPackageContents = [
    APP_STATE.PACKAGE_BLUEPRINT.label,
    APP_STATE.PACKAGE_PLUGIN.label
];

/**
 * Generated bundle index. Do not edit.
 */

export { APP_STATE, AddApplicationComponent, ApplicationCardComponent, ApplicationPropertiesFormComponent, DuplicateApplicationComponent, DuplicateApplicationListComponent, DuplicateApplicationPropertiesComponent, ERROR_MESSAGES, ERROR_TYPE, EcosystemService, EcosystemWizards, ListFiltersComponent, PACKAGE_TYPE_LABELS, PRODUCT_EXPERIENCE, PackageVersionSelectComponent, SharedEcosystemModule, TranslatePackageLabelPipe, UploadArchiveComponent, defaultPackageAvailabilities, defaultPackageContents, defaultPackageTypes, packageProperties };
//# sourceMappingURL=c8y-ngx-components-ecosystem-shared.mjs.map
