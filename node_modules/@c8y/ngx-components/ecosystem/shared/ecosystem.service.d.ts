import { EventEmitter } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { ApplicationService, ApplicationType, IApplication, IApplicationBinary, IApplicationVersion, IApplicationVersionDeleteParams, IdReference, IFetchResponse, IIdentified, IManagedObject, IManifest, InventoryService, IResult, IResultList, TenantService } from '@c8y/client';
import { AlertService, ApplicationPlugin, AppStateService, HumanizeAppNamePipe, ModalService, WizardModalService, ZipService } from '@c8y/ngx-components';
import { TranslateService } from '@ngx-translate/core';
import { BehaviorSubject } from 'rxjs';
import { EcosystemError } from './ecosystem-error';
import { ApplicationState, LicensedApplicationPlugin } from './ecosystem.model';
import * as i0 from "@angular/core";
export declare class EcosystemService {
    private modal;
    private alertService;
    private humanizeAppName;
    private translateService;
    private applicationService;
    private appStateService;
    private zipService;
    private tenantService;
    private inventoryService;
    private wizardModalService;
    appDeleted: EventEmitter<IApplication>;
    progress: BehaviorSubject<number>;
    private appsGroupedByContextPath$;
    private xhr;
    constructor(modal: ModalService, alertService: AlertService, humanizeAppName: HumanizeAppNamePipe, translateService: TranslateService, applicationService: ApplicationService, appStateService: AppStateService, zipService: ZipService, tenantService: TenantService, inventoryService: InventoryService, wizardModalService: WizardModalService);
    getUniqueAppConfig(srcApp: IApplication, existingApps: IApplication[]): IApplication;
    /**
     * Verify versions compatibility for blueprints. If a blueprint version
     * is not compatible, a warning is shown.
     *
     * @param blueprint The blueprint to install.
     * @returns true if the installation can continue or false if it should be aborted.
     */
    verifyBlueprintVersionsCompatibility(blueprint: Partial<IManifest>): Promise<boolean>;
    /**
     * Verify versions compatibility for plugins. In case a version does not exist in the
     * versioningMatrix we don't do anything due to backward compatibility. If a plugin version
     * is not compatible, a warning is shown.
     *
     * @param pluginsToInstall The list of plugins to install.
     * @returns true if the installation can continue or false if it should be aborted.
     */
    verifyPluginVersionsCompatibility(pluginsToInstall: ApplicationPlugin[], app: IApplication): Promise<boolean>;
    /**
     * Community plugins need to verify the license agreement. If a package is a community
     * package, the license is shown.
     *
     * @param pluginsToInstall The list of plugins to install.
     * @returns true if the installation can continue.
     */
    verifyLicenses(pluginsToInstall: Array<LicensedApplicationPlugin>): Promise<boolean>;
    /**
     * @description
     * Compares currently deployed application version with application version tagged as "latest"
     *
     * @param {string} currentApplicationVersion Deployed application version
     * @param {object} latestApp Latest application version object
     *
     * @returns {boolean} Returns true if latest version is greater than current, otherwise false
     */
    shouldUpgradePackage(currentApplicationVersion: string, latestApp: IApplicationVersion): boolean;
    /**
     * @description
     * Gets an object that contains searched tag
     *
     * @param {array} applicationVersions Array with all available versions
     * @param {string} tagName Searched tag
     *
     * @returns {object} Returns an object with searched tag
     */
    getApplicationVersionObjectByTag(applicationVersions: IApplicationVersion[], tagName: string): IApplicationVersion;
    getApplication(appId: IdReference): Promise<IApplication>;
    getApplications(customFilter?: any): Promise<IResultList<IApplication>>;
    getMicroservices(): Promise<IApplication[]>;
    getWebApplications(customFilter?: any): Promise<IApplication[]>;
    getFeatureApplications(customFilter?: any): Promise<IApplication[]>;
    getPackageApplications(customFilter?: any): Promise<IApplication[]>;
    isMicroserviceHostingAllowed(): Promise<boolean>;
    canOpenAppInBrowser(app: IApplication): boolean;
    openApp(app: any): void;
    canDeleteApp(app: IApplication): Promise<boolean>;
    isOwner(app: IApplication): boolean;
    isFeature(app: IApplication): boolean;
    isMicroservice(app: IApplication): boolean;
    isExternal(app: IApplication): boolean;
    isPackage(app: IApplication): boolean;
    isPlugin(app: IApplication): boolean;
    cancelAppCreation(app: IApplication): void;
    updateUploadProgress(event: any): void;
    setAppActiveVersion(app: IApplication, activeVersionId: string): Promise<IApplication>;
    setPackageVersionTag(app: IApplication, version: string, tags: string[]): Promise<{
        res: IFetchResponse;
        data: any;
    }>;
    deletePackageVersion(app: IApplication, params: IApplicationVersionDeleteParams): Promise<{
        res: IFetchResponse;
        data: any;
    }>;
    getHumanizedAppName(app: IApplication): Promise<string>;
    createConfig(app: IApplication, formGroupValue: FormGroup): Partial<IApplication>;
    updateAppManifest(application: IApplication, sourcePackage: IApplication): Promise<{
        res: IFetchResponse;
        data: any;
    }>;
    listArchives(appId: string | number | IApplication): Promise<IApplicationBinary[]>;
    deleteArchive(archive: IApplicationBinary, app: IApplication): Promise<void>;
    getArchiveManagedObject(binaryId: string): Promise<IManagedObject>;
    downloadArchive(app: IApplication, archive: Pick<IApplicationBinary, 'name' | 'id'>): Promise<void>;
    updateApp(app: IApplication, deleteOnFailure?: boolean): Promise<IResult<IApplication>>;
    deleteApp(app: IApplication, silent?: boolean): Promise<void>;
    checkIfSubscribed(app: IApplication): Promise<boolean>;
    subscribeApp(app: IApplication): Promise<void>;
    unsubscribeApp(app: IApplication): Promise<void>;
    isValidAppType(archive: File, appType: ApplicationType): Promise<boolean>;
    uploadArchiveToApp(archive: File, app: IApplication, isNewVersion?: boolean): Promise<IApplication>;
    validateArchiveToAppCompatibility(archive: File, app: IApplication): Promise<void>;
    getCumulocityJson(archive: File): Promise<IManifest | null>;
    createAppForArchive(archive: any, isPackageTypeArchive?: boolean): Promise<IApplication>;
    reactivateArchive(app: IApplication): Promise<void>;
    removeOldestArchive(app: IApplication, archives: IApplicationBinary[]): Promise<void>;
    deployApp(selectedPackage: IApplication, formGroupValue: any, model: any): Promise<void>;
    fallbackToCloneLatest(config: any, selectedPackage: any): Promise<void>;
    getAppState(app: IApplication): ApplicationState;
    getPackageContentState(app: IApplication): ApplicationState;
    isPackageBlueprint(app: IApplication): boolean;
    isPluginsPackage(app: IApplication): boolean;
    isUnpacked(app: IApplication): boolean;
    hasExports(app: IApplication): boolean;
    isApplication(app: IApplication): boolean;
    isCustomMicroservice(app: IApplication): boolean;
    getBinary(app: IApplication, archive: IApplicationBinary | IIdentified): Promise<ArrayBuffer>;
    isOverwrittenByCustomApp(app: IApplication): Promise<boolean>;
    hasSubscribedAppParent(app: IApplication): Promise<boolean>;
    /**
     * @deprecated
     */
    setAvailabilityToPrivateIfNotSetAlready(app: IApplication): IApplication;
    /**
     * Shows an error dialog.
     * @param error Either a server error or an internal [[EcosystemError]].
     */
    alertError(error: Error | EcosystemError): void;
    validatePackageKeyAndContextPath(manifest: IManifest, app: IApplication): Promise<void>;
    filterContainString(name: string, filterTerm: string): boolean;
    private showModal;
    private getPlatformVersion;
    private getAppKey;
    private getContextPath;
    private removeForbiddenCharacters;
    private isCurrentApp;
    private getCumulocityJson$;
    private getAppType;
    private getBaseNameFromArchiveOrAppModel;
    private checkIfAppNameKeyPathExists;
    private removeAppProperties;
    private getUploadOverrides;
    private removeVersionFromName;
    private isNameLengthExceeded;
    static ɵfac: i0.ɵɵFactoryDeclaration<EcosystemService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<EcosystemService>;
}
