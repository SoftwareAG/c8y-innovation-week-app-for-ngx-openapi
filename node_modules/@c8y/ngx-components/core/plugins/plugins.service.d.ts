import { ApplicationRemotePlugins, IApplication, IManifest } from '@c8y/client';
import { ApplicationService } from '@c8y/ngx-components/api';
import { AppStateService } from '../common/ui-state.service';
import { ApplicationPlugin, PackageType } from './plugins.model';
import * as i0 from "@angular/core";
export declare class PluginsService {
    private applicationService;
    private appStateService;
    constructor(applicationService: ApplicationService, appStateService: AppStateService);
    /**
     * Fetches a list of available packages.
     * @param params Additional query parameters.
     * @returns Returns a list of packages.
     */
    listPackages(params?: any): Promise<IApplication[]>;
    /**
     * Checks if an application is a package.
     * @param application Application managed object.
     * @returns Returns true if the application is a package.
     */
    isPackage(application: IApplication): boolean;
    /**
     * Updates the remotes field in the application configuration by adding new plugins.
     * Important: if the remotes object is not set on the configuration object,
     * remotes will not be added. Make sure that this object exists in the application configuration.
     * @param application Application managed object.
     * @param plugins List of remotes to be added.
     * @returns Returns updated application remotes.
     */
    addRemotes(application: IApplication, plugins: ApplicationPlugin | ApplicationPlugin[]): Promise<ApplicationRemotePlugins>;
    /**
     * Updates the remotes field in the application configuration by removing plugins.
     * @param application Application managed object.
     * @param plugins List of remotes to be removed.
     * @returns Returns updated application remotes.
     */
    removeRemotes(application: IApplication, plugins: ApplicationPlugin | ApplicationPlugin[]): Promise<ApplicationRemotePlugins>;
    /**
     * Updates the remotes field in the application configuration.
     * @param application Application managed object.
     * @param plugins List of remotes to be added.
     * @returns Returns updated application remotes.
     */
    updateRemotesInAppConfig(application: IApplication, plugins: ApplicationRemotePlugins): Promise<ApplicationRemotePlugins>;
    /**
     * Fetches the application manifest.
     * @param application Application managed object.
     * @returns Returns the application manifest.
     */
    getCumulocityJsonFile(application: IApplication): Promise<IManifest>;
    /**
     * Sets the initial state of remotes in the configuration (when it's missing), based on the list of remotes being in the application manifest.
     * @param application  Application managed object.
     * @returns Returns a list of remotes that has been assigned to the configuration object.
     */
    setInitialRemotes(application: IApplication): Promise<ApplicationRemotePlugins>;
    /**
     * Sorts versions list or list of objects by version property
     * @returns list of versions as array of strings or array of objects sorted by version property
     *
     * @param {{ list: T[]; path: string[] } | string[]} source data to sort
     * @param {'asc' | 'desc'} order ascending or descending order of sorting
     *
     * **Example**
     * ```typescript
     * const data = ['1.5.0', '2.0.0'];
     * const sortedData = pluginsService.sortVersions(versions, 'desc');
     * // sortedData:
     * // ['2.0.0', '1.5.0']
     * ```
     *
     * **Example**
     * ```typescript
     * const data = [
     *  {app: {appVersion: '1.5.0'}},
     *  {app: {appVersion: '2.0.0'}},
     * ];
     * const sortedData = pluginsService.sortVersions({list: data, path: ['app', 'appVersion']}, 'desc');
     * // sortedData:
     * // [
     * //  {app: {appVersion: '2.0.0'}},
     * //  {app: {appVersion: '1.5.0'}}
     * // ]
     * ```
     */
    sortVersions<T>(source: {
        list: T[];
        path: string[];
    }, order: 'asc' | 'desc'): T[];
    sortVersions(source: string[], order: 'asc' | 'desc'): string[];
    /**
     * Extracts a list of exported plugins from the application object.
     * @param application Application managed object.
     * @returns Returns a list of exported plugins.
     */
    getMFExports(application: IApplication): ApplicationPlugin[];
    /**
     * Extracts a list of exports from each available package.
     * @returns Returns a list of all exported plugins.
     */
    getAllMFExports(allVersions?: boolean): Promise<ApplicationPlugin[]>;
    /**
     * Extracts a list of remotes from the application object.
     * @param application Application managed object.
     * @returns Returns list of remotes.
     */
    getMFRemotes(application: IApplication): ApplicationRemotePlugins;
    /**
     * Determines the type of a package.
     * A package is OFFICIAL if it comes from management tenant and has a label attached called OFFICIAL.
     * A package is COMMUNITY if it has a label called COMMUNITY.
     * A package is CUSTOM if it does not have any label attached.
     * A package is UNKNOWN if it has a label attached but it does not match COMMUNITY or OFFICIAL.
     *
     * Labels can be used to identify the status of a package. Community packages always need
     * a license validation. The label will be shown on the application card to tell a user
     * whether they are looking into an official or community package.
     *
     * @param packageApplication The package application object to check.
     * @returns The package type.
     */
    getPackageType(packageApplication: IApplication): PackageType;
    /**
     * Verifies if an application is owned by management tenant.
     *
     * @param app The application to verify.
     * @returns True if owned by management tenant.
     */
    isOwnedByManagement(app: IApplication): boolean;
    private removeDuplicates;
    private isFromCurrentTenant;
    /**
     * Modifies the list of plugins to have additional information such as id.
     * @ignore
     */
    private extendPluginsDetails;
    private listApplicationsByCurrentTenant;
    private addPluginToRemotes;
    private removePluginsFromRemotes;
    private createPluginId;
    private parsePluginId;
    static ɵfac: i0.ɵɵFactoryDeclaration<PluginsService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<PluginsService>;
}
