import { NgModuleRef, EnvironmentInjector, Type } from '@angular/core';
import { ApplicationRemotePlugins, FetchClient } from '@c8y/client';
import { TranslateService } from '@ngx-translate/core';
import { Observable } from 'rxjs';
import { AppStateService } from '../common';
import * as i0 from "@angular/core";
export declare class PluginsResolveService {
    private translateService;
    private fetchClient;
    private appState;
    private injector;
    /**
     * Emits all injectors of already loaded plugins on subscription.
     */
    injectors$: Observable<EnvironmentInjector>;
    /**
     * Emits once remotePlugins have been resolved.
     */
    refresh$: Observable<void>;
    /**
     * Emits all plugin details of already loaded plugins on subscription.
     */
    pluginDetails$: Observable<{
        remoteNgModule: NgModuleRef<unknown> | Type<unknown>;
        moduleRef: NgModuleRef<unknown>;
    }>;
    allPluginsLoaded$: Observable<boolean>;
    private urlRemotesCache;
    private remoteScriptSet;
    private _injectors$;
    private _refresh$;
    private _pluginDetails$;
    private _allPluginsLoaded$;
    constructor(translateService: TranslateService, fetchClient: FetchClient, appState: AppStateService, injector: EnvironmentInjector);
    /**
     * Loads plugins by resolving the remote NgModules and injecting it. Also attaching
     * the hooks onto the root injector.
     * @param remoteModules The remote plugins to load as factory name mapping array.
     */
    resolveRemotePlugins(remoteModules: Array<{
        factory: any;
        name: any;
    }>): void;
    /**
     * Loads modules and handles hooking correctly.
     * @param remoteNgModules The modules to load.
     */
    loadModulesDynamically(remoteModules: Array<{
        factory: any;
        name: any;
    }>): void;
    loadModule(remoteNgModule: NgModuleRef<unknown> | Type<unknown>): NgModuleRef<unknown>;
    /**
     * Will refresh all current registered hooks.
     */
    refreshHooks(): void;
    markPluginsAsLoaded(): void;
    /**
     * Loads a list of remotes so that a particular application can use them.
     * The request is made to the following address: /apps/<contextPath>/remoteEntry.js
     * @param remotes List of remotes to be loaded.
     * @returns Returns the list of loaded modules from remotes.
     */
    loadRemotes(remotes: ApplicationRemotePlugins): Promise<any[]>;
    /**
     * Takes a list of remotes and turns it into an object containing union of corresponding remotes.
     * @param mfRemotes List of the remotes.
     * @returns Returns object with merged remotes.
     *
     * **Example**
     * ```typescript
     * const remotesA:ApplicationRemotePlugins = { contextPathA: ['moduleA', 'moduleB'] };
     * const remotesB:ApplicationRemotePlugins = { contextPathA: ['moduleA'], contextPathB: ['moduleZ'] };
     * const mergedRemotes:ApplicationRemotePlugins = mergeMFRemotes([remotesA, remotesB]);
     * // Result
     * {
     *  contextPathA: ['moduleA', 'moduleB'],
     *  contextPathB: ['moduleZ']
     * }
     *
     * ```
     */
    mergeMFRemotes(mfRemotes: ApplicationRemotePlugins[]): ApplicationRemotePlugins;
    /**
     * Clears URL remotes cache.
     */
    clearURLRemotesCache(): void;
    /**
     * Retrieves the remotes list from the URL.
     * @returns Returns the list of remotes.
     */
    loadUrlRemotes(): ApplicationRemotePlugins;
    private loadRemoteTranslations;
    private loadRemoteModule;
    private loadRemoteEntry;
    private lookupExposedModule;
    static ɵfac: i0.ɵɵFactoryDeclaration<PluginsResolveService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<PluginsResolveService>;
}
