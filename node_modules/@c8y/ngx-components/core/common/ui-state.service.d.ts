import { FetchClient, IApplication, TenantLoginOptionsService, ApplicationService, ICurrentTenant, IUser } from '@c8y/client';
import { BehaviorSubject, Observable } from 'rxjs';
import { OptionsService } from './options.service';
import { StateService } from './state-service.abstract';
import { ApiService } from '@c8y/ngx-components/api';
import { ApplicationOptions } from './ApplicationOptions';
import * as i0 from "@angular/core";
export declare class AppStateService extends StateService {
    private applicationService;
    apiService: ApiService;
    private options;
    private fetchClient;
    private tenantLoginOptionsService;
    state$: BehaviorSubject<any>;
    currentSupportUserName: BehaviorSubject<string | null>;
    currentUser: BehaviorSubject<IUser | null>;
    currentTenant: BehaviorSubject<ICurrentTenant | null>;
    currentApplication: BehaviorSubject<IApplication | null>;
    currentApplicationConfig: Observable<any>;
    /**
     * An Observable of the applications available for the current user.
     * The Observable emits a new array on user changes or if the application
     * performs POST, PUT or DELETE requests to the application API.
     */
    currentAppsOfUser: Observable<IApplication[]>;
    constructor(applicationService: ApplicationService, apiService: ApiService, options: OptionsService, fetchClient: FetchClient, tenantLoginOptionsService: TenantLoginOptionsService);
    assignApplicationKeyToDefaultHeaders(): void;
    /**
     * Returns the current state.
     */
    get state(): any;
    getLangs(): any;
    /**
     * Returns the correct UI version. In hybrid mode for angular and ngx.
     */
    get uiVersion(): any;
    /**
     * Loads the app manifest. If no access -> throw an error to verify app access.
     */
    loadManifest(): Promise<void>;
    /**
     * Dynamic options are stored on the API in a specific config: {} object. They can
     * be used to configure the app dynamically.
     *
     * Note: To avoids conflicts with the default Config, it is recommended
     * to use a certain namespace.
     */
    updateCurrentApplicationConfig<T = ApplicationOptions>(config: T): Promise<T>;
    /**
     * When this function called, it refreshes the values of loginOptions stored within ui state object.
     * Function is throttled to execute the refresh once in a time specified by params of @throttled decorator,
     * it should be called on leading edge of the timeout.
     */
    refreshLoginOptions(): Promise<void>;
    /**
     * Checks current users application list and matches it against given application name.
     * Returns true if application is in the list.
     * @param name application name
     */
    isApplicationAvailable(name: string): Promise<boolean>;
    /**
     * Sets current user (including support user).
     * @param userInfo Info about current user and support user to be set.
     */
    setUser(userInfo: {
        user: IUser;
        supportUserName: string;
    }): void;
    /**
     * Verifies if the current application is owned by the current tenant.
     * @param app The application to verify.
     * @returns true if it belongs to the current tenant.
     */
    isOwnerOfApplication(app?: IApplication): boolean;
    /**
     * Verifies if the current application is owned by the current tenant.
     * @param app The application to verify.
     * @returns true if it belongs to the current tenant.
     */
    isOwnerOfApplication$(app?: IApplication): Observable<boolean>;
    getCurrentContextPath(): string;
    protected currentAppsOfUser$(): Observable<IApplication[]>;
    /**
     * An Observable emitting once all POST, PUT, DELETE requests to the application API finished
     */
    protected onAppChangesCompletion$(): Observable<void>;
    private loadDefaultOptions;
    private showIncompatibleVersionsError;
    static ɵfac: i0.ɵɵFactoryDeclaration<AppStateService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AppStateService>;
}
