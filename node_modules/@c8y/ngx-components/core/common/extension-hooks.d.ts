import { ClassProvider, ExistingProvider, InjectionToken, Injector, Type, ValueProvider } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { BehaviorSubject, Observable } from 'rxjs';
import { PluginsResolveService } from '../plugins';
import { StateService } from './state-service.abstract';
export declare function fromTrigger<T>(router: Router, refresh: Observable<any> | Observable<any>[], factories: Array<T | T[] | ExtensionFactory<T> | ExtensionFactory<T>[] | (() => T | ExtensionFactory<T> | Array<T | ExtensionFactory<T>>)>): Observable<T[]>;
export declare function fromTriggerOnce<T>(router: Router, refresh: Observable<any> | Observable<any>[], factories: Array<T | T[] | ExtensionFactory<T> | ExtensionFactory<T>[] | (() => T | ExtensionFactory<T> | Array<T | ExtensionFactory<T>>)>): Observable<T[]>;
export declare enum InjectionType {
    COMPONENT = 0,
    ROUTE = 1
}
export declare function getInjectedHooks<T>(token: InjectionToken<T[]>, injectors: Injector[], type?: InjectionType): () => T[];
export declare function fromFactories<T>(factories?: Array<T | T[] | ExtensionFactory<T> | ExtensionFactory<T>[] | (() => T | ExtensionFactory<T> | Array<T | ExtensionFactory<T>>)>, router?: Router, withFirstEmpty?: boolean): Observable<T[]>;
export declare function resolveInjectedFactories<T>(factories: Array<T | T[] | ExtensionFactory<T> | ExtensionFactory<T>[] | (() => T | ExtensionFactory<T> | Array<T | ExtensionFactory<T>>)>): Array<T | T[] | ExtensionFactory<T>>;
export declare function stateToFactory<T>(componentsState: any): ExtensionFactory<T>;
export declare function sortByPriority<T>(items: T[]): T[];
export declare function removeDuplicatesIds<T extends {
    id?: string;
    priority?: number;
}>(items: T[]): T[];
export declare function toObservableOfArrays<T>(factoryResult: T | T[] | Promise<T | T[]> | Observable<T | T[]>, withFirstEmpty: boolean): Observable<T[]>;
export declare function isPromise<T = any>(obj: any): obj is Promise<T>;
export declare function isExtensionFactory<T = any>(obj: any): obj is ExtensionFactory<T>;
/**
 * Converts any value provided to an Observable that emits this value once and then completes.
 * A convenience method to represent all the data as Observables rather than
 * a mixture of Observables and other types.
 *
 * @param value The value the resulting Observable will emit.
 */
export declare function toObservable<T>(value: T | Promise<T> | Observable<T>): Observable<T>;
/**
 * Allows to extend the existing applications from a module.
 */
export interface ExtensionFactory<T> {
    /**
     * Allows to resolve the data of an extension point.
     * The return value can be a Promise or Observable
     * (allowing for asynchronous data resolution).
     *
     * @param activatedRoute The current activated route (if possible to resolve).
     */
    get(activatedRoute?: ActivatedRoute): Observable<T[] | T> | Promise<T[] | T> | T[] | T;
}
/**
 * Extension points allow to extend the application from
 * any module
 */
export interface ExtensionPoint<T> {
    /**
     * Observable that emits of array of extensions active at any give time
     */
    readonly items$: Observable<T[]>;
    /**
     * Additional factories that can be added dynamically. (without hook)
     */
    factories: ExtensionFactory<T>[];
    /**
     * Call the extension factories to refresh them.
     */
    refresh(): any;
}
export declare abstract class ExtensionPointWithoutStateForPlugins<T> implements ExtensionPoint<T> {
    items$: Observable<T[]>;
    factories: ExtensionFactory<T>[];
    readonly refresh$: Observable<void>;
    /**
     * All injectors to search for an extension.
     */
    protected injectors: Injector[];
    private readonly refreshTrigger;
    constructor(rootInjector: Injector, pluginService: PluginsResolveService);
    /**
     * Refresh the extension factories
     */
    refresh(): void;
    /**
     * Should be called within the constructor of the extending class and set the items$ attribute.
     */
    protected abstract setupItemsObservable(): Observable<T[]>;
}
export declare abstract class ExtensionPointForPlugins<T> extends StateService implements ExtensionPoint<T> {
    items$: Observable<T[]>;
    factories: ExtensionFactory<T>[];
    readonly refresh$: Observable<void>;
    readonly state$: BehaviorSubject<Set<T>>;
    /**
     * All injectors to search for an extension.
     */
    protected injectors: Injector[];
    private readonly refreshTrigger;
    constructor(rootInjector: Injector, pluginService: PluginsResolveService);
    /**
     * Refresh the extension factories
     */
    refresh(): void;
    /**
     * Should be called within the constructor of the extending class and set the items$ attribute.
     */
    protected abstract setupItemsObservable(): Observable<T[]>;
}
/**
 * Helper function to get the activated route in
 * a service (as ActivatedRoute injection only
 * works in components). Works as long as we only use
 * a tree and no child is active at the same time.
 *
 * @param router The current router
 */
export declare function getActivatedRoute(router: Router): ActivatedRoute;
export type GenericHookType<T> = T | T[] | Type<ExtensionFactory<T>>;
export type HookValueType<T> = T | T[] | Type<T>;
/**
 * A generic function to be used by specific implementations of the HOOK concept.
 * @param items The items that should be provided under the `useValue` or `useClass` attribute.
 * Allows an extension factory to be passed as an argument, which can create instances of type T.
 * @param token The InjectionToken/HOOK to be provided.
 * @param options If this is a multi provider or not (defaults to true) and provider type definition (defaults to ClassProvider) - `HookOptions`.
 * @returns A `Provider` (either `ValueProvider` or `ClassProvider`) to be provided in a module.
 */
export declare function hookGeneric<T>(items: GenericHookType<T> | HookValueType<T>, token: InjectionToken<T>, options?: Partial<HookOptions>): ValueProvider | ClassProvider | ExistingProvider;
export interface HookOptions {
    multi: boolean;
    providerType: HookProviderTypes;
}
export declare enum HookProviderTypes {
    ExistingProvider = "ExistingProvider",
    ClassProvider = "ClassProvider"
}
export declare function allEntriesAreEqual(previous: Array<unknown>, next: Array<unknown>): boolean;
