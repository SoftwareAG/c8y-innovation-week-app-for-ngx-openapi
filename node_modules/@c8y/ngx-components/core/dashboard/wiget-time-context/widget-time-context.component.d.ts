import { AfterViewInit, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { DashboardChildActionComponent } from '../dashboard-child-action.component';
import { DashboardChildComponent } from '../dashboard-child.component';
import { WidgetsDashboardEventService } from '../widgets-dashboard-event.service';
import { FormBuilder } from '@angular/forms';
import { Interval, WidgetTimeContextChange } from './widget-time-context.model';
import { WidgetTimeContextQueryService } from './widget-time-context-query.service';
import { WidgetTimeContextHelperService } from './widget-time-context-helper.service';
import { Router } from '@angular/router';
import { ActionBarService } from '../../action-bar';
import * as i0 from "@angular/core";
export declare class WidgetTimeContextComponent implements OnInit, OnDestroy, AfterViewInit {
    private widgetEventService;
    private dashboardChild;
    private formBuilder;
    private queryService;
    private helperService;
    private router;
    private actionBarService;
    /**
     * Indicates if the component can decouple or not.
     */
    canDecouple: boolean;
    /**
     * Emits each change as an array of dates [from, to].
     */
    dateContextChange: EventEmitter<WidgetTimeContextChange>;
    /**
     * @ignore
     */
    action: DashboardChildActionComponent;
    /**
     * Indicates if the time context is bound to the global scope.
     */
    isCoupled: boolean;
    decoupleTimeContextLabel: "Decouple time context";
    coupleTimeContextLabel: "Couple time context";
    form: ReturnType<WidgetTimeContextComponent['createForm']>;
    readonly DEFAULT_INTERVAL: Interval['id'];
    readonly ACTION_BAR_GROUP_ID = "timecontext";
    readonly REALTIME_INTERVAL = 1000;
    private subscription;
    private destroy$;
    private navigationInProgress;
    private realtimeSubscription;
    /**
     * @ignore only DI.
     */
    constructor(widgetEventService: WidgetsDashboardEventService, dashboardChild: DashboardChildComponent, formBuilder: FormBuilder, queryService: WidgetTimeContextQueryService, helperService: WidgetTimeContextHelperService, router: Router, actionBarService: ActionBarService);
    /**
     * @ignore Subscribing to the global context.
     */
    ngOnInit(): void;
    /**
     * @ignore Adding custom actions.
     */
    ngAfterViewInit(): void;
    /**
     * Toggles the coupling on or off.
     */
    toggleDecoupling(): void;
    /**
     * Applies form value to global or local date context.
     */
    applyDatetimeContext(): void;
    /**
     * Resets form to initial value and update context.
     */
    reset(): void;
    /**
     * @ignore unsubscribing.
     */
    ngOnDestroy(): void;
    private subscribeToIntervalChange;
    private subscribeToRealtimeChange;
    private createForm;
    /**
     * Fires a new WidgetChangeEvent either on the local change emitter or on the global one.
     * @param widgetTimeContextState New widget time context value.*/
    private update;
    private subscribeToGlobalContext;
    private updateFormValues;
    private unsubscribeFromGlobalContext;
    private getInitialContext;
    private subscribeToQueryParamsChange;
    private clearQueryParamsIfNeeded;
    private subscribeToRouterEvents;
    private getDefaultContext;
    private startRealtime;
    private stopRealtime;
    private onRealtimeValueChange;
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetTimeContextComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetTimeContextComponent, "c8y-widget-time-context", never, { "canDecouple": "canDecouple"; }, { "dateContextChange": "dateContextChange"; }, never, never, false, never>;
}
