import { EventEmitter, OnDestroy, ViewContainerRef, Injector, SimpleChanges } from '@angular/core';
import { DynamicComponent, DynamicComponentErrorStrategy } from './dynamic-component.model';
import { DynamicComponentService } from './dynamic-component.service';
import { Observable } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * C8y dynamic component.
 * ## Example:
 *
 * register component in HOOK in module:
 * ```typescript
 *  import { hookComponent } from '@c8y/ngx-components';
 *
 * @NgModule({
 *  ...,
 *  providers: [
 *    hookComponent({
 *      id: 'test-component',
 *      label: 'My test component',
 *      description: 'this is test component',
 *      component: TestComponent
 *    })
 *  ...
 *  ]
 *
 * ```
 * Showing dynamic component:
 * ```html
 * <c8y-dynamic-component [componentId]="'test-component'" [config]="config"></c8y-dynamic-component>
 * ```
 */
export declare class DynamicComponentComponent implements OnDestroy {
    private dynamicComponentService;
    private injector;
    /**
     * The ID of the registered component. It needs to be a component that is hooked
     * with the HOOK_COMPONENTS extension hook.
     */
    componentId: string;
    /**
     * The configuration to pass.
     */
    config: unknown;
    /**
     * DynamicComponents can have two modes, an edit (config) and an view (component) mode.
     * By default it is shown in the component mode.
     */
    mode: 'config' | 'component';
    /**
     * Disable this to hide the error that is shown if the component was not found.
     */
    notFoundError: boolean;
    /**
     * If set to true, it will execute the components resolvers before initializing the component.
     * Defaults to false.
     */
    executeResolvers: boolean;
    /**
     * Allows to set additional classes for widget styling.
     */
    updateWidgetClasses: EventEmitter<{
        [key: string]: boolean;
    }>;
    /**
     * @ignore
     */
    host: ViewContainerRef;
    /**
     * @ignore
     */
    error: any;
    /**
     * @ignore
     */
    expandErrorDetails: boolean;
    componentInstance: DynamicComponent;
    errorStrategy: DynamicComponentErrorStrategy;
    dynamicComponentErrorStrategy: typeof DynamicComponentErrorStrategy;
    private destroy$;
    private componentRef;
    /**
     * @ignore only DI
     */
    constructor(dynamicComponentService: DynamicComponentService, injector: Injector);
    /**
     * Calls the dynamic component life cycle hook. Currently only
     * supporting onBeforeSave, a hook which is called before a config component
     * is saved.
     */
    callLifeCycleHooks(): Observable<unknown>;
    /**
     * @ignore
     */
    ngOnChanges(changes: SimpleChanges): Promise<void>;
    /**
     * If an outside component changes the configuration, this function triggers ngOnChange on the dynamic component.
     * @param newConfigValues The new configuration value.
     */
    emitConfigChange(newConfigValues: unknown): void;
    ngOnDestroy(): void;
    private emitChangeOnComponent;
    private loadComponent;
    private getComponentType;
    private subscribeForOverlayChange;
    private callOnBeforeSaveHook;
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicComponentComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DynamicComponentComponent, "c8y-dynamic-component", never, { "componentId": "componentId"; "config": "config"; "mode": "mode"; "notFoundError": "notFoundError"; "executeResolvers": "executeResolvers"; }, { "updateWidgetClasses": "updateWidgetClasses"; }, never, never, false, never>;
}
