import { InjectionToken } from '@angular/core';
import { IManagedObject } from '@c8y/client';
import { Widget, DynamicComponentDefinition, Route, ViewContext } from '@c8y/ngx-components';
export declare const CONTEXT_DASHBOARD_CONFIG: InjectionToken<any>;
export interface ContextDashboardConfig {
    widgetFilter?: (component: DynamicComponentDefinition) => boolean;
    allowFullscreen?: boolean;
    routes?: Route[];
}
export interface ContextWidgetConfig {
    /**
     * Settings that define how the default config component is
     * displayed. They are static and will not be saved.
     */
    settings?: {
        /**
         * Avoids to show the widget in the "add widget" modal
         */
        noNewWidgets?: boolean;
        ng1?: {
            options: {
                /**
                 * Set this to false, to hide the device/group selector
                 * @deprecated: This is currently only implemented in angularjs and will be exported to a separate component.
                 */
                noDeviceTarget?: boolean;
                /**
                 * Set this to false to only select devices
                 * @deprecated: This is currently only implemented in angularjs and will be exported to a separate component.
                 */
                groupsSelectable?: boolean;
            };
            /**
             * The context from the device selector.
             */
            context?: {
                id?: string;
                name?: string;
            };
        };
        /**
         * Additional settings passed to the configuration component.
         */
        [key: string]: any;
    };
    /**
     * Settings that are injected in any displaying component.
     */
    displaySettings?: {
        /**
         * If enabled the widget is bound to the global time context. You can listen to ngOnChanges() change detection
         * to react to changes on the context. When a more detailed configuration is needed, use the <c8y-widget-time-context>
         * component instead.
         */
        globalTimeContext?: boolean;
    };
    /**
     * Whatever should be added to the configuration when a widget is created.
     */
    config?: {
        /**
         * Any other information that should be stored here.
         */
        [key: string]: any;
    };
    /**
     * The selected device or group (note: naming is inconsistent as group was added later
     * but must stay for already implemented widgets)
     */
    device?: {
        id?: string | number;
        name?: string;
        [key: string]: any;
    };
    /**
     * Any other information that should be stored here.
     */
    [key: string]: any;
}
export interface ContextDashboardManagedObject extends IManagedObject {
    c8y_Dashboard?: ContextDashboard;
    name?: string;
}
export interface ContextDashboard {
    icon?: string;
    name?: string;
    priority?: number;
    deviceType?: boolean;
    deviceTypeValue?: string;
    isFrozen?: boolean;
    classes?: {
        [key: string]: boolean;
    };
    widgetClasses?: {
        [key: string]: boolean;
    };
    widgetMargin?: number;
    translateWidgetTitle?: boolean;
    global?: boolean;
    children?: {
        [id: string]: Widget;
    };
    globalRolesIds?: DashboardGlobalRoles;
    c8y_IsNavigatorNode?: object;
    description?: string;
}
export declare enum ContextDashboardType {
    Device = "device",
    DeviceType = "type",
    Group = "group",
    Named = "name",
    Report = "report"
}
export declare const WIDGET_HEADER_CLASSES: ({
    label: "Regular`style`";
    class: string;
    description: "The widget has no border between header and content.";
} | {
    label: "Border`style`";
    class: string;
    description: "The widget has a small separation border between header and content.";
} | {
    label: "Overlay`style`";
    class: string;
    description: "The widget content overlays the header.";
} | {
    label: "Hidden`style`";
    class: string;
    description: "The widget header is not shown.";
})[];
export declare const WIDGET_CONTENT_CLASSES: ({
    label: "Match dashboard`style`";
    class: string;
    description: "The widget appearance matches the dashboard appearance.";
} | {
    label: "Light`style`";
    class: string;
    description: "The widget has light appearance, that is, dark text on light background.";
} | {
    label: "Dark`style`";
    class: string;
    description: "The widget has dark appearance, that is, light text on dark background.";
} | {
    label: "Transparent`style`";
    class: string;
    description: "The widget has no background.";
} | {
    label: "Branded`style`";
    class: string;
    description: "The widget is styled with the main brand color.";
})[];
export declare const DASHBOARD_THEME_CLASSES: ({
    label: "Match UI`theme`";
    class: string;
    description: "The dashboard appearance matches the UI appearance.";
} | {
    label: "Light`theme`";
    class: string;
    description: "The dashboard has light appearance, that is, dark text on light background.";
} | {
    label: "Dark`theme`";
    class: string;
    description: "The dashboard has dark appearance, that is, light text on dark background.";
} | {
    label: "Branded`theme`";
    class: string;
    description: "The dashboard is styled using the brand palette.";
})[];
export declare const STYLING_CLASS_PREFIXES: string[];
export interface DashboardCopyClipboard {
    dashboard: ContextDashboard;
    context: DashboardContext;
}
export interface DashboardContext {
    context: ViewContext;
    contextData: Partial<IManagedObject>;
}
export declare const ALL_GLOBAL_ROLES_SELECTED: "all";
export type DashboardGlobalRoles = number[] | typeof ALL_GLOBAL_ROLES_SELECTED;
export declare const PRODUCT_EXPERIENCE: {
    DASHBOARD: {
        EVENTS: {
            DASHBOARD_AVAILABILITY: string;
        };
        COMPONENTS: {
            DASHBOARD_AVAILABILITY: string;
        };
        ACTIONS: {
            APPLY_GLOBAL_ROLES_CHANGES: string;
        };
    };
};
