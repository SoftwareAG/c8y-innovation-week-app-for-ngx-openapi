import { OnDestroy } from '@angular/core';
import { DynamicComponentDefinition, Widget, DynamicComponentComponent } from '@c8y/ngx-components';
import { AssetSelectionChangeEvent } from '@c8y/ngx-components/assets-navigator';
import { BsModalRef } from 'ngx-bootstrap/modal';
import { Subject } from 'rxjs';
import { ContextDashboardManagedObject, ContextWidgetConfig } from './context-dashboard.model';
import { WidgetService } from './widget.service';
import { ContextDashboardService } from './context-dashboard.service';
import { IManagedObject, InventoryService } from '@c8y/client';
import * as i0 from "@angular/core";
export declare class WidgetConfigComponent implements OnDestroy {
    private widgetService;
    private modal;
    private inventory;
    contextDashboardService: ContextDashboardService;
    selectedDevice: IManagedObject;
    mode: 'config' | 'select' | 'style';
    searchResult: DynamicComponentDefinition[];
    components: DynamicComponentDefinition[];
    selected: DynamicComponentDefinition;
    searchChange$: Subject<unknown>;
    searchTerm: string;
    context: any;
    componentLabel: string;
    mo: ContextDashboardManagedObject;
    styling: {
        headerClass: string;
        contentClass: string;
    };
    defaultStyling: {
        headerClass: string;
        contentClass: string;
    };
    possibleStyling: {
        WIDGET_HEADER_CLASSES: ({
            label: "Regular`style`";
            class: string;
            description: "The widget has no border between header and content.";
        } | {
            label: "Border`style`";
            class: string;
            description: "The widget has a small separation border between header and content.";
        } | {
            label: "Overlay`style`";
            class: string;
            description: "The widget content overlays the header.";
        } | {
            label: "Hidden`style`";
            class: string;
            description: "The widget header is not shown.";
        })[];
        WIDGET_CONTENT_CLASSES: ({
            label: "Match dashboard`style`";
            class: string;
            description: "The widget appearance matches the dashboard appearance.";
        } | {
            label: "Light`style`";
            class: string;
            description: "The widget has light appearance, that is, dark text on light background.";
        } | {
            label: "Dark`style`";
            class: string;
            description: "The widget has dark appearance, that is, light text on dark background.";
        } | {
            label: "Transparent`style`";
            class: string;
            description: "The widget has no background.";
        } | {
            label: "Branded`style`";
            class: string;
            description: "The widget is styled with the main brand color.";
        })[];
    };
    current: any;
    widgetConfig: ContextWidgetConfig;
    isUpgrade: boolean;
    dynamicComponent: DynamicComponentComponent;
    get isEdit(): boolean;
    get isDeviceTypeDashboard(): boolean;
    result: Promise<Widget>;
    private searchSub;
    private _save;
    private _cancel;
    constructor(widgetService: WidgetService, modal: BsModalRef, inventory: InventoryService, contextDashboardService: ContextDashboardService);
    ngAfterContentInit(): Promise<void>;
    checkIfDeviceRequired(): boolean;
    selectionChanged(selection?: AssetSelectionChangeEvent): void;
    save(): Promise<void>;
    select(cmp: any, mode?: 'select' | 'config'): void;
    search(): void;
    resetSearch(): void;
    changeMode(mode: 'config' | 'select' | 'style'): void;
    close(): void;
    getStyle(isPreview?: boolean): {};
    ngOnDestroy(): void;
    hasConfig(): any;
    private setStylings;
    private isDashboardDefaultStyle;
    private setDefaultStyle;
    private composeWidgetConfig;
    private applyTargetIfDeviceDashboard;
    static ɵfac: i0.ɵɵFactoryDeclaration<WidgetConfigComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<WidgetConfigComponent, "c8y-widget-config", never, {}, {}, never, never, false, never>;
}
