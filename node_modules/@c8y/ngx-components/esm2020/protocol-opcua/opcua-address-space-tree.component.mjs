import { Component, Input, Output, EventEmitter } from '@angular/core';
import { AddressSpaceService } from './address-space.service';
import { OpcuaService } from './opcuaService';
import { AlertService } from '@c8y/ngx-components';
import { DynamicDataSource } from './dynamic-data-source';
import { NestedTreeControl } from '@angular/cdk/tree';
import { clone } from 'lodash';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./address-space.service";
import * as i2 from "./opcuaService";
import * as i3 from "@c8y/ngx-components";
import * as i4 from "@angular/common";
import * as i5 from "@angular/cdk/tree";
export class OpcuaAddressSpaceTreeComponent {
    set moId(id) {
        this._moId = id || undefined;
    }
    constructor(addressSpaceService, opcuaService, alertService) {
        this.addressSpaceService = addressSpaceService;
        this.opcuaService = opcuaService;
        this.alertService = alertService;
        this.focusEmitter = new EventEmitter();
        this.selectedNode = new EventEmitter();
        this.dataSource = null;
        this.loading = false;
        this.destroy$ = new Subject();
        this.getChildren = (node) => (node.expanded ? node.children : []);
        this.hasChild = (_, _nodeData) => this.addressSpaceService.childrenAvailable(_nodeData.references);
    }
    ngOnInit() {
        this.initializeDataSet();
    }
    ngOnChanges(changes) {
        if (changes.moId &&
            changes.moId.previousValue &&
            changes.moId.currentValue !== changes.moId.previousValue) {
            this.initializeDataSet();
        }
    }
    initializeDataSet() {
        this.nodeNavDataSubscription = this.addressSpaceService
            .getNodeNavData$()
            .pipe(takeUntil(this.destroy$))
            .subscribe(nodeNavData => this.openNode(nodeNavData));
        this.subscriptionRef = this.focusEmitter.subscribe(node => {
            this.focused = this.isFocusedNode(node) ? undefined : node;
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        // clean up the address-space-tree
        this.addressSpaceService.resetTreeToRootNode();
        if (this.nodeNavDataSubscription && !this.nodeNavDataSubscription.closed) {
            this.nodeNavDataSubscription.unsubscribe();
        }
        if (this.subscriptionRef && !this.subscriptionRef.closed) {
            this.subscriptionRef.unsubscribe();
        }
    }
    async openNode(nodeNavData) {
        const { node, selectedAncestorIds } = nodeNavData;
        let nodeId;
        // We just set the nodeId when the selectedAncestorIds variable an empty array.
        // If selectedAncestorIds contain any id we assume that the tree should be travsersed beginning
        // from the root node.
        if (node && node.nodeId && selectedAncestorIds && selectedAncestorIds.length === 0) {
            nodeId = node.nodeId;
        }
        // Always recreate the tree when routing to a specific nested node,
        // because previous modifications to the tree-structure could cause errors
        // while traversing with 'old' tree-data
        // -----------------
        // setupTree is able to handle nodeId = undefined
        await this.setupTree(nodeId);
        if (!selectedAncestorIds || selectedAncestorIds.length === 0) {
            return;
        }
        if (nodeNavData && this.dataSource) {
            const clonedAncestors = clone(selectedAncestorIds);
            clonedAncestors.shift();
            const n = await this.dataSource.toggleNode(this.dataSource.data[0], true);
            this.setChildNodes(n.children, clonedAncestors);
            this.toggleFocusedNode(node);
        }
    }
    setChildNodes(nodes, ids) {
        if (nodes) {
            ids.forEach(async (id) => {
                const match = nodes.find(n => n.nodeId === id);
                if (match && ids.length > 0) {
                    const idx = ids.findIndex(value => value === id);
                    if (idx >= 0) {
                        ids.splice(idx, 1);
                    }
                    const toggledNode = await this.dataSource.toggleNode(match, true);
                    this.setChildNodes(toggledNode.children, ids);
                }
            });
        }
    }
    async setupTree(nodeId) {
        this.loading = true;
        if (!this._moId || this._moId.length === 0) {
            this._moId = this.opcuaService.getMoId();
        }
        // addressSpaceService.getNode returns either the root node of the server (moId)
        // or if nodeId !== undefined the node with given nodeId
        const res = await this.addressSpaceService.getNode(this._moId, nodeId);
        if (res) {
            if (res.status !== 200) {
                const data = res.json ? await res.json() : undefined;
                this.alertService.addServerFailure({ data, res });
                this.dataSource = undefined;
            }
            else {
                const rootNode = (await res.json());
                this.nestedTreeControl = new NestedTreeControl(this.getChildren);
                this.dataSource = new DynamicDataSource(this.nestedTreeControl, this.addressSpaceService, this._moId);
                this.dataSource.data = [rootNode];
            }
            this.loading = false;
        }
        else {
            this.loading = false;
        }
    }
    getMoId() {
        if (!this._moId || this._moId.length === 0) {
            return this.opcuaService.getMoId();
        }
        return this._moId;
    }
    getIcon(nodeClassName) {
        return this.addressSpaceService.getIcon(nodeClassName);
    }
    toggleFocusedNode(node) {
        const relativePath = [];
        this.getRelativePath(node, relativePath);
        node.relativePath = relativePath;
        this.selectedNode.emit(node);
        this.focused = this.isFocusedNode(node) ? undefined : node;
    }
    isFocusedNode(node) {
        if (this.focused) {
            return node.nodeId === this.focused.nodeId;
        }
        return false;
    }
    getRelativePath(node, relativePath) {
        if (node.parentNode) {
            relativePath.unshift(node.browseName);
            this.getRelativePath(node.parentNode, relativePath);
        }
    }
}
OpcuaAddressSpaceTreeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: OpcuaAddressSpaceTreeComponent, deps: [{ token: i1.AddressSpaceService }, { token: i2.OpcuaService }, { token: i3.AlertService }], target: i0.ɵɵFactoryTarget.Component });
OpcuaAddressSpaceTreeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: OpcuaAddressSpaceTreeComponent, selector: "opcua-address-space-tree", inputs: { moId: "moId", node: "node", focusEmitter: "focusEmitter" }, outputs: { selectedNode: "selectedNode" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"card-block\" *ngIf=\"dataSource && !loading\">\n  <cdk-tree [dataSource]=\"dataSource\" [treeControl]=\"nestedTreeControl\">\n    <!-- This is the tree node template for leaf nodes -->\n    <cdk-nested-tree-node\n      *cdkTreeNodeDef=\"let node\"\n      (click)=\"toggleFocusedNode(node)\"\n      [ngClass]=\"{ strong: isFocusedNode(node) }\"\n      class=\"interact\"\n    >\n      <span>\n        <i\n          class=\"m-r-4 interact\"\n          [c8yIcon]=\"getIcon(node.nodeClassName)\"\n          [ngClass]=\"{ strong: isFocusedNode(node) }\"\n        ></i>\n        {{ node.displayName }}\n      </span>\n    </cdk-nested-tree-node>\n    <!-- This is the tree node template for expandable nodes -->\n    <cdk-nested-tree-node *cdkTreeNodeDef=\"let node; when: hasChild\">\n      <div class=\"d-flex\">\n        <button\n          cdkTreeNodeToggle\n          title=\"{{ 'Expand node' | translate }}\"\n          class=\"btn-clean text-primary m-r-4\"\n          [disabled]=\"node.currentlyLoadingChildren\"\n        >\n          <i\n            [ngClass]=\"{\n              'dlt-c8y-icon-plus-square': !node.expanded,\n              'dlt-c8y-icon-minus-square': node.expanded\n            }\"\n          ></i>\n        </button>\n        <i class=\"m-r-4 interact\" [c8yIcon]=\"getIcon(node.nodeClassName)\"></i>\n        <span\n          (click)=\"toggleFocusedNode(node)\"\n          [ngClass]=\"{ strong: isFocusedNode(node) }\"\n          class=\"interact\"\n        >\n          {{ node.displayName }}\n        </span>\n        <span\n          class=\"m-l-4\"\n          [style.visibility]=\"node.currentlyLoadingChildren ? 'visible' : 'hidden'\"\n        >\n          <i class=\"dlt-c8y-icon-circle-o-notch icon-spin\"></i>\n        </span>\n      </div>\n      <ng-container cdkTreeNodeOutlet></ng-container>\n    </cdk-nested-tree-node>\n  </cdk-tree>\n</div>\n<div class=\"p-t-8\" *ngIf=\"loading\">\n  <c8y-loading></c8y-loading>\n</div>\n<div class=\"alert alert-info m-t-16\" *ngIf=\"!dataSource && !loading\" translate>\n  No source data available to fetch address space.\n</div>\n", dependencies: [{ kind: "directive", type: i3.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i3.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i4.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.LoadingComponent, selector: "c8y-loading" }, { kind: "directive", type: i5.CdkNestedTreeNode, selector: "cdk-nested-tree-node", inputs: ["role", "disabled", "tabIndex"], exportAs: ["cdkNestedTreeNode"] }, { kind: "directive", type: i5.CdkTreeNodeDef, selector: "[cdkTreeNodeDef]", inputs: ["cdkTreeNodeDefWhen"] }, { kind: "directive", type: i5.CdkTreeNodeToggle, selector: "[cdkTreeNodeToggle]", inputs: ["cdkTreeNodeToggleRecursive"] }, { kind: "component", type: i5.CdkTree, selector: "cdk-tree", inputs: ["dataSource", "treeControl", "trackBy"], exportAs: ["cdkTree"] }, { kind: "directive", type: i5.CdkTreeNodeOutlet, selector: "[cdkTreeNodeOutlet]" }, { kind: "pipe", type: i3.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: OpcuaAddressSpaceTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'opcua-address-space-tree', template: "<div class=\"card-block\" *ngIf=\"dataSource && !loading\">\n  <cdk-tree [dataSource]=\"dataSource\" [treeControl]=\"nestedTreeControl\">\n    <!-- This is the tree node template for leaf nodes -->\n    <cdk-nested-tree-node\n      *cdkTreeNodeDef=\"let node\"\n      (click)=\"toggleFocusedNode(node)\"\n      [ngClass]=\"{ strong: isFocusedNode(node) }\"\n      class=\"interact\"\n    >\n      <span>\n        <i\n          class=\"m-r-4 interact\"\n          [c8yIcon]=\"getIcon(node.nodeClassName)\"\n          [ngClass]=\"{ strong: isFocusedNode(node) }\"\n        ></i>\n        {{ node.displayName }}\n      </span>\n    </cdk-nested-tree-node>\n    <!-- This is the tree node template for expandable nodes -->\n    <cdk-nested-tree-node *cdkTreeNodeDef=\"let node; when: hasChild\">\n      <div class=\"d-flex\">\n        <button\n          cdkTreeNodeToggle\n          title=\"{{ 'Expand node' | translate }}\"\n          class=\"btn-clean text-primary m-r-4\"\n          [disabled]=\"node.currentlyLoadingChildren\"\n        >\n          <i\n            [ngClass]=\"{\n              'dlt-c8y-icon-plus-square': !node.expanded,\n              'dlt-c8y-icon-minus-square': node.expanded\n            }\"\n          ></i>\n        </button>\n        <i class=\"m-r-4 interact\" [c8yIcon]=\"getIcon(node.nodeClassName)\"></i>\n        <span\n          (click)=\"toggleFocusedNode(node)\"\n          [ngClass]=\"{ strong: isFocusedNode(node) }\"\n          class=\"interact\"\n        >\n          {{ node.displayName }}\n        </span>\n        <span\n          class=\"m-l-4\"\n          [style.visibility]=\"node.currentlyLoadingChildren ? 'visible' : 'hidden'\"\n        >\n          <i class=\"dlt-c8y-icon-circle-o-notch icon-spin\"></i>\n        </span>\n      </div>\n      <ng-container cdkTreeNodeOutlet></ng-container>\n    </cdk-nested-tree-node>\n  </cdk-tree>\n</div>\n<div class=\"p-t-8\" *ngIf=\"loading\">\n  <c8y-loading></c8y-loading>\n</div>\n<div class=\"alert alert-info m-t-16\" *ngIf=\"!dataSource && !loading\" translate>\n  No source data available to fetch address space.\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.AddressSpaceService }, { type: i2.OpcuaService }, { type: i3.AlertService }]; }, propDecorators: { moId: [{
                type: Input
            }], node: [{
                type: Input
            }], focusEmitter: [{
                type: Input
            }], selectedNode: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BjdWEtYWRkcmVzcy1zcGFjZS10cmVlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Byb3RvY29sLW9wY3VhL29wY3VhLWFkZHJlc3Mtc3BhY2UtdHJlZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi9wcm90b2NvbC1vcGN1YS9vcGN1YS1hZGRyZXNzLXNwYWNlLXRyZWUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUVOLFlBQVksRUFJYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQW9CLG1CQUFtQixFQUFzQixNQUFNLHlCQUF5QixDQUFDO0FBQ3BHLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDbkQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUMvQixPQUFPLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7QUFNM0MsTUFBTSxPQUFPLDhCQUE4QjtJQUN6QyxJQUNJLElBQUksQ0FBQyxFQUFVO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxJQUFJLFNBQVMsQ0FBQztJQUMvQixDQUFDO0lBY0QsWUFDVSxtQkFBd0MsRUFDeEMsWUFBMEIsRUFDMUIsWUFBMEI7UUFGMUIsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4QyxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQixpQkFBWSxHQUFaLFlBQVksQ0FBYztR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SSxDQUFDLE9BQU8sRUFBRTtZQUNoQixPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7U0FDNUM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFTyxlQUFlLENBQUMsSUFBc0IsRUFBRSxZQUFzQjtRQUNwRSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbkIsWUFBWSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ3JEO0lBQ0gsQ0FBQzs7MkhBbExVLDhCQUE4QjsrR0FBOUIsOEJBQThCLHNNQ3ZCM0MscWtFQTJEQTsyRkRwQ2EsOEJBQThCO2tCQUoxQyxTQUFTOytCQUNFLDBCQUEwQjtnS0FLaEMsSUFBSTtzQkFEUCxLQUFLO2dCQUtHLElBQUk7c0JBQVosS0FBSztnQkFDRyxZQUFZO3NCQUFwQixLQUFLO2dCQUNJLFlBQVk7c0JBQXJCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIE9uSW5pdCxcbiAgRXZlbnRFbWl0dGVyLFxuICBPbkRlc3Ryb3ksXG4gIE9uQ2hhbmdlcyxcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFkZHJlc3NTcGFjZU5vZGUsIEFkZHJlc3NTcGFjZVNlcnZpY2UsIE5vZGVOYXZpZ2F0aW9uRGF0YSB9IGZyb20gJy4vYWRkcmVzcy1zcGFjZS5zZXJ2aWNlJztcbmltcG9ydCB7IE9wY3VhU2VydmljZSB9IGZyb20gJy4vb3BjdWFTZXJ2aWNlJztcbmltcG9ydCB7IEFsZXJ0U2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgRHluYW1pY0RhdGFTb3VyY2UgfSBmcm9tICcuL2R5bmFtaWMtZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHsgTmVzdGVkVHJlZUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9jZGsvdHJlZSc7XG5pbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnb3BjdWEtYWRkcmVzcy1zcGFjZS10cmVlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL29wY3VhLWFkZHJlc3Mtc3BhY2UtdHJlZS5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgT3BjdWFBZGRyZXNzU3BhY2VUcmVlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpXG4gIHNldCBtb0lkKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9tb0lkID0gaWQgfHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgQElucHV0KCkgbm9kZTtcbiAgQElucHV0KCkgZm9jdXNFbWl0dGVyOiBFdmVudEVtaXR0ZXI8QWRkcmVzc1NwYWNlTm9kZT4gPSBuZXcgRXZlbnRFbWl0dGVyPEFkZHJlc3NTcGFjZU5vZGU+KCk7XG4gIEBPdXRwdXQoKSBzZWxlY3RlZE5vZGU6IEV2ZW50RW1pdHRlcjxBZGRyZXNzU3BhY2VOb2RlPiA9IG5ldyBFdmVudEVtaXR0ZXI8QWRkcmVzc1NwYWNlTm9kZT4oKTtcbiAgbmVzdGVkVHJlZUNvbnRyb2w6IE5lc3RlZFRyZWVDb250cm9sPEFkZHJlc3NTcGFjZU5vZGU+O1xuICBkYXRhU291cmNlOiBEeW5hbWljRGF0YVNvdXJjZSA9IG51bGw7XG4gIGZvY3VzZWQ6IEFkZHJlc3NTcGFjZU5vZGU7XG4gIGxvYWRpbmcgPSBmYWxzZTtcbiAgc3Vic2NyaXB0aW9uUmVmOiBTdWJzY3JpcHRpb247XG4gIG5vZGVOYXZEYXRhU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX21vSWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBkZXN0cm95JDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgYWRkcmVzc1NwYWNlU2VydmljZTogQWRkcmVzc1NwYWNlU2VydmljZSxcbiAgICBwcml2YXRlIG9wY3VhU2VydmljZTogT3BjdWFTZXJ2aWNlLFxuICAgIHByaXZhdGUgYWxlcnRTZXJ2aWNlOiBBbGVydFNlcnZpY2VcbiAgKSB7fVxuXG4gIGdldENoaWxkcmVuID0gKG5vZGU6IEFkZHJlc3NTcGFjZU5vZGUpID0+IChub2RlLmV4cGFuZGVkID8gbm9kZS5jaGlsZHJlbiA6IFtdKTtcbiAgaGFzQ2hpbGQgPSAoXzogbnVtYmVyLCBfbm9kZURhdGE6IEFkZHJlc3NTcGFjZU5vZGUpID0+XG4gICAgdGhpcy5hZGRyZXNzU3BhY2VTZXJ2aWNlLmNoaWxkcmVuQXZhaWxhYmxlKF9ub2RlRGF0YS5yZWZlcmVuY2VzKTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVEYXRhU2V0KCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKFxuICAgICAgY2hhbmdlcy5tb0lkICYmXG4gICAgICBjaGFuZ2VzLm1vSWQucHJldmlvdXNWYWx1ZSAmJlxuICAgICAgY2hhbmdlcy5tb0lkLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5tb0lkLnByZXZpb3VzVmFsdWVcbiAgICApIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZURhdGFTZXQoKTtcbiAgICB9XG4gIH1cblxuICBpbml0aWFsaXplRGF0YVNldCgpIHtcbiAgICB0aGlzLm5vZGVOYXZEYXRhU3Vic2NyaXB0aW9uID0gdGhpcy5hZGRyZXNzU3BhY2VTZXJ2aWNlXG4gICAgICAuZ2V0Tm9kZU5hdkRhdGEkKClcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgIC5zdWJzY3JpYmUobm9kZU5hdkRhdGEgPT4gdGhpcy5vcGVuTm9kZShub2RlTmF2RGF0YSkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uUmVmID0gdGhpcy5mb2N1c0VtaXR0ZXIuc3Vic2NyaWJlKG5vZGUgPT4ge1xuICAgICAgdGhpcy5mb2N1c2VkID0gdGhpcy5pc0ZvY3VzZWROb2RlKG5vZGUpID8gdW5kZWZpbmVkIDogbm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICAvLyBjbGVhbiB1cCB0aGUgYWRkcmVzcy1zcGFjZS10cmVlXG4gICAgdGhpcy5hZGRyZXNzU3BhY2VTZXJ2aWNlLnJlc2V0VHJlZVRvUm9vdE5vZGUoKTtcblxuICAgIGlmICh0aGlzLm5vZGVOYXZEYXRhU3Vic2NyaXB0aW9uICYmICF0aGlzLm5vZGVOYXZEYXRhU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgdGhpcy5ub2RlTmF2RGF0YVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvblJlZiAmJiAhdGhpcy5zdWJzY3JpcHRpb25SZWYuY2xvc2VkKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvblJlZi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG9wZW5Ob2RlKG5vZGVOYXZEYXRhOiBOb2RlTmF2aWdhdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IG5vZGUsIHNlbGVjdGVkQW5jZXN0b3JJZHMgfSA9IG5vZGVOYXZEYXRhO1xuICAgIGxldCBub2RlSWQ7XG5cbiAgICAvLyBXZSBqdXN0IHNldCB0aGUgbm9kZUlkIHdoZW4gdGhlIHNlbGVjdGVkQW5jZXN0b3JJZHMgdmFyaWFibGUgYW4gZW1wdHkgYXJyYXkuXG4gICAgLy8gSWYgc2VsZWN0ZWRBbmNlc3RvcklkcyBjb250YWluIGFueSBpZCB3ZSBhc3N1bWUgdGhhdCB0aGUgdHJlZSBzaG91bGQgYmUgdHJhdnNlcnNlZCBiZWdpbm5pbmdcbiAgICAvLyBmcm9tIHRoZSByb290IG5vZGUuXG4gICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlSWQgJiYgc2VsZWN0ZWRBbmNlc3RvcklkcyAmJiBzZWxlY3RlZEFuY2VzdG9ySWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbm9kZUlkID0gbm9kZS5ub2RlSWQ7XG4gICAgfVxuICAgIC8vIEFsd2F5cyByZWNyZWF0ZSB0aGUgdHJlZSB3aGVuIHJvdXRpbmcgdG8gYSBzcGVjaWZpYyBuZXN0ZWQgbm9kZSxcbiAgICAvLyBiZWNhdXNlIHByZXZpb3VzIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHRyZWUtc3RydWN0dXJlIGNvdWxkIGNhdXNlIGVycm9yc1xuICAgIC8vIHdoaWxlIHRyYXZlcnNpbmcgd2l0aCAnb2xkJyB0cmVlLWRhdGFcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNldHVwVHJlZSBpcyBhYmxlIHRvIGhhbmRsZSBub2RlSWQgPSB1bmRlZmluZWRcbiAgICBhd2FpdCB0aGlzLnNldHVwVHJlZShub2RlSWQpO1xuXG4gICAgaWYgKCFzZWxlY3RlZEFuY2VzdG9ySWRzIHx8IHNlbGVjdGVkQW5jZXN0b3JJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGVOYXZEYXRhICYmIHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgY29uc3QgY2xvbmVkQW5jZXN0b3JzID0gY2xvbmUoc2VsZWN0ZWRBbmNlc3Rvcklkcyk7XG4gICAgICBjbG9uZWRBbmNlc3RvcnMuc2hpZnQoKTtcblxuICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuZGF0YVNvdXJjZS50b2dnbGVOb2RlKHRoaXMuZGF0YVNvdXJjZS5kYXRhWzBdLCB0cnVlKTtcbiAgICAgIHRoaXMuc2V0Q2hpbGROb2RlcyhuLmNoaWxkcmVuLCBjbG9uZWRBbmNlc3RvcnMpO1xuXG4gICAgICB0aGlzLnRvZ2dsZUZvY3VzZWROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHNldENoaWxkTm9kZXMobm9kZXM6IEFkZHJlc3NTcGFjZU5vZGVbXSwgaWRzOiBzdHJpbmdbXSkge1xuICAgIGlmIChub2Rlcykge1xuICAgICAgaWRzLmZvckVhY2goYXN5bmMgaWQgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IG5vZGVzLmZpbmQobiA9PiBuLm5vZGVJZCA9PT0gaWQpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpZHggPSBpZHMuZmluZEluZGV4KHZhbHVlID0+IHZhbHVlID09PSBpZCk7XG4gICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBpZHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRvZ2dsZWROb2RlID0gYXdhaXQgdGhpcy5kYXRhU291cmNlLnRvZ2dsZU5vZGUobWF0Y2gsIHRydWUpO1xuICAgICAgICAgIHRoaXMuc2V0Q2hpbGROb2Rlcyh0b2dnbGVkTm9kZS5jaGlsZHJlbiwgaWRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2V0dXBUcmVlKG5vZGVJZD86IHN0cmluZykge1xuICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuX21vSWQgfHwgdGhpcy5fbW9JZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX21vSWQgPSB0aGlzLm9wY3VhU2VydmljZS5nZXRNb0lkKCk7XG4gICAgfVxuXG4gICAgLy8gYWRkcmVzc1NwYWNlU2VydmljZS5nZXROb2RlIHJldHVybnMgZWl0aGVyIHRoZSByb290IG5vZGUgb2YgdGhlIHNlcnZlciAobW9JZClcbiAgICAvLyBvciBpZiBub2RlSWQgIT09IHVuZGVmaW5lZCB0aGUgbm9kZSB3aXRoIGdpdmVuIG5vZGVJZFxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuYWRkcmVzc1NwYWNlU2VydmljZS5nZXROb2RlKHRoaXMuX21vSWQsIG5vZGVJZCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcmVzLmpzb24gPyBhd2FpdCByZXMuanNvbigpIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFsZXJ0U2VydmljZS5hZGRTZXJ2ZXJGYWlsdXJlKHsgZGF0YSwgcmVzIH0pO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IChhd2FpdCByZXMuanNvbigpKSBhcyBBZGRyZXNzU3BhY2VOb2RlO1xuICAgICAgICB0aGlzLm5lc3RlZFRyZWVDb250cm9sID0gbmV3IE5lc3RlZFRyZWVDb250cm9sPEFkZHJlc3NTcGFjZU5vZGU+KHRoaXMuZ2V0Q2hpbGRyZW4pO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBuZXcgRHluYW1pY0RhdGFTb3VyY2UoXG4gICAgICAgICAgdGhpcy5uZXN0ZWRUcmVlQ29udHJvbCxcbiAgICAgICAgICB0aGlzLmFkZHJlc3NTcGFjZVNlcnZpY2UsXG4gICAgICAgICAgdGhpcy5fbW9JZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IFtyb290Tm9kZV07XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZ2V0TW9JZCgpIHtcbiAgICBpZiAoIXRoaXMuX21vSWQgfHwgdGhpcy5fbW9JZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLm9wY3VhU2VydmljZS5nZXRNb0lkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tb0lkO1xuICB9XG5cbiAgZ2V0SWNvbihub2RlQ2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc1NwYWNlU2VydmljZS5nZXRJY29uKG5vZGVDbGFzc05hbWUpO1xuICB9XG5cbiAgdG9nZ2xlRm9jdXNlZE5vZGUobm9kZSkge1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IFtdO1xuICAgIHRoaXMuZ2V0UmVsYXRpdmVQYXRoKG5vZGUsIHJlbGF0aXZlUGF0aCk7XG4gICAgbm9kZS5yZWxhdGl2ZVBhdGggPSByZWxhdGl2ZVBhdGg7XG5cbiAgICB0aGlzLnNlbGVjdGVkTm9kZS5lbWl0KG5vZGUpO1xuICAgIHRoaXMuZm9jdXNlZCA9IHRoaXMuaXNGb2N1c2VkTm9kZShub2RlKSA/IHVuZGVmaW5lZCA6IG5vZGU7XG4gIH1cblxuICBpc0ZvY3VzZWROb2RlKG5vZGU6IEFkZHJlc3NTcGFjZU5vZGUpIHtcbiAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlSWQgPT09IHRoaXMuZm9jdXNlZC5ub2RlSWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmVsYXRpdmVQYXRoKG5vZGU6IEFkZHJlc3NTcGFjZU5vZGUsIHJlbGF0aXZlUGF0aDogc3RyaW5nW10pIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICByZWxhdGl2ZVBhdGgudW5zaGlmdChub2RlLmJyb3dzZU5hbWUpO1xuICAgICAgdGhpcy5nZXRSZWxhdGl2ZVBhdGgobm9kZS5wYXJlbnROb2RlLCByZWxhdGl2ZVBhdGgpO1xuICAgIH1cbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cImNhcmQtYmxvY2tcIiAqbmdJZj1cImRhdGFTb3VyY2UgJiYgIWxvYWRpbmdcIj5cbiAgPGNkay10cmVlIFtkYXRhU291cmNlXT1cImRhdGFTb3VyY2VcIiBbdHJlZUNvbnRyb2xdPVwibmVzdGVkVHJlZUNvbnRyb2xcIj5cbiAgICA8IS0tIFRoaXMgaXMgdGhlIHRyZWUgbm9kZSB0ZW1wbGF0ZSBmb3IgbGVhZiBub2RlcyAtLT5cbiAgICA8Y2RrLW5lc3RlZC10cmVlLW5vZGVcbiAgICAgICpjZGtUcmVlTm9kZURlZj1cImxldCBub2RlXCJcbiAgICAgIChjbGljayk9XCJ0b2dnbGVGb2N1c2VkTm9kZShub2RlKVwiXG4gICAgICBbbmdDbGFzc109XCJ7IHN0cm9uZzogaXNGb2N1c2VkTm9kZShub2RlKSB9XCJcbiAgICAgIGNsYXNzPVwiaW50ZXJhY3RcIlxuICAgID5cbiAgICAgIDxzcGFuPlxuICAgICAgICA8aVxuICAgICAgICAgIGNsYXNzPVwibS1yLTQgaW50ZXJhY3RcIlxuICAgICAgICAgIFtjOHlJY29uXT1cImdldEljb24obm9kZS5ub2RlQ2xhc3NOYW1lKVwiXG4gICAgICAgICAgW25nQ2xhc3NdPVwieyBzdHJvbmc6IGlzRm9jdXNlZE5vZGUobm9kZSkgfVwiXG4gICAgICAgID48L2k+XG4gICAgICAgIHt7IG5vZGUuZGlzcGxheU5hbWUgfX1cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Nkay1uZXN0ZWQtdHJlZS1ub2RlPlxuICAgIDwhLS0gVGhpcyBpcyB0aGUgdHJlZSBub2RlIHRlbXBsYXRlIGZvciBleHBhbmRhYmxlIG5vZGVzIC0tPlxuICAgIDxjZGstbmVzdGVkLXRyZWUtbm9kZSAqY2RrVHJlZU5vZGVEZWY9XCJsZXQgbm9kZTsgd2hlbjogaGFzQ2hpbGRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJkLWZsZXhcIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNka1RyZWVOb2RlVG9nZ2xlXG4gICAgICAgICAgdGl0bGU9XCJ7eyAnRXhwYW5kIG5vZGUnIHwgdHJhbnNsYXRlIH19XCJcbiAgICAgICAgICBjbGFzcz1cImJ0bi1jbGVhbiB0ZXh0LXByaW1hcnkgbS1yLTRcIlxuICAgICAgICAgIFtkaXNhYmxlZF09XCJub2RlLmN1cnJlbnRseUxvYWRpbmdDaGlsZHJlblwiXG4gICAgICAgID5cbiAgICAgICAgICA8aVxuICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xuICAgICAgICAgICAgICAnZGx0LWM4eS1pY29uLXBsdXMtc3F1YXJlJzogIW5vZGUuZXhwYW5kZWQsXG4gICAgICAgICAgICAgICdkbHQtYzh5LWljb24tbWludXMtc3F1YXJlJzogbm9kZS5leHBhbmRlZFxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgPjwvaT5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxpIGNsYXNzPVwibS1yLTQgaW50ZXJhY3RcIiBbYzh5SWNvbl09XCJnZXRJY29uKG5vZGUubm9kZUNsYXNzTmFtZSlcIj48L2k+XG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUZvY3VzZWROb2RlKG5vZGUpXCJcbiAgICAgICAgICBbbmdDbGFzc109XCJ7IHN0cm9uZzogaXNGb2N1c2VkTm9kZShub2RlKSB9XCJcbiAgICAgICAgICBjbGFzcz1cImludGVyYWN0XCJcbiAgICAgICAgPlxuICAgICAgICAgIHt7IG5vZGUuZGlzcGxheU5hbWUgfX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3BhblxuICAgICAgICAgIGNsYXNzPVwibS1sLTRcIlxuICAgICAgICAgIFtzdHlsZS52aXNpYmlsaXR5XT1cIm5vZGUuY3VycmVudGx5TG9hZGluZ0NoaWxkcmVuID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcIlxuICAgICAgICA+XG4gICAgICAgICAgPGkgY2xhc3M9XCJkbHQtYzh5LWljb24tY2lyY2xlLW8tbm90Y2ggaWNvbi1zcGluXCI+PC9pPlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxuZy1jb250YWluZXIgY2RrVHJlZU5vZGVPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gICAgPC9jZGstbmVzdGVkLXRyZWUtbm9kZT5cbiAgPC9jZGstdHJlZT5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cInAtdC04XCIgKm5nSWY9XCJsb2FkaW5nXCI+XG4gIDxjOHktbG9hZGluZz48L2M4eS1sb2FkaW5nPlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtaW5mbyBtLXQtMTZcIiAqbmdJZj1cIiFkYXRhU291cmNlICYmICFsb2FkaW5nXCIgdHJhbnNsYXRlPlxuICBObyBzb3VyY2UgZGF0YSBhdmFpbGFibGUgdG8gZmV0Y2ggYWRkcmVzcyBzcGFjZS5cbjwvZGl2PlxuIl19