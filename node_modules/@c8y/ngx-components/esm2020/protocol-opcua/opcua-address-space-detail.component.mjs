import { Component, Input, Output, EventEmitter } from '@angular/core';
import { AddressSpaceService } from './address-space.service';
import { omit } from 'lodash-es';
import * as i0 from "@angular/core";
import * as i1 from "./address-space.service";
import * as i2 from "@angular/common";
import * as i3 from "@c8y/ngx-components";
export class OpcuaAddressSpaceDetailComponent {
    set node(n) {
        this._node = n;
        if (n) {
            this.setNodeData(n);
        }
        else {
            // remove details from current view
            this.showDetails = false;
        }
    }
    constructor(addressSpaceService) {
        this.addressSpaceService = addressSpaceService;
        this.selected = false;
        this.showDetails = false;
        this.toggleAttrDetail = new EventEmitter();
    }
    setNodeData(nodeData) {
        this.showDetails = true;
        const { attributes, references } = nodeData;
        this.nodeDataRef = references;
        const omitList = [
            'attributes',
            'references',
            'children',
            'currentlyLoadingChildren',
            'expanded',
            'browsePath',
            'relativePath',
            'parentNode'
        ];
        this.nodeDataAttr = Object.assign({}, attributes, omit(nodeData, omitList));
    }
    toggleDetail(node) {
        this.showDetails = !this.showDetails;
        this.toggleAttrDetail.emit(node);
    }
    navigateTo(ancestors) {
        const nodeNavData = {
            node: this._node,
            selectedAncestorIds: ancestors
        };
        this.toggleDetail(this._node);
        this.addressSpaceService.triggerNodeToOpen(nodeNavData);
    }
}
OpcuaAddressSpaceDetailComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: OpcuaAddressSpaceDetailComponent, deps: [{ token: i1.AddressSpaceService }], target: i0.ɵɵFactoryTarget.Component });
OpcuaAddressSpaceDetailComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: OpcuaAddressSpaceDetailComponent, selector: "opcua-address-space-detail", inputs: { node: "node" }, outputs: { toggleAttrDetail: "toggleAttrDetail" }, ngImport: i0, template: "<div\n  class=\"card flex-scroll m-b-4 split-row-2 animated fast\"\n  style=\"pointer-events: all\"\n  [ngClass]=\"{ fadeInRightBig: showDetails, fadeOutRightBig: !showDetails }\"\n>\n  <div class=\"card-header separator \">\n    <h4>{{ 'Attributes' | translate }}</h4>\n    <button\n      class=\"close m-l-auto visible-sm visible-xs\"\n      title=\"{{ 'Close' | translate }}\"\n      (click)=\"toggleDetail(nodeDataAttr)\"\n    >\n      &times;\n    </button>\n  </div>\n  <div class=\"card-inner-scroll\">\n    <div class=\"card-block\">\n      <table class=\"table table-striped table-condensed\">\n        <colgroup>\n          <col width=\"50%\" />\n          <col width=\"50%\" />\n        </colgroup>\n        <thead>\n          <tr>\n            <th>{{ 'Attribute' | translate }}</th>\n            <th>{{ 'Value' | translate }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let item of nodeDataAttr | keyvalue\">\n            <td>{{ item.key }}</td>\n            <td *ngIf=\"item.key === 'absolutePaths'\" class=\"text-break-word\">\n              {{ item.value | json }}\n            </td>\n            <td *ngIf=\"item.key === 'ancestorNodeIds'\" class=\"text-break-word\">\n              <a *ngFor=\"let value of item.value\" (click)=\"navigateTo(value)\">\n                {{ value | json }}</a\n              >\n            </td>\n            <td *ngIf=\"item.key !== 'absolutePaths' && item.key !== 'ancestorNodeIds'\">\n              {{ item.value }}\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n<div\n  class=\"card flex-scroll split-row-2 animated fast\"\n  style=\"pointer-events: all\"\n  [ngClass]=\"{ fadeInRightBig: showDetails, fadeOutRightBig: !showDetails }\"\n>\n  <div class=\"card-header separator\">\n    <h4>{{ 'References' | translate }}</h4>\n  </div>\n  <div class=\"card-inner-scroll\">\n    <div class=\"card-block\">\n      <table class=\"table table-striped table-condensed\">\n        <colgroup>\n          <col width=\"50%\" />\n          <col width=\"50%\" />\n        </colgroup>\n        <thead>\n          <tr>\n            <th>{{ 'Attribute' | translate }}</th>\n            <th>{{ 'Value' | translate }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let item of nodeDataRef\">\n            <td>{{ item.referenceLabel }}</td>\n            <td class=\"text-break-word\">{{ item.targetLabel }}</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i2.JsonPipe, name: "json" }, { kind: "pipe", type: i2.KeyValuePipe, name: "keyvalue" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: OpcuaAddressSpaceDetailComponent, decorators: [{
            type: Component,
            args: [{ selector: 'opcua-address-space-detail', template: "<div\n  class=\"card flex-scroll m-b-4 split-row-2 animated fast\"\n  style=\"pointer-events: all\"\n  [ngClass]=\"{ fadeInRightBig: showDetails, fadeOutRightBig: !showDetails }\"\n>\n  <div class=\"card-header separator \">\n    <h4>{{ 'Attributes' | translate }}</h4>\n    <button\n      class=\"close m-l-auto visible-sm visible-xs\"\n      title=\"{{ 'Close' | translate }}\"\n      (click)=\"toggleDetail(nodeDataAttr)\"\n    >\n      &times;\n    </button>\n  </div>\n  <div class=\"card-inner-scroll\">\n    <div class=\"card-block\">\n      <table class=\"table table-striped table-condensed\">\n        <colgroup>\n          <col width=\"50%\" />\n          <col width=\"50%\" />\n        </colgroup>\n        <thead>\n          <tr>\n            <th>{{ 'Attribute' | translate }}</th>\n            <th>{{ 'Value' | translate }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let item of nodeDataAttr | keyvalue\">\n            <td>{{ item.key }}</td>\n            <td *ngIf=\"item.key === 'absolutePaths'\" class=\"text-break-word\">\n              {{ item.value | json }}\n            </td>\n            <td *ngIf=\"item.key === 'ancestorNodeIds'\" class=\"text-break-word\">\n              <a *ngFor=\"let value of item.value\" (click)=\"navigateTo(value)\">\n                {{ value | json }}</a\n              >\n            </td>\n            <td *ngIf=\"item.key !== 'absolutePaths' && item.key !== 'ancestorNodeIds'\">\n              {{ item.value }}\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n<div\n  class=\"card flex-scroll split-row-2 animated fast\"\n  style=\"pointer-events: all\"\n  [ngClass]=\"{ fadeInRightBig: showDetails, fadeOutRightBig: !showDetails }\"\n>\n  <div class=\"card-header separator\">\n    <h4>{{ 'References' | translate }}</h4>\n  </div>\n  <div class=\"card-inner-scroll\">\n    <div class=\"card-block\">\n      <table class=\"table table-striped table-condensed\">\n        <colgroup>\n          <col width=\"50%\" />\n          <col width=\"50%\" />\n        </colgroup>\n        <thead>\n          <tr>\n            <th>{{ 'Attribute' | translate }}</th>\n            <th>{{ 'Value' | translate }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let item of nodeDataRef\">\n            <td>{{ item.referenceLabel }}</td>\n            <td class=\"text-break-word\">{{ item.targetLabel }}</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.AddressSpaceService }]; }, propDecorators: { node: [{
                type: Input
            }], toggleAttrDetail: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BjdWEtYWRkcmVzcy1zcGFjZS1kZXRhaWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcHJvdG9jb2wtb3BjdWEvb3BjdWEtYWRkcmVzcy1zcGFjZS1kZXRhaWwuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vcHJvdG9jb2wtb3BjdWEvb3BjdWEtYWRkcmVzcy1zcGFjZS1kZXRhaWwuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN2RSxPQUFPLEVBQW9CLG1CQUFtQixFQUFzQixNQUFNLHlCQUF5QixDQUFDO0FBQ3BHLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxXQUFXLENBQUM7Ozs7O0FBTWpDLE1BQU0sT0FBTyxnQ0FBZ0M7SUFDM0MsSUFBYSxJQUFJLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxFQUFFO1lBQ0wsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQjthQUFNO1lBQ0wsbUNBQW1DO1lBQ25DLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQzFCO0lBQ0gsQ0FBQztJQVVELFlBQW9CLG1CQUF3QztRQUF4Qyx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBUDVELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsZ0JBQVcsR0FBRyxLQUFLLENBQUM7UUFFVixxQkFBZ0IsR0FBbUMsSUFBSSxZQUFZLEVBQW9CLENBQUM7SUFJbkMsQ0FBQztJQUNoRSxXQUFXLENBQUMsUUFBUTtRQUNsQixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUN4QixNQUFNLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxHQUFHLFFBQVEsQ0FBQztRQUM1QyxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQztRQUM5QixNQUFNLFFBQVEsR0FBRztZQUNmLFlBQVk7WUFDWixZQUFZO1lBQ1osVUFBVTtZQUNWLDBCQUEwQjtZQUMxQixVQUFVO1lBQ1YsWUFBWTtZQUNaLGNBQWM7WUFDZCxZQUFZO1NBQ2IsQ0FBQztRQUNGLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQsWUFBWSxDQUFDLElBQUk7UUFDZixJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNyQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCxVQUFVLENBQUMsU0FBbUI7UUFDNUIsTUFBTSxXQUFXLEdBQXVCO1lBQ3RDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSztZQUNoQixtQkFBbUIsRUFBRSxTQUFTO1NBQy9CLENBQUM7UUFFRixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDMUQsQ0FBQzs7NkhBbERVLGdDQUFnQztpSEFBaEMsZ0NBQWdDLCtJQ1I3Qyx5L0VBK0VBOzJGRHZFYSxnQ0FBZ0M7a0JBSjVDLFNBQVM7K0JBQ0UsNEJBQTRCOzBHQUl6QixJQUFJO3NCQUFoQixLQUFLO2dCQWNJLGdCQUFnQjtzQkFBekIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBZGRyZXNzU3BhY2VOb2RlLCBBZGRyZXNzU3BhY2VTZXJ2aWNlLCBOb2RlTmF2aWdhdGlvbkRhdGEgfSBmcm9tICcuL2FkZHJlc3Mtc3BhY2Uuc2VydmljZSc7XG5pbXBvcnQgeyBvbWl0IH0gZnJvbSAnbG9kYXNoLWVzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnb3BjdWEtYWRkcmVzcy1zcGFjZS1kZXRhaWwnLFxuICB0ZW1wbGF0ZVVybDogJy4vb3BjdWEtYWRkcmVzcy1zcGFjZS1kZXRhaWwuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIE9wY3VhQWRkcmVzc1NwYWNlRGV0YWlsQ29tcG9uZW50IHtcbiAgQElucHV0KCkgc2V0IG5vZGUobikge1xuICAgIHRoaXMuX25vZGUgPSBuO1xuICAgIGlmIChuKSB7XG4gICAgICB0aGlzLnNldE5vZGVEYXRhKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgZGV0YWlscyBmcm9tIGN1cnJlbnQgdmlld1xuICAgICAgdGhpcy5zaG93RGV0YWlscyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBub2RlRGF0YUF0dHI6IE1hcDxzdHJpbmcsIHN0cmluZz47XG4gIG5vZGVEYXRhUmVmOiBvYmplY3RbXTtcbiAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgc2hvd0RldGFpbHMgPSBmYWxzZTtcblxuICBAT3V0cHV0KCkgdG9nZ2xlQXR0ckRldGFpbDogRXZlbnRFbWl0dGVyPEFkZHJlc3NTcGFjZU5vZGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxBZGRyZXNzU3BhY2VOb2RlPigpO1xuXG4gIHByaXZhdGUgX25vZGU6IEFkZHJlc3NTcGFjZU5vZGU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhZGRyZXNzU3BhY2VTZXJ2aWNlOiBBZGRyZXNzU3BhY2VTZXJ2aWNlKSB7fVxuICBzZXROb2RlRGF0YShub2RlRGF0YSkge1xuICAgIHRoaXMuc2hvd0RldGFpbHMgPSB0cnVlO1xuICAgIGNvbnN0IHsgYXR0cmlidXRlcywgcmVmZXJlbmNlcyB9ID0gbm9kZURhdGE7XG4gICAgdGhpcy5ub2RlRGF0YVJlZiA9IHJlZmVyZW5jZXM7XG4gICAgY29uc3Qgb21pdExpc3QgPSBbXG4gICAgICAnYXR0cmlidXRlcycsXG4gICAgICAncmVmZXJlbmNlcycsXG4gICAgICAnY2hpbGRyZW4nLFxuICAgICAgJ2N1cnJlbnRseUxvYWRpbmdDaGlsZHJlbicsXG4gICAgICAnZXhwYW5kZWQnLFxuICAgICAgJ2Jyb3dzZVBhdGgnLFxuICAgICAgJ3JlbGF0aXZlUGF0aCcsXG4gICAgICAncGFyZW50Tm9kZSdcbiAgICBdO1xuICAgIHRoaXMubm9kZURhdGFBdHRyID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcywgb21pdChub2RlRGF0YSwgb21pdExpc3QpKTtcbiAgfVxuXG4gIHRvZ2dsZURldGFpbChub2RlKSB7XG4gICAgdGhpcy5zaG93RGV0YWlscyA9ICF0aGlzLnNob3dEZXRhaWxzO1xuICAgIHRoaXMudG9nZ2xlQXR0ckRldGFpbC5lbWl0KG5vZGUpO1xuICB9XG5cbiAgbmF2aWdhdGVUbyhhbmNlc3RvcnM6IHN0cmluZ1tdKSB7XG4gICAgY29uc3Qgbm9kZU5hdkRhdGE6IE5vZGVOYXZpZ2F0aW9uRGF0YSA9IHtcbiAgICAgIG5vZGU6IHRoaXMuX25vZGUsXG4gICAgICBzZWxlY3RlZEFuY2VzdG9ySWRzOiBhbmNlc3RvcnNcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVEZXRhaWwodGhpcy5fbm9kZSk7XG4gICAgdGhpcy5hZGRyZXNzU3BhY2VTZXJ2aWNlLnRyaWdnZXJOb2RlVG9PcGVuKG5vZGVOYXZEYXRhKTtcbiAgfVxufVxuIiwiPGRpdlxuICBjbGFzcz1cImNhcmQgZmxleC1zY3JvbGwgbS1iLTQgc3BsaXQtcm93LTIgYW5pbWF0ZWQgZmFzdFwiXG4gIHN0eWxlPVwicG9pbnRlci1ldmVudHM6IGFsbFwiXG4gIFtuZ0NsYXNzXT1cInsgZmFkZUluUmlnaHRCaWc6IHNob3dEZXRhaWxzLCBmYWRlT3V0UmlnaHRCaWc6ICFzaG93RGV0YWlscyB9XCJcbj5cbiAgPGRpdiBjbGFzcz1cImNhcmQtaGVhZGVyIHNlcGFyYXRvciBcIj5cbiAgICA8aDQ+e3sgJ0F0dHJpYnV0ZXMnIHwgdHJhbnNsYXRlIH19PC9oND5cbiAgICA8YnV0dG9uXG4gICAgICBjbGFzcz1cImNsb3NlIG0tbC1hdXRvIHZpc2libGUtc20gdmlzaWJsZS14c1wiXG4gICAgICB0aXRsZT1cInt7ICdDbG9zZScgfCB0cmFuc2xhdGUgfX1cIlxuICAgICAgKGNsaWNrKT1cInRvZ2dsZURldGFpbChub2RlRGF0YUF0dHIpXCJcbiAgICA+XG4gICAgICAmdGltZXM7XG4gICAgPC9idXR0b24+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiY2FyZC1pbm5lci1zY3JvbGxcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ibG9ja1wiPlxuICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcIj5cbiAgICAgICAgPGNvbGdyb3VwPlxuICAgICAgICAgIDxjb2wgd2lkdGg9XCI1MCVcIiAvPlxuICAgICAgICAgIDxjb2wgd2lkdGg9XCI1MCVcIiAvPlxuICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRoPnt7ICdBdHRyaWJ1dGUnIHwgdHJhbnNsYXRlIH19PC90aD5cbiAgICAgICAgICAgIDx0aD57eyAnVmFsdWUnIHwgdHJhbnNsYXRlIH19PC90aD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgPHRyICpuZ0Zvcj1cImxldCBpdGVtIG9mIG5vZGVEYXRhQXR0ciB8IGtleXZhbHVlXCI+XG4gICAgICAgICAgICA8dGQ+e3sgaXRlbS5rZXkgfX08L3RkPlxuICAgICAgICAgICAgPHRkICpuZ0lmPVwiaXRlbS5rZXkgPT09ICdhYnNvbHV0ZVBhdGhzJ1wiIGNsYXNzPVwidGV4dC1icmVhay13b3JkXCI+XG4gICAgICAgICAgICAgIHt7IGl0ZW0udmFsdWUgfCBqc29uIH19XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkICpuZ0lmPVwiaXRlbS5rZXkgPT09ICdhbmNlc3Rvck5vZGVJZHMnXCIgY2xhc3M9XCJ0ZXh0LWJyZWFrLXdvcmRcIj5cbiAgICAgICAgICAgICAgPGEgKm5nRm9yPVwibGV0IHZhbHVlIG9mIGl0ZW0udmFsdWVcIiAoY2xpY2spPVwibmF2aWdhdGVUbyh2YWx1ZSlcIj5cbiAgICAgICAgICAgICAgICB7eyB2YWx1ZSB8IGpzb24gfX08L2FcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZCAqbmdJZj1cIml0ZW0ua2V5ICE9PSAnYWJzb2x1dGVQYXRocycgJiYgaXRlbS5rZXkgIT09ICdhbmNlc3Rvck5vZGVJZHMnXCI+XG4gICAgICAgICAgICAgIHt7IGl0ZW0udmFsdWUgfX1cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG48ZGl2XG4gIGNsYXNzPVwiY2FyZCBmbGV4LXNjcm9sbCBzcGxpdC1yb3ctMiBhbmltYXRlZCBmYXN0XCJcbiAgc3R5bGU9XCJwb2ludGVyLWV2ZW50czogYWxsXCJcbiAgW25nQ2xhc3NdPVwieyBmYWRlSW5SaWdodEJpZzogc2hvd0RldGFpbHMsIGZhZGVPdXRSaWdodEJpZzogIXNob3dEZXRhaWxzIH1cIlxuPlxuICA8ZGl2IGNsYXNzPVwiY2FyZC1oZWFkZXIgc2VwYXJhdG9yXCI+XG4gICAgPGg0Pnt7ICdSZWZlcmVuY2VzJyB8IHRyYW5zbGF0ZSB9fTwvaDQ+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiY2FyZC1pbm5lci1zY3JvbGxcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ibG9ja1wiPlxuICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcIj5cbiAgICAgICAgPGNvbGdyb3VwPlxuICAgICAgICAgIDxjb2wgd2lkdGg9XCI1MCVcIiAvPlxuICAgICAgICAgIDxjb2wgd2lkdGg9XCI1MCVcIiAvPlxuICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRoPnt7ICdBdHRyaWJ1dGUnIHwgdHJhbnNsYXRlIH19PC90aD5cbiAgICAgICAgICAgIDx0aD57eyAnVmFsdWUnIHwgdHJhbnNsYXRlIH19PC90aD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgPHRyICpuZ0Zvcj1cImxldCBpdGVtIG9mIG5vZGVEYXRhUmVmXCI+XG4gICAgICAgICAgICA8dGQ+e3sgaXRlbS5yZWZlcmVuY2VMYWJlbCB9fTwvdGQ+XG4gICAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZXh0LWJyZWFrLXdvcmRcIj57eyBpdGVtLnRhcmdldExhYmVsIH19PC90ZD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbiJdfQ==