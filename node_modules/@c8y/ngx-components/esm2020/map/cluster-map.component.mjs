import { Component, EventEmitter, Inject, Input, IterableDiffers, Optional, Output, SimpleChange } from '@angular/core';
import { ColorService, ManagedObjectRealtimeService } from '@c8y/ngx-components';
import { TranslateService } from '@ngx-translate/core';
import { BehaviorSubject, from, fromEvent, interval, merge, NEVER, of, Subject } from 'rxjs';
import { debounceTime, filter, first, map, mergeMap, switchMap, takeUntil, tap } from 'rxjs/operators';
import { ClusterMap } from './cluster-map';
import { MapComponent } from './map.component';
import { ClusterSize, defaultLayer, defaultMapConfig, MAP_DEFAULT_CONFIG, MAP_TILE_LAYER } from './map.model';
import { MapService } from './map.service';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/ngx-components";
import * as i2 from "./map.service";
import * as i3 from "@ngx-translate/core";
export class ClusterMapComponent extends MapComponent {
    constructor(moRealtimeService, mapService, layers, defaultConfig, translateService, iterable, colorService) {
        super(moRealtimeService, mapService, layers, defaultConfig, translateService);
        this.moRealtimeService = moRealtimeService;
        this.mapService = mapService;
        this.layers = layers;
        this.defaultConfig = defaultConfig;
        this.translateService = translateService;
        this.iterable = iterable;
        this.colorService = colorService;
        this.isLoading$ = new BehaviorSubject(false);
        this.msUntilRefresh$ = new BehaviorSubject(5000);
        this.showClusterColor = false;
        this.mapChange = new EventEmitter();
        this.reloadTrigger$ = new BehaviorSubject(false);
        this.clusters = [];
        this.MIN_INTERVAL = 5000;
        this.EVENT_THROTTLE_TIME = 750;
        if (!this.layers) {
            this.layers = [defaultLayer];
        }
        if (!this.defaultConfig) {
            this.defaultConfig = defaultMapConfig;
        }
        this.config = {
            center: this.defaultConfig.center
        };
    }
    async ngOnChanges(changes) {
        if (changes.config?.firstChange) {
            return;
        }
        if (changes.rootNode?.previousValue !== changes.rootNode?.currentValue) {
            this.changeRootNode(changes.rootNode.currentValue);
        }
        if (changes.config?.currentValue) {
            this.changeConfig(changes.config);
        }
    }
    changeConfig(change) {
        // on following, cancel reload to avoid stale state
        if (change.currentValue.follow === true) {
            this.cancelReload();
            this.isLoading$.next(false);
        }
        if (change.currentValue.refreshInterval !== change.previousValue.refreshInterval) {
            this.reload();
        }
        super.changeConfig(change);
    }
    async ngAfterViewInit() {
        if (!this.leaflet) {
            this.leaflet = await this.mapService.getLeaflet();
        }
        this.initMap();
        this.changeRootNode(this.rootNode);
        this.changeConfig(new SimpleChange({}, this.config, false));
    }
    async reset() {
        this.ngOnDestroy();
        await this.ngAfterViewInit();
    }
    reload() {
        this.reloadTrigger$.next(true);
    }
    cancelReload() {
        this.reloadTrigger$.next(false);
    }
    listenToClusterChanges() {
        const timerStart$ = new Subject();
        const timerEnd$ = new Subject();
        const documentHiddenEvent$ = fromEvent(document, 'visibilitychange').pipe(takeUntil(this.destroy$));
        const interval$ = timerStart$.pipe(map(() => this.config.refreshInterval), switchMap(configInterval => {
            if (!configInterval) {
                return NEVER;
            }
            return interval(1000).pipe(map(value => value * 1000), tap(value => this.msUntilRefresh$.next(configInterval - value)), filter(value => value >= this.MIN_INTERVAL && value >= configInterval), first(), takeUntil(timerEnd$));
        }), switchMap(() => (document.hidden ? documentHiddenEvent$ : of(true))), takeUntil(this.destroy$));
        const mapChange$ = merge(fromEvent(this.map, 'move'), fromEvent(this.map, 'moveend')).pipe(debounceTime(this.EVENT_THROTTLE_TIME), tap(event => this.mapChange.emit(event)), takeUntil(this.destroy$));
        merge(this.reloadTrigger$, mapChange$, interval$)
            .pipe(tap(() => {
            timerEnd$.next(true);
            this.msUntilRefresh$.next(0);
            this.isLoading$.next(true);
        }), switchMap(value => value === false
            ? of([])
            : from(this.mapService.getClusterSize(this.map.getBounds())).pipe(mergeMap((clusterSize) => this.getClusterRects(clusterSize, this.map.getBounds())), mergeMap(rects => this.createOrUpdateCluster(rects)))), takeUntil(this.destroy$))
            .subscribe((clusters) => {
            clusters.forEach(cluster => cluster.render(this.map));
            this.isLoading$.next(false);
            timerStart$.next();
            this.msUntilRefresh$.next(this.config.refreshInterval);
        });
    }
    refreshMarkers() {
        if (this.assets) {
            super.refreshMarkers();
            return;
        }
        this.clusters.forEach(cluster => {
            cluster.clear(this.map);
        });
        this.reload();
    }
    changeRootNode(mo) {
        this.unsubscribeAllListeners();
        this.clearMarkers();
        this.clearClusters();
        const isPositionDevice = mo?.c8y_Position && mo?.c8y_IsDevice;
        if (isPositionDevice) {
            this.assets = mo;
            this.refreshMarkers();
            return;
        }
        this.assets = null;
        this.listenToClusterChanges();
        this.reload();
    }
    async getClusterRects(levelThreshold = ClusterSize.FOUR, viewBounds, level = 0) {
        let rects = [];
        if (levelThreshold === ClusterSize.NONE) {
            const rect = await this.getRect(viewBounds);
            rects.push(rect);
            return rects;
        }
        if (level >= levelThreshold) {
            return rects;
        }
        level++;
        const { lat: x1, lng: y1 } = viewBounds.getSouthWest();
        const { lat: x2, lng: y2 } = viewBounds.getNorthEast();
        const newX2 = (x1 + x2) / 2;
        const newY2 = (y1 + y2) / 2;
        const bounds = [
            [
                [x1, y1],
                [newX2, newY2]
            ],
            [
                [newX2, newY2],
                [x2, y2]
            ],
            [
                [x1, newY2],
                [newX2, y2]
            ],
            [
                [newX2, y1],
                [x2, newY2]
            ]
        ];
        for (const bound of bounds) {
            const latLngBound = this.leaflet.latLngBounds(bound);
            const rect = await this.getRect(latLngBound);
            rects = [...rects, ...(await this.getClusterRects(levelThreshold, latLngBound, level))];
            if (level === levelThreshold) {
                rects.push(rect);
            }
        }
        return rects;
    }
    async getRect(latLngBound) {
        let color = 'none';
        if (this.showClusterColor) {
            color = await this.colorService.generateColor(latLngBound.toBBoxString());
        }
        const rect = this.leaflet.rectangle(latLngBound, {
            color,
            weight: color === 'none' ? 0 : 1,
            interactive: false
        });
        return rect;
    }
    clearClusters() {
        this.clusters.forEach(cluster => {
            cluster.clear(this.map);
        });
        this.clusters = [];
    }
    async updateCluster(cluster) {
        const clusterCount = await this.mapService.getPositionMOsFromBoundCount(cluster.rect.getBounds(), this.rootNode);
        if (clusterCount > this.mapService.MAX_DEVICE_PER_CLUSTER) {
            cluster.setClusterToBigMarker(this.map, clusterCount, this.leaflet);
            cluster.positions = [];
            return cluster;
        }
        cluster.removeClusterToBigMarker();
        cluster.positions = await this.mapService.getPositionMOs(cluster.rect.getBounds(), this.rootNode);
        return cluster;
    }
    createOrUpdateCluster(rects) {
        const isNew = rects.length !== this.clusters.length;
        if (isNew) {
            this.clearClusters();
        }
        const updatePromise = rects.map((rect, index) => {
            if (isNew) {
                const cluster = new ClusterMap(this.iterable, asset => this.getAssetMarker(asset), this.translateService);
                this.clusters.push(cluster);
            }
            this.clusters[index].rect = rect;
            return this.updateCluster(this.clusters[index]);
        });
        return Promise.all(updatePromise);
    }
}
ClusterMapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ClusterMapComponent, deps: [{ token: i1.ManagedObjectRealtimeService }, { token: i2.MapService }, { token: MAP_TILE_LAYER, optional: true }, { token: MAP_DEFAULT_CONFIG, optional: true }, { token: i3.TranslateService }, { token: i0.IterableDiffers }, { token: i1.ColorService }], target: i0.ɵɵFactoryTarget.Component });
ClusterMapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ClusterMapComponent, selector: "c8y-cluster-map", inputs: { config: "config", rootNode: "rootNode", assets: ["asset", "assets"], showClusterColor: "showClusterColor" }, outputs: { mapChange: "mapChange" }, providers: [ManagedObjectRealtimeService], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div class=\"c8y-map\">\n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ClusterMapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-cluster-map', providers: [ManagedObjectRealtimeService], template: "<div class=\"c8y-map\">\n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" }]
        }], ctorParameters: function () { return [{ type: i1.ManagedObjectRealtimeService }, { type: i2.MapService }, { type: Array, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_TILE_LAYER]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_DEFAULT_CONFIG]
                }] }, { type: i3.TranslateService }, { type: i0.IterableDiffers }, { type: i1.ColorService }]; }, propDecorators: { config: [{
                type: Input
            }], rootNode: [{
                type: Input
            }], assets: [{
                type: Input,
                args: ['asset']
            }], showClusterColor: [{
                type: Input
            }], mapChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2x1c3Rlci1tYXAuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbWFwL2NsdXN0ZXItbWFwLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uL21hcC9jbHVzdGVyLW1hcC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLGVBQWUsRUFDZixRQUFRLEVBQ1IsTUFBTSxFQUNOLFlBQVksRUFFYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsWUFBWSxFQUFFLDRCQUE0QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFdkQsT0FBTyxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0YsT0FBTyxFQUNMLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLEdBQUcsRUFDSCxRQUFRLEVBQ1IsU0FBUyxFQUNULFNBQVMsRUFDVCxHQUFHLEVBQ0osTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBRUwsV0FBVyxFQUNYLFlBQVksRUFDWixnQkFBZ0IsRUFHaEIsa0JBQWtCLEVBQ2xCLGNBQWMsRUFFZixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7OztBQU8zQyxNQUFNLE9BQU8sbUJBQW9CLFNBQVEsWUFBWTtJQXdCbkQsWUFDWSxpQkFBK0MsRUFDL0MsVUFBc0IsRUFDYyxN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c0VDNUMzQyxrRkFJQTsyRkQwQ2EsbUJBQW1CO2tCQUwvQixTQUFTOytCQUNFLGlCQUFpQixhQUVoQixDQUFDLDRCQUE0QixDQUFDOzswQkE2QnRDLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsY0FBYzs7MEJBQ2pDLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsa0JBQWtCO29JQXZCeEMsTUFBTTtzQkFETCxLQUFLO2dCQUlOLFFBQVE7c0JBRFAsS0FBSztnQkFJTixNQUFNO3NCQURMLEtBQUs7dUJBQUMsT0FBTztnQkFJZCxnQkFBZ0I7c0JBRGYsS0FBSztnQkFJTixTQUFTO3NCQURSLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgSXRlcmFibGVEaWZmZXJzLFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2UsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJTWFuYWdlZE9iamVjdCB9IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IENvbG9yU2VydmljZSwgTWFuYWdlZE9iamVjdFJlYWx0aW1lU2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHR5cGUgKiBhcyBMIGZyb20gJ2xlYWZsZXQnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBmcm9tLCBmcm9tRXZlbnQsIGludGVydmFsLCBtZXJnZSwgTkVWRVIsIG9mLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBkZWJvdW5jZVRpbWUsXG4gIGZpbHRlcixcbiAgZmlyc3QsXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHN3aXRjaE1hcCxcbiAgdGFrZVVudGlsLFxuICB0YXBcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2x1c3Rlck1hcCB9IGZyb20gJy4vY2x1c3Rlci1tYXAnO1xuaW1wb3J0IHsgTWFwQ29tcG9uZW50IH0gZnJvbSAnLi9tYXAuY29tcG9uZW50JztcbmltcG9ydCB7XG4gIENsdXN0ZXJNYXBDb25maWcsXG4gIENsdXN0ZXJTaXplLFxuICBkZWZhdWx0TGF5ZXIsXG4gIGRlZmF1bHRNYXBDb25maWcsXG4gIE1hcERlZmF1bHRDb25maWcsXG4gIE1hcFRpbGVMYXllcixcbiAgTUFQX0RFRkFVTFRfQ09ORklHLFxuICBNQVBfVElMRV9MQVlFUixcbiAgUG9zaXRpb25NYW5hZ2VkT2JqZWN0XG59IGZyb20gJy4vbWFwLm1vZGVsJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuL21hcC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LWNsdXN0ZXItbWFwJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2NsdXN0ZXItbWFwLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbTWFuYWdlZE9iamVjdFJlYWx0aW1lU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2x1c3Rlck1hcENvbXBvbmVudCBleHRlbmRzIE1hcENvbXBvbmVudCB7XG4gIGlzTG9hZGluZyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgbXNVbnRpbFJlZnJlc2gkID0gbmV3IEJlaGF2aW9yU3ViamVjdCg1MDAwKTtcblxuICBASW5wdXQoKVxuICBjb25maWc6IENsdXN0ZXJNYXBDb25maWc7XG5cbiAgQElucHV0KClcbiAgcm9vdE5vZGU6IElNYW5hZ2VkT2JqZWN0O1xuXG4gIEBJbnB1dCgnYXNzZXQnKVxuICBhc3NldHM6IFBvc2l0aW9uTWFuYWdlZE9iamVjdDtcblxuICBASW5wdXQoKVxuICBzaG93Q2x1c3RlckNvbG9yID0gZmFsc2U7XG5cbiAgQE91dHB1dCgpXG4gIG1hcENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8TC5MZWFmbGV0RXZlbnQ+KCk7XG5cbiAgcHJpdmF0ZSByZWxvYWRUcmlnZ2VyJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICBwcml2YXRlIGNsdXN0ZXJzOiBDbHVzdGVyTWFwW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBNSU5fSU5URVJWQUwgPSA1MDAwO1xuICBwcml2YXRlIHJlYWRvbmx5IEVWRU5UX1RIUk9UVExFX1RJTUUgPSA3NTA7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIG1vUmVhbHRpbWVTZXJ2aWNlOiBNYW5hZ2VkT2JqZWN0UmVhbHRpbWVTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBtYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTUFQX1RJTEVfTEFZRVIpIHByb3RlY3RlZCBsYXllcnM6IEFycmF5PE1hcFRpbGVMYXllciB8IE1hcFRpbGVMYXllcltdPixcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BUF9ERUZBVUxUX0NPTkZJRykgcHJvdGVjdGVkIGRlZmF1bHRDb25maWc6IE1hcERlZmF1bHRDb25maWcsXG4gICAgcHJvdGVjdGVkIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBpdGVyYWJsZTogSXRlcmFibGVEaWZmZXJzLFxuICAgIHByaXZhdGUgY29sb3JTZXJ2aWNlOiBDb2xvclNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIobW9SZWFsdGltZVNlcnZpY2UsIG1hcFNlcnZpY2UsIGxheWVycywgZGVmYXVsdENvbmZpZywgdHJhbnNsYXRlU2VydmljZSk7XG4gICAgaWYgKCF0aGlzLmxheWVycykge1xuICAgICAgdGhpcy5sYXllcnMgPSBbZGVmYXVsdExheWVyXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRNYXBDb25maWc7XG4gICAgfVxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgY2VudGVyOiB0aGlzLmRlZmF1bHRDb25maWcuY2VudGVyXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5jb25maWc/LmZpcnN0Q2hhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMucm9vdE5vZGU/LnByZXZpb3VzVmFsdWUgIT09IGNoYW5nZXMucm9vdE5vZGU/LmN1cnJlbnRWYWx1ZSkge1xuICAgICAgdGhpcy5jaGFuZ2VSb290Tm9kZShjaGFuZ2VzLnJvb3ROb2RlLmN1cnJlbnRWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuY29uZmlnPy5jdXJyZW50VmFsdWUpIHtcbiAgICAgIHRoaXMuY2hhbmdlQ29uZmlnKGNoYW5nZXMuY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VDb25maWcoY2hhbmdlOiBTaW1wbGVDaGFuZ2UpIHtcbiAgICAvLyBvbiBmb2xsb3dpbmcsIGNhbmNlbCByZWxvYWQgdG8gYXZvaWQgc3RhbGUgc3RhdGVcbiAgICBpZiAoY2hhbmdlLmN1cnJlbnRWYWx1ZS5mb2xsb3cgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2FuY2VsUmVsb2FkKCk7XG4gICAgICB0aGlzLmlzTG9hZGluZyQubmV4dChmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZS5jdXJyZW50VmFsdWUucmVmcmVzaEludGVydmFsICE9PSBjaGFuZ2UucHJldmlvdXNWYWx1ZS5yZWZyZXNoSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMucmVsb2FkKCk7XG4gICAgfVxuICAgIHN1cGVyLmNoYW5nZUNvbmZpZyhjaGFuZ2UpO1xuICB9XG5cbiAgYXN5bmMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGlmICghdGhpcy5sZWFmbGV0KSB7XG4gICAgICB0aGlzLmxlYWZsZXQgPSBhd2FpdCB0aGlzLm1hcFNlcnZpY2UuZ2V0TGVhZmxldCgpO1xuICAgIH1cbiAgICB0aGlzLmluaXRNYXAoKTtcbiAgICB0aGlzLmNoYW5nZVJvb3ROb2RlKHRoaXMucm9vdE5vZGUpO1xuICAgIHRoaXMuY2hhbmdlQ29uZmlnKG5ldyBTaW1wbGVDaGFuZ2Uoe30sIHRoaXMuY29uZmlnLCBmYWxzZSkpO1xuICB9XG5cbiAgYXN5bmMgcmVzZXQoKSB7XG4gICAgdGhpcy5uZ09uRGVzdHJveSgpO1xuICAgIGF3YWl0IHRoaXMubmdBZnRlclZpZXdJbml0KCk7XG4gIH1cblxuICByZWxvYWQoKSB7XG4gICAgdGhpcy5yZWxvYWRUcmlnZ2VyJC5uZXh0KHRydWUpO1xuICB9XG5cbiAgY2FuY2VsUmVsb2FkKCkge1xuICAgIHRoaXMucmVsb2FkVHJpZ2dlciQubmV4dChmYWxzZSk7XG4gIH1cblxuICBsaXN0ZW5Ub0NsdXN0ZXJDaGFuZ2VzKCkge1xuICAgIGNvbnN0IHRpbWVyU3RhcnQkID0gbmV3IFN1YmplY3QoKTtcbiAgICBjb25zdCB0aW1lckVuZCQgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3QgZG9jdW1lbnRIaWRkZW5FdmVudCQgPSBmcm9tRXZlbnQ8Ym9vbGVhbj4oZG9jdW1lbnQsICd2aXNpYmlsaXR5Y2hhbmdlJykucGlwZShcbiAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKVxuICAgICk7XG5cbiAgICBjb25zdCBpbnRlcnZhbCQgPSB0aW1lclN0YXJ0JC5waXBlKFxuICAgICAgbWFwKCgpID0+IHRoaXMuY29uZmlnLnJlZnJlc2hJbnRlcnZhbCksXG4gICAgICBzd2l0Y2hNYXAoY29uZmlnSW50ZXJ2YWwgPT4ge1xuICAgICAgICBpZiAoIWNvbmZpZ0ludGVydmFsKSB7XG4gICAgICAgICAgcmV0dXJuIE5FVkVSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnZhbCgxMDAwKS5waXBlKFxuICAgICAgICAgIG1hcCh2YWx1ZSA9PiB2YWx1ZSAqIDEwMDApLFxuICAgICAgICAgIHRhcCh2YWx1ZSA9PiB0aGlzLm1zVW50aWxSZWZyZXNoJC5uZXh0KGNvbmZpZ0ludGVydmFsIC0gdmFsdWUpKSxcbiAgICAgICAgICBmaWx0ZXIodmFsdWUgPT4gdmFsdWUgPj0gdGhpcy5NSU5fSU5URVJWQUwgJiYgdmFsdWUgPj0gY29uZmlnSW50ZXJ2YWwpLFxuICAgICAgICAgIGZpcnN0KCksXG4gICAgICAgICAgdGFrZVVudGlsKHRpbWVyRW5kJClcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuICAgICAgc3dpdGNoTWFwKCgpID0+IChkb2N1bWVudC5oaWRkZW4gPyBkb2N1bWVudEhpZGRlbkV2ZW50JCA6IG9mKHRydWUpKSksXG4gICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICApO1xuXG4gICAgY29uc3QgbWFwQ2hhbmdlJCA9IG1lcmdlKFxuICAgICAgZnJvbUV2ZW50PEwuTGVhZmxldEV2ZW50Pih0aGlzLm1hcCwgJ21vdmUnKSxcbiAgICAgIGZyb21FdmVudDxMLkxlYWZsZXRFdmVudD4odGhpcy5tYXAsICdtb3ZlZW5kJylcbiAgICApLnBpcGUoXG4gICAgICBkZWJvdW5jZVRpbWUodGhpcy5FVkVOVF9USFJPVFRMRV9USU1FKSxcbiAgICAgIHRhcChldmVudCA9PiB0aGlzLm1hcENoYW5nZS5lbWl0KGV2ZW50KSksXG4gICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICApO1xuXG4gICAgbWVyZ2UodGhpcy5yZWxvYWRUcmlnZ2VyJCwgbWFwQ2hhbmdlJCwgaW50ZXJ2YWwkKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgICAgdGltZXJFbmQkLm5leHQodHJ1ZSk7XG4gICAgICAgICAgdGhpcy5tc1VudGlsUmVmcmVzaCQubmV4dCgwKTtcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyQubmV4dCh0cnVlKTtcbiAgICAgICAgfSksXG4gICAgICAgIHN3aXRjaE1hcCh2YWx1ZSA9PlxuICAgICAgICAgIHZhbHVlID09PSBmYWxzZVxuICAgICAgICAgICAgPyBvZihbXSlcbiAgICAgICAgICAgIDogZnJvbSh0aGlzLm1hcFNlcnZpY2UuZ2V0Q2x1c3RlclNpemUodGhpcy5tYXAuZ2V0Qm91bmRzKCkpKS5waXBlKFxuICAgICAgICAgICAgICAgIG1lcmdlTWFwKChjbHVzdGVyU2l6ZTogQ2x1c3RlclNpemUpID0+XG4gICAgICAgICAgICAgICAgICB0aGlzLmdldENsdXN0ZXJSZWN0cyhjbHVzdGVyU2l6ZSwgdGhpcy5tYXAuZ2V0Qm91bmRzKCkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtZXJnZU1hcChyZWN0cyA9PiB0aGlzLmNyZWF0ZU9yVXBkYXRlQ2x1c3RlcihyZWN0cykpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChjbHVzdGVyczogQ2x1c3Rlck1hcFtdKSA9PiB7XG4gICAgICAgIGNsdXN0ZXJzLmZvckVhY2goY2x1c3RlciA9PiBjbHVzdGVyLnJlbmRlcih0aGlzLm1hcCkpO1xuXG4gICAgICAgIHRoaXMuaXNMb2FkaW5nJC5uZXh0KGZhbHNlKTtcbiAgICAgICAgdGltZXJTdGFydCQubmV4dCgpO1xuICAgICAgICB0aGlzLm1zVW50aWxSZWZyZXNoJC5uZXh0KHRoaXMuY29uZmlnLnJlZnJlc2hJbnRlcnZhbCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJlZnJlc2hNYXJrZXJzKCkge1xuICAgIGlmICh0aGlzLmFzc2V0cykge1xuICAgICAgc3VwZXIucmVmcmVzaE1hcmtlcnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jbHVzdGVycy5mb3JFYWNoKGNsdXN0ZXIgPT4ge1xuICAgICAgY2x1c3Rlci5jbGVhcih0aGlzLm1hcCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZWxvYWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgY2hhbmdlUm9vdE5vZGUobW86IElNYW5hZ2VkT2JqZWN0KSB7XG4gICAgdGhpcy51bnN1YnNjcmliZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuY2xlYXJNYXJrZXJzKCk7XG4gICAgdGhpcy5jbGVhckNsdXN0ZXJzKCk7XG5cbiAgICBjb25zdCBpc1Bvc2l0aW9uRGV2aWNlID0gbW8/LmM4eV9Qb3NpdGlvbiAmJiBtbz8uYzh5X0lzRGV2aWNlO1xuICAgIGlmIChpc1Bvc2l0aW9uRGV2aWNlKSB7XG4gICAgICB0aGlzLmFzc2V0cyA9IG1vIGFzIFBvc2l0aW9uTWFuYWdlZE9iamVjdDtcbiAgICAgIHRoaXMucmVmcmVzaE1hcmtlcnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hc3NldHMgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuVG9DbHVzdGVyQ2hhbmdlcygpO1xuICAgIHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldENsdXN0ZXJSZWN0cyhcbiAgICBsZXZlbFRocmVzaG9sZDogQ2x1c3RlclNpemUgPSBDbHVzdGVyU2l6ZS5GT1VSLFxuICAgIHZpZXdCb3VuZHM6IEwuTGF0TG5nQm91bmRzLFxuICAgIGxldmVsID0gMFxuICApOiBQcm9taXNlPEwuUmVjdGFuZ2xlW10+IHtcbiAgICBsZXQgcmVjdHMgPSBbXTtcblxuICAgIGlmIChsZXZlbFRocmVzaG9sZCA9PT0gQ2x1c3RlclNpemUuTk9ORSkge1xuICAgICAgY29uc3QgcmVjdCA9IGF3YWl0IHRoaXMuZ2V0UmVjdCh2aWV3Qm91bmRzKTtcbiAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICByZXR1cm4gcmVjdHM7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsID49IGxldmVsVGhyZXNob2xkKSB7XG4gICAgICByZXR1cm4gcmVjdHM7XG4gICAgfVxuICAgIGxldmVsKys7XG5cbiAgICBjb25zdCB7IGxhdDogeDEsIGxuZzogeTEgfSA9IHZpZXdCb3VuZHMuZ2V0U291dGhXZXN0KCk7XG4gICAgY29uc3QgeyBsYXQ6IHgyLCBsbmc6IHkyIH0gPSB2aWV3Qm91bmRzLmdldE5vcnRoRWFzdCgpO1xuICAgIGNvbnN0IG5ld1gyID0gKHgxICsgeDIpIC8gMjtcbiAgICBjb25zdCBuZXdZMiA9ICh5MSArIHkyKSAvIDI7XG5cbiAgICBjb25zdCBib3VuZHM6IFtbbnVtYmVyLCBudW1iZXJdLCBbbnVtYmVyLCBudW1iZXJdXVtdID0gW1xuICAgICAgW1xuICAgICAgICBbeDEsIHkxXSxcbiAgICAgICAgW25ld1gyLCBuZXdZMl1cbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFtuZXdYMiwgbmV3WTJdLFxuICAgICAgICBbeDIsIHkyXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgW3gxLCBuZXdZMl0sXG4gICAgICAgIFtuZXdYMiwgeTJdXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbbmV3WDIsIHkxXSxcbiAgICAgICAgW3gyLCBuZXdZMl1cbiAgICAgIF1cbiAgICBdO1xuICAgIGZvciAoY29uc3QgYm91bmQgb2YgYm91bmRzKSB7XG4gICAgICBjb25zdCBsYXRMbmdCb3VuZCA9IHRoaXMubGVhZmxldC5sYXRMbmdCb3VuZHMoYm91bmQpO1xuICAgICAgY29uc3QgcmVjdCA9IGF3YWl0IHRoaXMuZ2V0UmVjdChsYXRMbmdCb3VuZCk7XG4gICAgICByZWN0cyA9IFsuLi5yZWN0cywgLi4uKGF3YWl0IHRoaXMuZ2V0Q2x1c3RlclJlY3RzKGxldmVsVGhyZXNob2xkLCBsYXRMbmdCb3VuZCwgbGV2ZWwpKV07XG5cbiAgICAgIGlmIChsZXZlbCA9PT0gbGV2ZWxUaHJlc2hvbGQpIHtcbiAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdHM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFJlY3QobGF0TG5nQm91bmQ6IEwuTGF0TG5nQm91bmRzKSB7XG4gICAgbGV0IGNvbG9yID0gJ25vbmUnO1xuICAgIGlmICh0aGlzLnNob3dDbHVzdGVyQ29sb3IpIHtcbiAgICAgIGNvbG9yID0gYXdhaXQgdGhpcy5jb2xvclNlcnZpY2UuZ2VuZXJhdGVDb2xvcihsYXRMbmdCb3VuZC50b0JCb3hTdHJpbmcoKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmxlYWZsZXQucmVjdGFuZ2xlKGxhdExuZ0JvdW5kLCB7XG4gICAgICBjb2xvcixcbiAgICAgIHdlaWdodDogY29sb3IgPT09ICdub25lJyA/IDAgOiAxLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyQ2x1c3RlcnMoKSB7XG4gICAgdGhpcy5jbHVzdGVycy5mb3JFYWNoKGNsdXN0ZXIgPT4ge1xuICAgICAgY2x1c3Rlci5jbGVhcih0aGlzLm1hcCk7XG4gICAgfSk7XG4gICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVDbHVzdGVyKGNsdXN0ZXI6IENsdXN0ZXJNYXApIHtcbiAgICBjb25zdCBjbHVzdGVyQ291bnQgPSBhd2FpdCB0aGlzLm1hcFNlcnZpY2UuZ2V0UG9zaXRpb25NT3NGcm9tQm91bmRDb3VudChcbiAgICAgIGNsdXN0ZXIucmVjdC5nZXRCb3VuZHMoKSxcbiAgICAgIHRoaXMucm9vdE5vZGVcbiAgICApO1xuICAgIGlmIChjbHVzdGVyQ291bnQgPiB0aGlzLm1hcFNlcnZpY2UuTUFYX0RFVklDRV9QRVJfQ0xVU1RFUikge1xuICAgICAgY2x1c3Rlci5zZXRDbHVzdGVyVG9CaWdNYXJrZXIodGhpcy5tYXAsIGNsdXN0ZXJDb3VudCwgdGhpcy5sZWFmbGV0KTtcbiAgICAgIGNsdXN0ZXIucG9zaXRpb25zID0gW107XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9XG5cbiAgICBjbHVzdGVyLnJlbW92ZUNsdXN0ZXJUb0JpZ01hcmtlcigpO1xuICAgIGNsdXN0ZXIucG9zaXRpb25zID0gYXdhaXQgdGhpcy5tYXBTZXJ2aWNlLmdldFBvc2l0aW9uTU9zKFxuICAgICAgY2x1c3Rlci5yZWN0LmdldEJvdW5kcygpLFxuICAgICAgdGhpcy5yb290Tm9kZVxuICAgICk7XG4gICAgcmV0dXJuIGNsdXN0ZXI7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU9yVXBkYXRlQ2x1c3RlcihyZWN0czogTC5SZWN0YW5nbGU8dW5rbm93bj5bXSkge1xuICAgIGNvbnN0IGlzTmV3ID0gcmVjdHMubGVuZ3RoICE9PSB0aGlzLmNsdXN0ZXJzLmxlbmd0aDtcbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIHRoaXMuY2xlYXJDbHVzdGVycygpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVQcm9taXNlID0gcmVjdHMubWFwKChyZWN0LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBuZXcgQ2x1c3Rlck1hcChcbiAgICAgICAgICB0aGlzLml0ZXJhYmxlLFxuICAgICAgICAgIGFzc2V0ID0+IHRoaXMuZ2V0QXNzZXRNYXJrZXIoYXNzZXQpLFxuICAgICAgICAgIHRoaXMudHJhbnNsYXRlU2VydmljZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzLnB1c2goY2x1c3Rlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmNsdXN0ZXJzW2luZGV4XS5yZWN0ID0gcmVjdDtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsdXN0ZXIodGhpcy5jbHVzdGVyc1tpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHVwZGF0ZVByb21pc2UpO1xuICB9XG59XG4iLCI8ZGl2IGNsYXNzPVwiYzh5LW1hcFwiPlxuICA8ZGl2ICNtYXA+PC9kaXY+XG48L2Rpdj5cbjxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiJdfQ==