import { Injectable } from '@angular/core';
import { MeasurementService } from '@c8y/client';
import { from, merge } from 'rxjs';
import { filter, map, switchMap } from 'rxjs/operators';
import { RealtimeSubjectService } from './realtime-subject.service';
import { RealtimeService } from './realtime.service';
import * as i0 from "@angular/core";
import * as i1 from "./realtime-subject.service";
import * as i2 from "@c8y/client";
export class MeasurementRealtimeService extends RealtimeService {
    constructor(realtimeSubject, measurementService) {
        super(realtimeSubject);
        this.realtimeSubject = realtimeSubject;
        this.measurementService = measurementService;
    }
    /**
     * Get an Observable of all measurements filtered by fragment and series.
     *
     * @param {string} fragment Measurement fragment
     *
     * @param {string} series Measurement series
     *
     * @param {string | number | IIdentified} entityOrId Entity object or id
     *
     * @returns An [[Observable]] of newly created entity objects.
     */
    onCreateOfSpecificMeasurement$(fragment, series, entityOrId) {
        return this.onCreate$(entityOrId).pipe(filter(msg => msg[fragment] && msg[fragment][series]));
    }
    /**
     * Get an Observable of all measurements filtered by fragment and series.
     * Combines the latest value from measurement API and future values via realtime API.
     *
     * @param {string} fragment Measurement fragment
     *
     * @param {string} series Measurement series
     *
     * @param {string | number | IIdentified} entityOrId Entity object or id
     *
     * @param {number} pageSize Number of measurements to initially retrieve from backend
     *
     * @param {boolean} emitNullIfInitialValuesWereNotFound Flag that if set to true will initially emit value of null in case no measurement could have been retrieved from backend
     *
     * @returns An [[Observable]] of newly created entity objects.
     */
    latestValueOfSpecificMeasurement$(fragment, series, entityOrId, pageSize = 1, emitNullIfInitialValuesWereNotFound = false) {
        const realtime$ = this.onCreateOfSpecificMeasurement$(fragment, series, entityOrId);
        const lastMeasurement$ = this.lastMeasurement$(fragment, series, entityOrId, pageSize, emitNullIfInitialValuesWereNotFound);
        return merge(lastMeasurement$, realtime$);
    }
    lastMeasurement$(fragment, series, entityOrId, pageSize, emitNullIfInitialValuesWereNotFound = false) {
        return from(this.measurementService.list({
            valueFragmentSeries: series,
            valueFragmentType: fragment,
            source: this.getIdString(entityOrId),
            dateFrom: '1970-01-01',
            revert: true,
            pageSize
        })).pipe(
        // emit null in case no value could have been retrieved so we are able to note that in certain cases.
        map(result => !emitNullIfInitialValuesWereNotFound || result.data.length ? result.data : [null]), 
        // reverse required, so that measurements are received ordered by time (ascending).
        // from ensures values are sent as single measurements and not a measurement array.
        switchMap(result => from(result.reverse())));
    }
    channel() {
        return '/measurements/*';
    }
}
MeasurementRealtimeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MeasurementRealtimeService, deps: [{ token: i1.RealtimeSubjectService }, { token: i2.MeasurementService }], target: i0.ɵɵFactoryTarget.Injectable });
MeasurementRealtimeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MeasurementRealtimeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: MeasurementRealtimeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.RealtimeSubjectService }, { type: i2.MeasurementService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVhc3VyZW1lbnQtcmVhbHRpbWUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvcmVhbHRpbWUvbWVhc3VyZW1lbnQtcmVhbHRpbWUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBNkIsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDNUUsT0FBTyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDL0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDcEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDOzs7O0FBR3JELE1BQU0sT0FBTywwQkFBMkIsU0FBUSxlQUE2QjtJQUMzRSxZQUNZLGVBQXVDLEVBQ3ZDLGtCQUFzQztRQUVoRCxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7UUFIYixvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7UUFDdkMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtJQUdsRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILDhCQUE4QixDQUM1QixRQUFnQixFQUNoQixNQUFjLEVBQ2QsVUFBMEM7UUFFMUMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0gsaUNBQWlDLENBQy9CLFFBQWdCLEVBQ2hCLE1BQWMsRUFDZCxVQUF5QyxFQUN6QyxRQUFRLEdBQUcsQ0FBQyxFQUNaLG1DQUFtQyxHQUFHLEtBQUs7UUFFM0MsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLDhCQUE4QixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDcEYsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQzVDLFFBQVEsRUFDUixNQUFNLEVBQ04sVUFBVSxFQUNWLFFBQVEsRUFDUixtQ0FBbUMsQ0FDcEMsQ0FBQztRQUNGLE9BQU8sS0FBSyxDQUFDLGdCQUFnQixFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFUyxnQkFBZ0IsQ0FDeEIsUUFBZ0IsRUFDaEIsTUFBYyxFQUNkLFVBQXlDLEVBQ3pDLFFBQWdCLEVBQ2hCLG1DQUFtQyxHQUFHLEtBQUs7UUFFM0MsT0FBTyxJQUFJLENBQ1QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQztZQUMzQixtQkFBbUIsRUFBRSxNQUFNO1lBQzNCLGlCQUFpQixFQUFFLFFBQVE7WUFDM0IsTUFBTSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDO1lBQ3BDLFFBQVEsRUFBRSxZQUFZO1lBQ3RCLE1BQU0sRUFBRSxJQUFJO1lBQ1osUUFBUTtTQUNULENBQUMsQ0FDSCxDQUFDLElBQUk7UUFDSixxR0FBcUc7UUFDckcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQ1gsQ0FBQyxtQ0FBbUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDbEY7UUFDRCxtRkFBbUY7UUFDbkYsbUZBQW1GO1FBQ25GLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUM1QyxDQUFDO0lBQ0osQ0FBQztJQUVTLE9BQU87UUFDZixPQUFPLGlCQUFpQixDQUFDO0lBQzNCLENBQUM7O3VIQTFGVSwwQkFBMEI7MkhBQTFCLDBCQUEwQjsyRkFBMUIsMEJBQTBCO2tCQUR0QyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSUlkZW50aWZpZWQsIElNZWFzdXJlbWVudCwgTWVhc3VyZW1lbnRTZXJ2aWNlIH0gZnJvbSAnQGM4eS9jbGllbnQnO1xuaW1wb3J0IHsgZnJvbSwgbWVyZ2UsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBSZWFsdGltZVN1YmplY3RTZXJ2aWNlIH0gZnJvbSAnLi9yZWFsdGltZS1zdWJqZWN0LnNlcnZpY2UnO1xuaW1wb3J0IHsgUmVhbHRpbWVTZXJ2aWNlIH0gZnJvbSAnLi9yZWFsdGltZS5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1lYXN1cmVtZW50UmVhbHRpbWVTZXJ2aWNlIGV4dGVuZHMgUmVhbHRpbWVTZXJ2aWNlPElNZWFzdXJlbWVudD4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgcmVhbHRpbWVTdWJqZWN0OiBSZWFsdGltZVN1YmplY3RTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBtZWFzdXJlbWVudFNlcnZpY2U6IE1lYXN1cmVtZW50U2VydmljZVxuICApIHtcbiAgICBzdXBlcihyZWFsdGltZVN1YmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBPYnNlcnZhYmxlIG9mIGFsbCBtZWFzdXJlbWVudHMgZmlsdGVyZWQgYnkgZnJhZ21lbnQgYW5kIHNlcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyYWdtZW50IE1lYXN1cmVtZW50IGZyYWdtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXMgTWVhc3VyZW1lbnQgc2VyaWVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgSUlkZW50aWZpZWR9IGVudGl0eU9ySWQgRW50aXR5IG9iamVjdCBvciBpZFxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBbW09ic2VydmFibGVdXSBvZiBuZXdseSBjcmVhdGVkIGVudGl0eSBvYmplY3RzLlxuICAgKi9cbiAgb25DcmVhdGVPZlNwZWNpZmljTWVhc3VyZW1lbnQkKFxuICAgIGZyYWdtZW50OiBzdHJpbmcsXG4gICAgc2VyaWVzOiBzdHJpbmcsXG4gICAgZW50aXR5T3JJZD86IHN0cmluZyB8IG51bWJlciB8IElJZGVudGlmaWVkXG4gICk6IE9ic2VydmFibGU8SU1lYXN1cmVtZW50PiB7XG4gICAgcmV0dXJuIHRoaXMub25DcmVhdGUkKGVudGl0eU9ySWQpLnBpcGUoZmlsdGVyKG1zZyA9PiBtc2dbZnJhZ21lbnRdICYmIG1zZ1tmcmFnbWVudF1bc2VyaWVzXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBPYnNlcnZhYmxlIG9mIGFsbCBtZWFzdXJlbWVudHMgZmlsdGVyZWQgYnkgZnJhZ21lbnQgYW5kIHNlcmllcy5cbiAgICogQ29tYmluZXMgdGhlIGxhdGVzdCB2YWx1ZSBmcm9tIG1lYXN1cmVtZW50IEFQSSBhbmQgZnV0dXJlIHZhbHVlcyB2aWEgcmVhbHRpbWUgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJhZ21lbnQgTWVhc3VyZW1lbnQgZnJhZ21lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmllcyBNZWFzdXJlbWVudCBzZXJpZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBJSWRlbnRpZmllZH0gZW50aXR5T3JJZCBFbnRpdHkgb2JqZWN0IG9yIGlkXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlU2l6ZSBOdW1iZXIgb2YgbWVhc3VyZW1lbnRzIHRvIGluaXRpYWxseSByZXRyaWV2ZSBmcm9tIGJhY2tlbmRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbWl0TnVsbElmSW5pdGlhbFZhbHVlc1dlcmVOb3RGb3VuZCBGbGFnIHRoYXQgaWYgc2V0IHRvIHRydWUgd2lsbCBpbml0aWFsbHkgZW1pdCB2YWx1ZSBvZiBudWxsIGluIGNhc2Ugbm8gbWVhc3VyZW1lbnQgY291bGQgaGF2ZSBiZWVuIHJldHJpZXZlZCBmcm9tIGJhY2tlbmRcbiAgICpcbiAgICogQHJldHVybnMgQW4gW1tPYnNlcnZhYmxlXV0gb2YgbmV3bHkgY3JlYXRlZCBlbnRpdHkgb2JqZWN0cy5cbiAgICovXG4gIGxhdGVzdFZhbHVlT2ZTcGVjaWZpY01lYXN1cmVtZW50JChcbiAgICBmcmFnbWVudDogc3RyaW5nLFxuICAgIHNlcmllczogc3RyaW5nLFxuICAgIGVudGl0eU9ySWQ6IHN0cmluZyB8IG51bWJlciB8IElJZGVudGlmaWVkLFxuICAgIHBhZ2VTaXplID0gMSxcbiAgICBlbWl0TnVsbElmSW5pdGlhbFZhbHVlc1dlcmVOb3RGb3VuZCA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IHJlYWx0aW1lJCA9IHRoaXMub25DcmVhdGVPZlNwZWNpZmljTWVhc3VyZW1lbnQkKGZyYWdtZW50LCBzZXJpZXMsIGVudGl0eU9ySWQpO1xuICAgIGNvbnN0IGxhc3RNZWFzdXJlbWVudCQgPSB0aGlzLmxhc3RNZWFzdXJlbWVudCQoXG4gICAgICBmcmFnbWVudCxcbiAgICAgIHNlcmllcyxcbiAgICAgIGVudGl0eU9ySWQsXG4gICAgICBwYWdlU2l6ZSxcbiAgICAgIGVtaXROdWxsSWZJbml0aWFsVmFsdWVzV2VyZU5vdEZvdW5kXG4gICAgKTtcbiAgICByZXR1cm4gbWVyZ2UobGFzdE1lYXN1cmVtZW50JCwgcmVhbHRpbWUkKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsYXN0TWVhc3VyZW1lbnQkKFxuICAgIGZyYWdtZW50OiBzdHJpbmcsXG4gICAgc2VyaWVzOiBzdHJpbmcsXG4gICAgZW50aXR5T3JJZDogc3RyaW5nIHwgbnVtYmVyIHwgSUlkZW50aWZpZWQsXG4gICAgcGFnZVNpemU6IG51bWJlcixcbiAgICBlbWl0TnVsbElmSW5pdGlhbFZhbHVlc1dlcmVOb3RGb3VuZCA9IGZhbHNlXG4gICkge1xuICAgIHJldHVybiBmcm9tKFxuICAgICAgdGhpcy5tZWFzdXJlbWVudFNlcnZpY2UubGlzdCh7XG4gICAgICAgIHZhbHVlRnJhZ21lbnRTZXJpZXM6IHNlcmllcyxcbiAgICAgICAgdmFsdWVGcmFnbWVudFR5cGU6IGZyYWdtZW50LFxuICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0SWRTdHJpbmcoZW50aXR5T3JJZCksXG4gICAgICAgIGRhdGVGcm9tOiAnMTk3MC0wMS0wMScsXG4gICAgICAgIHJldmVydDogdHJ1ZSxcbiAgICAgICAgcGFnZVNpemVcbiAgICAgIH0pXG4gICAgKS5waXBlKFxuICAgICAgLy8gZW1pdCBudWxsIGluIGNhc2Ugbm8gdmFsdWUgY291bGQgaGF2ZSBiZWVuIHJldHJpZXZlZCBzbyB3ZSBhcmUgYWJsZSB0byBub3RlIHRoYXQgaW4gY2VydGFpbiBjYXNlcy5cbiAgICAgIG1hcChyZXN1bHQgPT5cbiAgICAgICAgIWVtaXROdWxsSWZJbml0aWFsVmFsdWVzV2VyZU5vdEZvdW5kIHx8IHJlc3VsdC5kYXRhLmxlbmd0aCA/IHJlc3VsdC5kYXRhIDogW251bGxdXG4gICAgICApLFxuICAgICAgLy8gcmV2ZXJzZSByZXF1aXJlZCwgc28gdGhhdCBtZWFzdXJlbWVudHMgYXJlIHJlY2VpdmVkIG9yZGVyZWQgYnkgdGltZSAoYXNjZW5kaW5nKS5cbiAgICAgIC8vIGZyb20gZW5zdXJlcyB2YWx1ZXMgYXJlIHNlbnQgYXMgc2luZ2xlIG1lYXN1cmVtZW50cyBhbmQgbm90IGEgbWVhc3VyZW1lbnQgYXJyYXkuXG4gICAgICBzd2l0Y2hNYXAocmVzdWx0ID0+IGZyb20ocmVzdWx0LnJldmVyc2UoKSkpXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGFubmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICcvbWVhc3VyZW1lbnRzLyonO1xuICB9XG59XG4iXX0=