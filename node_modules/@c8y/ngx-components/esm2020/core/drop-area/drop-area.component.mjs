import { ChangeDetectorRef, Component, ElementRef, EventEmitter, HostListener, Input, Output, ViewChild } from '@angular/core';
import { NG_VALUE_ACCESSOR, AbstractControl } from '@angular/forms';
import { TranslateService } from '@ngx-translate/core';
import { get, map, some, min } from 'lodash-es';
import { BytesPipe } from '../common/bytes.pipe';
import { FilesService } from '../common/files.service';
import { gettext } from '../i18n/gettext';
import * as i0 from "@angular/core";
import * as i1 from "../common/files.service";
import * as i2 from "@ngx-translate/core";
import * as i3 from "../common/bytes.pipe";
import * as i4 from "../common/icon.directive";
import * as i5 from "../i18n/c8y-translate.directive";
import * as i6 from "@angular/common";
import * as i7 from "../common/loading.component";
import * as i8 from "../i18n/c8y-translate.pipe";
/**
 * A drop-zone which is a file selector allowing users to select file(s) from their file system, either natively or by drag and drop.
 *
 * ## Example:
 *
 * ```html
 *  <div>
 *    <c8y-drop-area
 *      (dropped)="uploadFile($event)"
 *      [icon]="'upload'"
 *      [accept]="'.zip,.7z,video'">
 *    </c8y-drop-area>
 *  </div>
 * ```
 */
export class DropAreaComponent {
    constructor(cd, filesService, translate, bytes, ref) {
        this.cd = cd;
        this.filesService = filesService;
        this.translate = translate;
        this.bytes = bytes;
        this.ref = ref;
        this.title = gettext('Upload file');
        this.message = gettext('Drop file here');
        this.icon = 'plus-square';
        this.loadingMessage = gettext('Uploading…');
        this.forceHideList = false;
        /** Affects displaying both the drop zone and the list of dropped files. */
        this.alwaysShow = false;
        this.clickToOpen = true;
        this.loading = false;
        /**
         * Current progress of the upload as a percentage. If not given a spinner will be displayed.
         */
        this.progress = -1; // -1 = spinner
        this.dropped = new EventEmitter();
        this.maxAllowedFiles = Infinity;
        this.isOver = false;
        this.errors = false;
        this.onChange = _ => undefined;
        this.onTouched = () => undefined;
    }
    onkeyup(event) {
        if (event.key === 'Enter') {
            this.picker.nativeElement.click();
        }
    }
    ngOnInit() {
        this.acceptedExts = this.filesService.extractFileExtensions(this.accept).map(t => `.${t}`);
        this.alwaysShow = this.alwaysShow || this.area.nativeElement.children.length === 0;
        if (this.files && this.isFilesAnObjectOrArray() && this.files.length > 0) {
            this.onFilesSelected(this.files);
        }
    }
    ngAfterViewChecked() {
        this.hasDropAreaSmallClass = this.ref.nativeElement.classList.contains('drop-area-sm');
    }
    /**
     * Toggles the style of the drop zone element when a file is dragged over the component.
     */
    toggle() {
        this.zone.nativeElement.style.height = this.area.nativeElement.offsetHeight + 'px';
        this.onOver();
    }
    /**
     * Shows computer browser with files to drop into drop-area zone.
     */
    showPicker($event) {
        this.preventDefault($event);
        this.picker.nativeElement.value = '';
        this.picker.nativeElement.click();
    }
    /**
     * Triggered when file is on over drop area, but not dropped.
     */
    onOver() {
        if (!this.isOver) {
            this.isOver = true;
            document.addEventListener('dragover', this.preventDefault);
            document.addEventListener('drop', this.preventDefault);
        }
    }
    /**
     * Triggered when file is dropped.
     */
    onPick($event) {
        this.errors = false;
        this.preventDefault($event);
        this.onFilesSelected($event.target.files);
    }
    /**
     * Handle file when it is dropped into drop-area.
     */
    onDrop($event) {
        this.preventDefault($event);
        this.onFilesSelected($event.dataTransfer.files);
        this.stopDragging();
    }
    /**
     * Checks condition what should be displayed: drop-area zone or list of dropped files.
     */
    shouldShowFilesList() {
        return (this.isFilesAnObjectOrArray() &&
            !this.forceHideList &&
            this.alwaysShow &&
            !this.isFilesArrayEmpty() &&
            !this.hasEmptyFiles() &&
            !this.isTooManyFiles());
    }
    /**
     * Triggered when file is picked over web application.
     */
    stopDragging() {
        document.removeEventListener('dragover', this.preventDefault);
        document.removeEventListener('drop', this.preventDefault);
        this.isOver = false;
    }
    /**
     * Delete files already dropped files.
     */
    onDelete() {
        delete this.files;
        delete this.filesNameString;
        this.clearErrors();
        this.dropped.emit(null);
        this.onChange(null);
        this.cd.markForCheck();
    }
    writeValue(value) {
        this.files = value;
        if (!value) {
            this.onDelete();
        }
        else {
            this.filesNameString = this.getFilesNamesAsString(value);
        }
        this.cd.detectChanges();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    async onFilesSelected(files) {
        const hasValidNameLength = this.filesService.checkMaxLength(files);
        if (!hasValidNameLength) {
            this.onFileInvalidNameLength();
            return;
        }
        const haveValidTypes = this.filesService.haveValidExtensions(files, this.accept);
        if (!haveValidTypes) {
            this.onFileInvalidType();
            return;
        }
        const maxFileSizeInBytes = this.maxFileSizeInMegaBytes
            ? this.convertMegaBytesToBytes(this.maxFileSizeInMegaBytes)
            : null;
        const haveValidSizes = await this.filesService.haveValidSizes(files, maxFileSizeInBytes);
        if (!haveValidSizes) {
            await this.onFileInvalidSize();
            return;
        }
        this.files = files;
        this.filesNameString = this.getFilesNamesAsString(files);
        this.errors = false;
        if (this.isTooManyFiles()) {
            this.errors = true;
            this.formControl?.setErrors({ tooManyFiles: true });
            this.errorMessage = gettext('Too many files selected.');
            return;
        }
        if (this.hasEmptyFiles()) {
            this.errors = true;
            this.formControl?.setErrors({ emptyFiles: true });
            this.errorMessage = gettext('File must not be empty, select another one.');
            return;
        }
        const droppedFiles = this.compose(files);
        this.dropped.emit(droppedFiles);
        this.onChange(droppedFiles);
        this.cd.markForCheck();
    }
    onFileInvalidNameLength() {
        this.errors = true;
        this.formControl?.setErrors({ invalidNameLength: true });
        this.errorMessage = gettext('The filename is too long.');
    }
    onFileInvalidType() {
        this.errors = true;
        this.formControl?.setErrors({ invalidType: true });
        this.errorMessage = gettext('The selected file is not supported.');
    }
    async onFileInvalidSize() {
        const maxFileSizeInBytes = this.maxFileSizeInMegaBytes
            ? this.convertMegaBytesToBytes(this.maxFileSizeInMegaBytes)
            : null;
        const msg = gettext('The selected file is too large. The size limit is {{ limit }}.');
        const limit = this.bytes.transform(min([maxFileSizeInBytes, await this.filesService.loadBytesSizeLimit()]));
        this.errors = true;
        this.formControl?.setErrors({ invalidSize: true });
        this.errorMessage = this.translate.instant(msg, { limit });
    }
    convertMegaBytesToBytes(maxFileSizeInMegaBytes) {
        return maxFileSizeInMegaBytes * 1048576;
    }
    getFilesNamesAsString(files) {
        return map(files, ({ name }) => name).join(', ');
    }
    isFilesArrayEmpty() {
        return get(this, 'files.length', 0) === 0;
    }
    isTooManyFiles() {
        return get(this, 'files.length', 0) > this.maxAllowedFiles;
    }
    isFilesAnObjectOrArray() {
        return typeof this.files === 'object';
    }
    hasEmptyFiles() {
        let result = true;
        if (!this.isFilesArrayEmpty()) {
            result = this.isAnyFileEmpty();
        }
        return result;
    }
    isAnyFileEmpty() {
        return some(Array.from(this.files), ['size', 0]);
    }
    clearErrors() {
        delete this.errorMessage;
        this.errors = false;
        this.formControl?.setErrors(null);
    }
    preventDefault($event) {
        if ($event) {
            $event.preventDefault();
        }
    }
    compose(files) {
        return Array.from(files).map(file => ({
            file,
            readAsJson: async () => JSON.parse(await this.read(file, ReadAsType.TEXT)),
            readAsText: async () => this.read(file, ReadAsType.TEXT),
            readAsArrayBuffer: async () => this.read(file, ReadAsType.ARRAY_BUFFER),
            readAsBinaryString: async () => this.read(file, ReadAsType.BINARY_STRING),
            readAsDataURL: async () => this.read(file, ReadAsType.DATA_URL)
        }));
    }
    async read(file, type) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            switch (type) {
                case ReadAsType.TEXT: {
                    reader.readAsText(file);
                    break;
                }
                case ReadAsType.ARRAY_BUFFER: {
                    reader.readAsArrayBuffer(file);
                    break;
                }
                case ReadAsType.BINARY_STRING: {
                    reader.readAsBinaryString(file);
                    break;
                }
                case ReadAsType.DATA_URL: {
                    reader.readAsDataURL(file);
                    break;
                }
            }
            reader.onload = () => this.onLoad(reader, resolve, reject);
        });
    }
    onLoad(reader, resolve, reject) {
        if (reader.readyState !== 2) {
            return;
        }
        if (reader.error) {
            reject(reader.error);
        }
        resolve(reader.result);
    }
}
DropAreaComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DropAreaComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.FilesService }, { token: i2.TranslateService }, { token: i3.BytesPipe }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
DropAreaComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: DropAreaComponent, selector: "c8y-drop-area", inputs: { formControl: "formControl", title: "title", message: "message", icon: "icon", loadingMessage: "loadingMessage", forceHideList: "forceHideList", alwaysShow: "alwaysShow", clickToOpen: "clickToOpen", loading: "loading", progress: "progress", maxAllowedFiles: "maxAllowedFiles", files: "files", maxFileSizeInMegaBytes: "maxFileSizeInMegaBytes", accept: "accept" }, outputs: { dropped: "dropped" }, host: { listeners: { "keyup": "onkeyup($event)" } }, providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: DropAreaComponent, multi: true }], viewQueries: [{ propertyName: "area", first: true, predicate: ["area"], descendants: true, static: true }, { propertyName: "zone", first: true, predicate: ["zone"], descendants: true }, { propertyName: "picker", first: true, predicate: ["picker"], descendants: true }], ngImport: i0, template: "<div\n  class=\"drop-zone\"\n  *ngIf=\"!shouldShowFilesList()\"\n  [ngClass]=\"{ 'has-errors': errors }\"\n  [style.pointerEvents]=\"loading ? 'none' : 'auto'\"\n  #zone\n  (dragleave)=\"stopDragging()\"\n  (drop)=\"onDrop($event)\"\n  (dragover)=\"onOver()\"\n  [style.display]=\"isOver || alwaysShow || loading ? 'block' : 'none'\"\n  (click)=\"showPicker($event)\"\n  tabindex=\"0\"\n>\n  <div class=\"file-placeholder\" data-cy=\"c8y-file-placeholder--drop-zone\" [ngClass]=\"{ 'drag-over': isOver }\">\n    <div *ngIf=\"loading\" class=\"d-flex d-col p-4 flex-center\">\n      <div\n        class=\"progress progress-striped active m-0\"\n        *ngIf=\"progress !== -1\"\n        style=\"min-width: 50%\"\n      >\n        <div\n          [attr.aria-label]=\"progress + '%'\"\n          class=\"progress-bar\"\n          role=\"progressbar\"\n          aria-valuenow=\"0\"\n          aria-valuemin=\"0\"\n          aria-valuemax=\"100\"\n          [style.width]=\"progress + '%'\"\n        ></div>\n      </div>\n      <div class=\"spinner-snake\" *ngIf=\"progress === -1\"></div>\n      <p *ngIf=\"!hasDropAreaSmallClass\" class=\"m-t-auto m-b-auto m-r-8\">\n        {{ loadingMessage | translate }}\n      </p>\n    </div>\n\n    <div *ngIf=\"!loading\" class=\"hint-placeholder pointer\">\n      <i class=\"dlt-c8y-icon-{{ icon }}\"></i>\n      <p *ngIf=\"!errors\">\n        <b>{{ message | translate }}</b>\n        <br />\n        <span *ngIf=\"alwaysShow && clickToOpen\" translate></span>\n      </p>\n      <div *ngIf=\"errors\" class=\"has-errors\">\n        <p class=\"form-control-feedback-message\">\n          {{ errorMessage | translate }}\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div\n  class=\"drop-zone\"\n  *ngIf=\"shouldShowFilesList()\"\n  [style.display]=\"isOver || alwaysShow || loading ? 'block' : 'none'\"\n  tabindex=\"0\"\n>\n  <div *ngIf=\"loading\" class=\"p-absolute p-4 fit-w fit-h d-flex d-col j-c-center a-i-center\">\n    <div\n      class=\"progress progress-striped active m-0\"\n      *ngIf=\"progress !== -1\"\n      style=\"min-width: 80%\"\n    >\n      <div\n        [attr.aria-label]=\"progress + '%'\"\n        class=\"progress-bar\"\n        role=\"progressbar\"\n        aria-valuenow=\"0\"\n        aria-valuemin=\"0\"\n        aria-valuemax=\"100\"\n        [style.width]=\"progress + '%'\"\n      ></div>\n    </div>\n    <div *ngIf=\"progress === -1\">\n      <c8y-loading></c8y-loading>\n    </div>\n    <p *ngIf=\"!hasDropAreaSmallClass\" class=\"m-b-8\">\n      <strong>\n        {{ loadingMessage | translate }}\n      </strong>\n    </p>\n  </div>\n  <div *ngIf=\"!loading\" class=\"file-placeholder p-4\">\n    <div class=\"d-flex p-4 a-i-center\">\n      <i c8yIcon=\"file-o\" class=\"icon-20 m-r-8\"></i>\n      <span title=\"{{ filesNameString }}\" class=\"text-truncate\">\n        {{ filesNameString }}\n      </span>\n      <button\n        title=\"{{ 'Remove' | translate }}\"\n        [attr.aria-label]=\"'Remove' | translate\"\n        type=\"button\"\n        class=\"btn btn-dot btn-dot--danger showOnHover m-l-auto\"\n      >\n        <i c8yIcon=\"minus-circle\" (click)=\"onDelete()\"></i>\n      </button>\n    </div>\n  </div>\n</div>\n<label for=\"file\" class=\"sr-only\">{{ 'Select file' | translate }}</label>\n<input\n  #picker\n  *ngIf=\"clickToOpen\"\n  (change)=\"onPick($event)\"\n  (click)=\"picker.focus()\"\n  (blur)=\"onTouched()\"\n  [accept]=\"acceptedExts\"\n  [multiple]=\"maxAllowedFiles > 1\"\n  type=\"file\"\n  class=\"hidden\"\n  id=\"file\"\n/>\n<div #area [hidden]=\"isOver || loading\" (dragover)=\"toggle()\">\n  <ng-content></ng-content>\n</div>\n", dependencies: [{ kind: "directive", type: i4.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i5.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i6.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i7.LoadingComponent, selector: "c8y-loading" }, { kind: "pipe", type: i8.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DropAreaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-drop-area', providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: DropAreaComponent, multi: true }], template: "<div\n  class=\"drop-zone\"\n  *ngIf=\"!shouldShowFilesList()\"\n  [ngClass]=\"{ 'has-errors': errors }\"\n  [style.pointerEvents]=\"loading ? 'none' : 'auto'\"\n  #zone\n  (dragleave)=\"stopDragging()\"\n  (drop)=\"onDrop($event)\"\n  (dragover)=\"onOver()\"\n  [style.display]=\"isOver || alwaysShow || loading ? 'block' : 'none'\"\n  (click)=\"showPicker($event)\"\n  tabindex=\"0\"\n>\n  <div class=\"file-placeholder\" data-cy=\"c8y-file-placeholder--drop-zone\" [ngClass]=\"{ 'drag-over': isOver }\">\n    <div *ngIf=\"loading\" class=\"d-flex d-col p-4 flex-center\">\n      <div\n        class=\"progress progress-striped active m-0\"\n        *ngIf=\"progress !== -1\"\n        style=\"min-width: 50%\"\n      >\n        <div\n          [attr.aria-label]=\"progress + '%'\"\n          class=\"progress-bar\"\n          role=\"progressbar\"\n          aria-valuenow=\"0\"\n          aria-valuemin=\"0\"\n          aria-valuemax=\"100\"\n          [style.width]=\"progress + '%'\"\n        ></div>\n      </div>\n      <div class=\"spinner-snake\" *ngIf=\"progress === -1\"></div>\n      <p *ngIf=\"!hasDropAreaSmallClass\" class=\"m-t-auto m-b-auto m-r-8\">\n        {{ loadingMessage | translate }}\n      </p>\n    </div>\n\n    <div *ngIf=\"!loading\" class=\"hint-placeholder pointer\">\n      <i class=\"dlt-c8y-icon-{{ icon }}\"></i>\n      <p *ngIf=\"!errors\">\n        <b>{{ message | translate }}</b>\n        <br />\n        <span *ngIf=\"alwaysShow && clickToOpen\" translate></span>\n      </p>\n      <div *ngIf=\"errors\" class=\"has-errors\">\n        <p class=\"form-control-feedback-message\">\n          {{ errorMessage | translate }}\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div\n  class=\"drop-zone\"\n  *ngIf=\"shouldShowFilesList()\"\n  [style.display]=\"isOver || alwaysShow || loading ? 'block' : 'none'\"\n  tabindex=\"0\"\n>\n  <div *ngIf=\"loading\" class=\"p-absolute p-4 fit-w fit-h d-flex d-col j-c-center a-i-center\">\n    <div\n      class=\"progress progress-striped active m-0\"\n      *ngIf=\"progress !== -1\"\n      style=\"min-width: 80%\"\n    >\n      <div\n        [attr.aria-label]=\"progress + '%'\"\n        class=\"progress-bar\"\n        role=\"progressbar\"\n        aria-valuenow=\"0\"\n        aria-valuemin=\"0\"\n        aria-valuemax=\"100\"\n        [style.width]=\"progress + '%'\"\n      ></div>\n    </div>\n    <div *ngIf=\"progress === -1\">\n      <c8y-loading></c8y-loading>\n    </div>\n    <p *ngIf=\"!hasDropAreaSmallClass\" class=\"m-b-8\">\n      <strong>\n        {{ loadingMessage | translate }}\n      </strong>\n    </p>\n  </div>\n  <div *ngIf=\"!loading\" class=\"file-placeholder p-4\">\n    <div class=\"d-flex p-4 a-i-center\">\n      <i c8yIcon=\"file-o\" class=\"icon-20 m-r-8\"></i>\n      <span title=\"{{ filesNameString }}\" class=\"text-truncate\">\n        {{ filesNameString }}\n      </span>\n      <button\n        title=\"{{ 'Remove' | translate }}\"\n        [attr.aria-label]=\"'Remove' | translate\"\n        type=\"button\"\n        class=\"btn btn-dot btn-dot--danger showOnHover m-l-auto\"\n      >\n        <i c8yIcon=\"minus-circle\" (click)=\"onDelete()\"></i>\n      </button>\n    </div>\n  </div>\n</div>\n<label for=\"file\" class=\"sr-only\">{{ 'Select file' | translate }}</label>\n<input\n  #picker\n  *ngIf=\"clickToOpen\"\n  (change)=\"onPick($event)\"\n  (click)=\"picker.focus()\"\n  (blur)=\"onTouched()\"\n  [accept]=\"acceptedExts\"\n  [multiple]=\"maxAllowedFiles > 1\"\n  type=\"file\"\n  class=\"hidden\"\n  id=\"file\"\n/>\n<div #area [hidden]=\"isOver || loading\" (dragover)=\"toggle()\">\n  <ng-content></ng-content>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.FilesService }, { type: i2.TranslateService }, { type: i3.BytesPipe }, { type: i0.ElementRef }]; }, propDecorators: { formControl: [{
                type: Input
            }], title: [{
                type: Input
            }], message: [{
                type: Input
            }], icon: [{
                type: Input
            }], loadingMessage: [{
                type: Input
            }], forceHideList: [{
                type: Input
            }], alwaysShow: [{
                type: Input
            }], clickToOpen: [{
                type: Input
            }], loading: [{
                type: Input
            }], progress: [{
                type: Input
            }], dropped: [{
                type: Output
            }], maxAllowedFiles: [{
                type: Input
            }], files: [{
                type: Input
            }], maxFileSizeInMegaBytes: [{
                type: Input
            }], accept: [{
                type: Input
            }], area: [{
                type: ViewChild,
                args: ['area', { static: true }]
            }], zone: [{
                type: ViewChild,
                args: ['zone', { static: false }]
            }], picker: [{
                type: ViewChild,
                args: ['picker', { static: false }]
            }], onkeyup: [{
                type: HostListener,
                args: ['keyup', ['$event']]
            }] } });
var ReadAsType;
(function (ReadAsType) {
    ReadAsType[ReadAsType["TEXT"] = 0] = "TEXT";
    ReadAsType[ReadAsType["DATA_URL"] = 1] = "DATA_URL";
    ReadAsType[ReadAsType["ARRAY_BUFFER"] = 2] = "ARRAY_BUFFER";
    ReadAsType[ReadAsType["BINARY_STRING"] = 3] = "BINARY_STRING";
})(ReadAsType || (ReadAsType = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcC1hcmVhLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvZHJvcC1hcmVhL2Ryb3AtYXJlYS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9jb3JlL2Ryb3AtYXJlYS9kcm9wLWFyZWEuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUVMLE1BQU0sRUFDTixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxlQUFlLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUxRixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ2hELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7O0FBRTFDOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBT0gsTUFBTSxPQUFPLGlCQUFpQjtJQXdENUIsWUFDVSxFQUFxQixFQUNyQixZQUEwQixFQUMxQixTQUEyQixFQUMzQixLQUFnQixFQUNoQixHQUFlO1FBSmYsT0FBRSxHQUFGLEVBQUUsQ0FBbUI7UUFDckIsaUJBQVksR0FBWixZQUFZLENBQWM7UUFDMUIsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFDM0IsVUFBSyxHQUFMLEtBQUssQ0FBVztRQUNoQixRQUFHLEdBQUgsR0FBRyxDQUFZO1FBM0RoQixVQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWEs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RSxlQUFlLGFBRWQsQ0FBQyxFQUFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLG1CQUFtQixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQzttTkFHL0UsV0FBVztzQkFBbkIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0csT0FBTztzQkFBZixLQUFLO2dCQUNHLElBQUk7c0JBQVosS0FBSztnQkFDRyxjQUFjO3NCQUF0QixLQUFLO2dCQUNHLGFBQWE7c0JBQXJCLEtBQUs7Z0JBRUcsVUFBVTtzQkFBbEIsS0FBSztnQkFDRyxXQUFXO3NCQUFuQixLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFJRyxRQUFRO3NCQUFoQixLQUFLO2dCQUNJLE9BQU87c0JBQWhCLE1BQU07Z0JBQ0UsZUFBZTtzQkFBdkIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0csc0JBQXNCO3NCQUE5QixLQUFLO2dCQTBCRyxNQUFNO3NCQUFkLEtBQUs7Z0JBUStCLElBQUk7c0JBQXhDLFNBQVM7dUJBQUMsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFDRyxJQUFJO3NCQUF6QyxTQUFTO3VCQUFDLE1BQU0sRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Z0JBQ0ksTUFBTTtzQkFBN0MsU0FBUzt1QkFBQyxRQUFRLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO2dCQVd0QyxPQUFPO3NCQUROLFlBQVk7dUJBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDOztBQXFTbkMsSUFBSyxVQUtKO0FBTEQsV0FBSyxVQUFVO0lBQ2IsMkNBQUksQ0FBQTtJQUNKLG1EQUFRLENBQUE7SUFDUiwyREFBWSxDQUFBO0lBQ1osNkRBQWEsQ0FBQTtBQUNmLENBQUMsRUFMSSxVQUFVLEtBQVYsVUFBVSxRQUtkIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0TGlzdGVuZXIsXG4gIElucHV0LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SLCBBYnN0cmFjdENvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IGdldCwgbWFwLCBzb21lLCBtaW4gfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgQnl0ZXNQaXBlIH0gZnJvbSAnLi4vY29tbW9uL2J5dGVzLnBpcGUnO1xuaW1wb3J0IHsgRmlsZXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2ZpbGVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ2V0dGV4dCB9IGZyb20gJy4uL2kxOG4vZ2V0dGV4dCc7XG5cbi8qKlxuICogQSBkcm9wLXpvbmUgd2hpY2ggaXMgYSBmaWxlIHNlbGVjdG9yIGFsbG93aW5nIHVzZXJzIHRvIHNlbGVjdCBmaWxlKHMpIGZyb20gdGhlaXIgZmlsZSBzeXN0ZW0sIGVpdGhlciBuYXRpdmVseSBvciBieSBkcmFnIGFuZCBkcm9wLlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogIDxkaXY+XG4gKiAgICA8Yzh5LWRyb3AtYXJlYVxuICogICAgICAoZHJvcHBlZCk9XCJ1cGxvYWRGaWxlKCRldmVudClcIlxuICogICAgICBbaWNvbl09XCIndXBsb2FkJ1wiXG4gKiAgICAgIFthY2NlcHRdPVwiJy56aXAsLjd6LHZpZGVvJ1wiPlxuICogICAgPC9jOHktZHJvcC1hcmVhPlxuICogIDwvZGl2PlxuICogYGBgXG4gKi9cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LWRyb3AtYXJlYScsXG4gIHRlbXBsYXRlVXJsOiAnLi9kcm9wLWFyZWEuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogRHJvcEFyZWFDb21wb25lbnQsIG11bHRpOiB0cnVlIH1dXG59KVxuZXhwb3J0IGNsYXNzIERyb3BBcmVhQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gIEBJbnB1dCgpIGZvcm1Db250cm9sOiBBYnN0cmFjdENvbnRyb2w8YW55LCBhbnk+O1xuICBASW5wdXQoKSB0aXRsZSA9IGdldHRleHQoJ1VwbG9hZCBmaWxlJyk7XG4gIEBJbnB1dCgpIG1lc3NhZ2UgPSBnZXR0ZXh0KCdEcm9wIGZpbGUgaGVyZScpO1xuICBASW5wdXQoKSBpY29uID0gJ3BsdXMtc3F1YXJlJztcbiAgQElucHV0KCkgbG9hZGluZ01lc3NhZ2UgPSBnZXR0ZXh0KCdVcGxvYWRpbmfigKYnKTtcbiAgQElucHV0KCkgZm9yY2VIaWRlTGlzdCA9IGZhbHNlO1xuICAvKiogQWZmZWN0cyBkaXNwbGF5aW5nIGJvdGggdGhlIGRyb3Agem9uZSBhbmQgdGhlIGxpc3Qgb2YgZHJvcHBlZCBmaWxlcy4gKi9cbiAgQElucHV0KCkgYWx3YXlzU2hvdyA9IGZhbHNlO1xuICBASW5wdXQoKSBjbGlja1RvT3BlbiA9IHRydWU7XG4gIEBJbnB1dCgpIGxvYWRpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIHVwbG9hZCBhcyBhIHBlcmNlbnRhZ2UuIElmIG5vdCBnaXZlbiBhIHNwaW5uZXIgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAqL1xuICBASW5wdXQoKSBwcm9ncmVzcyA9IC0xOyAvLyAtMSA9IHNwaW5uZXJcbiAgQE91dHB1dCgpIGRyb3BwZWQ6IEV2ZW50RW1pdHRlcjxEcm9wcGVkRmlsZVtdPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQElucHV0KCkgbWF4QWxsb3dlZEZpbGVzID0gSW5maW5pdHk7XG4gIEBJbnB1dCgpIGZpbGVzOiBGaWxlTGlzdDtcbiAgQElucHV0KCkgbWF4RmlsZVNpemVJbk1lZ2FCeXRlczogbnVtYmVyO1xuICAvKiogU3BlY2lmaWVzIGEgZmlsdGVyIGZvciB3aGF0IGZpbGUgdHlwZXMgdGhlIHVzZXIgY2FuIHBpY2sgZnJvbSB0aGUgZmlsZSBpbnB1dCBkaWFsb2cgYm94LlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBTcGVjaWZ5IGZpbGUgdHlwZXMgYnkgZXh0ZW5zaW9uczpcbiAgICogYGBgaHRtbFxuICAgKiAgLi4uXG4gICAqICBbYWNjZXB0XT1cIicuemlwLC43eidcIlxuICAgKiAgLi4uXG4gICAqIGBgYFxuICAgKlxuICAgKiBTcGVjaWZ5IGZpbGUgdHlwZXMgYnkgZXh0ZW5zaW9ucyBhbmQgZ2VuZXJpYyB0eXBlcyBbR0VORVJJQ19GSUxFX1RZUEVde0BsaW5rIEdFTkVSSUNfRklMRV9UWVBFfTpcbiAgICogYGBgaHRtbFxuICAgKiAgLi4uXG4gICAqICBbYWNjZXB0XT1cIicucGRmLGFyY2hpdmUnXCJcbiAgICogIC4uLlxuICAgKiBgYGBcbiAgICpcbiAgICogU3BlY2lmeSBmaWxlIHR5cGVzIGJ5IGdlbmVyaWMgdHlwZXMgW0dFTkVSSUNfRklMRV9UWVBFXXtAbGluayBHRU5FUklDX0ZJTEVfVFlQRX06XG4gICAqICBgYGBodG1sXG4gICAqICAuLi5cbiAgICogIFthY2NlcHRdPVwiJ2FyY2hpdmUsdmlkZW8nXCJcbiAgICogIC4uLlxuICAgKlxuICAgKiBgYGBcbiAgICovXG4gIEBJbnB1dCgpIGFjY2VwdDogc3RyaW5nO1xuICBpc092ZXIgPSBmYWxzZTtcbiAgZXJyb3JzID0gZmFsc2U7XG4gIGVycm9yTWVzc2FnZTogc3RyaW5nO1xuICBmaWxlc05hbWVTdHJpbmc6IHN0cmluZztcbiAgYWNjZXB0ZWRFeHRzOiBzdHJpbmdbXTtcbiAgaGFzRHJvcEFyZWFTbWFsbENsYXNzOiBib29sZWFuO1xuXG4gIEBWaWV3Q2hpbGQoJ2FyZWEnLCB7IHN0YXRpYzogdHJ1ZSB9KSBhcmVhOiBFbGVtZW50UmVmO1xuICBAVmlld0NoaWxkKCd6b25lJywgeyBzdGF0aWM6IGZhbHNlIH0pIHpvbmU6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ3BpY2tlcicsIHsgc3RhdGljOiBmYWxzZSB9KSBwaWNrZXI6IEVsZW1lbnRSZWY7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBmaWxlc1NlcnZpY2U6IEZpbGVzU2VydmljZSxcbiAgICBwcml2YXRlIHRyYW5zbGF0ZTogVHJhbnNsYXRlU2VydmljZSxcbiAgICBwcml2YXRlIGJ5dGVzOiBCeXRlc1BpcGUsXG4gICAgcHJpdmF0ZSByZWY6IEVsZW1lbnRSZWZcbiAgKSB7fVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2tleXVwJywgWyckZXZlbnQnXSlcbiAgb25rZXl1cChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIHRoaXMucGlja2VyLm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmFjY2VwdGVkRXh0cyA9IHRoaXMuZmlsZXNTZXJ2aWNlLmV4dHJhY3RGaWxlRXh0ZW5zaW9ucyh0aGlzLmFjY2VwdCkubWFwKHQgPT4gYC4ke3R9YCk7XG4gICAgdGhpcy5hbHdheXNTaG93ID0gdGhpcy5hbHdheXNTaG93IHx8IHRoaXMuYXJlYS5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcblxuICAgIGlmICh0aGlzLmZpbGVzICYmIHRoaXMuaXNGaWxlc0FuT2JqZWN0T3JBcnJheSgpICYmIHRoaXMuZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5vbkZpbGVzU2VsZWN0ZWQodGhpcy5maWxlcyk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgIHRoaXMuaGFzRHJvcEFyZWFTbWFsbENsYXNzID0gdGhpcy5yZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2Ryb3AtYXJlYS1zbScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHN0eWxlIG9mIHRoZSBkcm9wIHpvbmUgZWxlbWVudCB3aGVuIGEgZmlsZSBpcyBkcmFnZ2VkIG92ZXIgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICB0aGlzLnpvbmUubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLmFyZWEubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgIHRoaXMub25PdmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MgY29tcHV0ZXIgYnJvd3NlciB3aXRoIGZpbGVzIHRvIGRyb3AgaW50byBkcm9wLWFyZWEgem9uZS5cbiAgICovXG4gIHNob3dQaWNrZXIoJGV2ZW50Pyk6IHZvaWQge1xuICAgIHRoaXMucHJldmVudERlZmF1bHQoJGV2ZW50KTtcbiAgICB0aGlzLnBpY2tlci5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgdGhpcy5waWNrZXIubmF0aXZlRWxlbWVudC5jbGljaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGZpbGUgaXMgb24gb3ZlciBkcm9wIGFyZWEsIGJ1dCBub3QgZHJvcHBlZC5cbiAgICovXG4gIG9uT3ZlcigpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNPdmVyKSB7XG4gICAgICB0aGlzLmlzT3ZlciA9IHRydWU7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMucHJldmVudERlZmF1bHQpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMucHJldmVudERlZmF1bHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBmaWxlIGlzIGRyb3BwZWQuXG4gICAqL1xuICBvblBpY2soJGV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5lcnJvcnMgPSBmYWxzZTtcbiAgICB0aGlzLnByZXZlbnREZWZhdWx0KCRldmVudCk7XG4gICAgdGhpcy5vbkZpbGVzU2VsZWN0ZWQoJGV2ZW50LnRhcmdldC5maWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGZpbGUgd2hlbiBpdCBpcyBkcm9wcGVkIGludG8gZHJvcC1hcmVhLlxuICAgKi9cbiAgb25Ecm9wKCRldmVudCk6IHZvaWQge1xuICAgIHRoaXMucHJldmVudERlZmF1bHQoJGV2ZW50KTtcbiAgICB0aGlzLm9uRmlsZXNTZWxlY3RlZCgkZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKTtcbiAgICB0aGlzLnN0b3BEcmFnZ2luZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBjb25kaXRpb24gd2hhdCBzaG91bGQgYmUgZGlzcGxheWVkOiBkcm9wLWFyZWEgem9uZSBvciBsaXN0IG9mIGRyb3BwZWQgZmlsZXMuXG4gICAqL1xuICBzaG91bGRTaG93RmlsZXNMaXN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzRmlsZXNBbk9iamVjdE9yQXJyYXkoKSAmJlxuICAgICAgIXRoaXMuZm9yY2VIaWRlTGlzdCAmJlxuICAgICAgdGhpcy5hbHdheXNTaG93ICYmXG4gICAgICAhdGhpcy5pc0ZpbGVzQXJyYXlFbXB0eSgpICYmXG4gICAgICAhdGhpcy5oYXNFbXB0eUZpbGVzKCkgJiZcbiAgICAgICF0aGlzLmlzVG9vTWFueUZpbGVzKClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGZpbGUgaXMgcGlja2VkIG92ZXIgd2ViIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgc3RvcERyYWdnaW5nKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpcy5wcmV2ZW50RGVmYXVsdCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMucHJldmVudERlZmF1bHQpO1xuICAgIHRoaXMuaXNPdmVyID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGZpbGVzIGFscmVhZHkgZHJvcHBlZCBmaWxlcy5cbiAgICovXG4gIG9uRGVsZXRlKCkge1xuICAgIGRlbGV0ZSB0aGlzLmZpbGVzO1xuICAgIGRlbGV0ZSB0aGlzLmZpbGVzTmFtZVN0cmluZztcbiAgICB0aGlzLmNsZWFyRXJyb3JzKCk7XG4gICAgdGhpcy5kcm9wcGVkLmVtaXQobnVsbCk7XG4gICAgdGhpcy5vbkNoYW5nZShudWxsKTtcbiAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgb25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkID0gXyA9PiB1bmRlZmluZWQ7XG4gIG9uVG91Y2hlZDogKCkgPT4gdm9pZCA9ICgpID0+IHVuZGVmaW5lZDtcblxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLmZpbGVzID0gdmFsdWU7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdGhpcy5vbkRlbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbGVzTmFtZVN0cmluZyA9IHRoaXMuZ2V0RmlsZXNOYW1lc0FzU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG4gICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgb25GaWxlc1NlbGVjdGVkKGZpbGVzOiBGaWxlTGlzdCkge1xuICAgIGNvbnN0IGhhc1ZhbGlkTmFtZUxlbmd0aCA9IHRoaXMuZmlsZXNTZXJ2aWNlLmNoZWNrTWF4TGVuZ3RoKGZpbGVzKTtcbiAgICBpZiAoIWhhc1ZhbGlkTmFtZUxlbmd0aCkge1xuICAgICAgdGhpcy5vbkZpbGVJbnZhbGlkTmFtZUxlbmd0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhdmVWYWxpZFR5cGVzID0gdGhpcy5maWxlc1NlcnZpY2UuaGF2ZVZhbGlkRXh0ZW5zaW9ucyhmaWxlcywgdGhpcy5hY2NlcHQpO1xuICAgIGlmICghaGF2ZVZhbGlkVHlwZXMpIHtcbiAgICAgIHRoaXMub25GaWxlSW52YWxpZFR5cGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhGaWxlU2l6ZUluQnl0ZXMgPSB0aGlzLm1heEZpbGVTaXplSW5NZWdhQnl0ZXNcbiAgICAgID8gdGhpcy5jb252ZXJ0TWVnYUJ5dGVzVG9CeXRlcyh0aGlzLm1heEZpbGVTaXplSW5NZWdhQnl0ZXMpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgaGF2ZVZhbGlkU2l6ZXMgPSBhd2FpdCB0aGlzLmZpbGVzU2VydmljZS5oYXZlVmFsaWRTaXplcyhmaWxlcywgbWF4RmlsZVNpemVJbkJ5dGVzKTtcbiAgICBpZiAoIWhhdmVWYWxpZFNpemVzKSB7XG4gICAgICBhd2FpdCB0aGlzLm9uRmlsZUludmFsaWRTaXplKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5maWxlcyA9IGZpbGVzO1xuICAgIHRoaXMuZmlsZXNOYW1lU3RyaW5nID0gdGhpcy5nZXRGaWxlc05hbWVzQXNTdHJpbmcoZmlsZXMpO1xuICAgIHRoaXMuZXJyb3JzID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc1Rvb01hbnlGaWxlcygpKSB7XG4gICAgICB0aGlzLmVycm9ycyA9IHRydWU7XG4gICAgICB0aGlzLmZvcm1Db250cm9sPy5zZXRFcnJvcnMoeyB0b29NYW55RmlsZXM6IHRydWUgfSk7XG4gICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGdldHRleHQoJ1RvbyBtYW55IGZpbGVzIHNlbGVjdGVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0VtcHR5RmlsZXMoKSkge1xuICAgICAgdGhpcy5lcnJvcnMgPSB0cnVlO1xuICAgICAgdGhpcy5mb3JtQ29udHJvbD8uc2V0RXJyb3JzKHsgZW1wdHlGaWxlczogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gZ2V0dGV4dCgnRmlsZSBtdXN0IG5vdCBiZSBlbXB0eSwgc2VsZWN0IGFub3RoZXIgb25lLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRyb3BwZWRGaWxlczogRHJvcHBlZEZpbGVbXSA9IHRoaXMuY29tcG9zZShmaWxlcyk7XG4gICAgdGhpcy5kcm9wcGVkLmVtaXQoZHJvcHBlZEZpbGVzKTtcbiAgICB0aGlzLm9uQ2hhbmdlKGRyb3BwZWRGaWxlcyk7XG4gICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgb25GaWxlSW52YWxpZE5hbWVMZW5ndGgoKSB7XG4gICAgdGhpcy5lcnJvcnMgPSB0cnVlO1xuICAgIHRoaXMuZm9ybUNvbnRyb2w/LnNldEVycm9ycyh7IGludmFsaWROYW1lTGVuZ3RoOiB0cnVlIH0pO1xuICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gZ2V0dGV4dCgnVGhlIGZpbGVuYW1lIGlzIHRvbyBsb25nLicpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkZpbGVJbnZhbGlkVHlwZSgpIHtcbiAgICB0aGlzLmVycm9ycyA9IHRydWU7XG4gICAgdGhpcy5mb3JtQ29udHJvbD8uc2V0RXJyb3JzKHsgaW52YWxpZFR5cGU6IHRydWUgfSk7XG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBnZXR0ZXh0KCdUaGUgc2VsZWN0ZWQgZmlsZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBvbkZpbGVJbnZhbGlkU2l6ZSgpIHtcbiAgICBjb25zdCBtYXhGaWxlU2l6ZUluQnl0ZXMgPSB0aGlzLm1heEZpbGVTaXplSW5NZWdhQnl0ZXNcbiAgICAgID8gdGhpcy5jb252ZXJ0TWVnYUJ5dGVzVG9CeXRlcyh0aGlzLm1heEZpbGVTaXplSW5NZWdhQnl0ZXMpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgbXNnID0gZ2V0dGV4dCgnVGhlIHNlbGVjdGVkIGZpbGUgaXMgdG9vIGxhcmdlLiBUaGUgc2l6ZSBsaW1pdCBpcyB7eyBsaW1pdCB9fS4nKTtcbiAgICBjb25zdCBsaW1pdCA9IHRoaXMuYnl0ZXMudHJhbnNmb3JtKFxuICAgICAgbWluKFttYXhGaWxlU2l6ZUluQnl0ZXMsIGF3YWl0IHRoaXMuZmlsZXNTZXJ2aWNlLmxvYWRCeXRlc1NpemVMaW1pdCgpXSlcbiAgICApO1xuICAgIHRoaXMuZXJyb3JzID0gdHJ1ZTtcbiAgICB0aGlzLmZvcm1Db250cm9sPy5zZXRFcnJvcnMoeyBpbnZhbGlkU2l6ZTogdHJ1ZSB9KTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IHRoaXMudHJhbnNsYXRlLmluc3RhbnQobXNnLCB7IGxpbWl0IH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjb252ZXJ0TWVnYUJ5dGVzVG9CeXRlcyhtYXhGaWxlU2l6ZUluTWVnYUJ5dGVzOiBTaXplSW5NZWdhQnl0ZXMpOiBTaXplSW5CeXRlcyB7XG4gICAgcmV0dXJuIG1heEZpbGVTaXplSW5NZWdhQnl0ZXMgKiAxXzA0OF81NzY7XG4gIH1cblxuICBwcml2YXRlIGdldEZpbGVzTmFtZXNBc1N0cmluZyhmaWxlczogRmlsZUxpc3QpOiBzdHJpbmcge1xuICAgIHJldHVybiBtYXAoZmlsZXMsICh7IG5hbWUgfSkgPT4gbmFtZSkuam9pbignLCAnKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNGaWxlc0FycmF5RW1wdHkoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCAnZmlsZXMubGVuZ3RoJywgMCkgPT09IDA7XG4gIH1cblxuICBwcml2YXRlIGlzVG9vTWFueUZpbGVzKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgJ2ZpbGVzLmxlbmd0aCcsIDApID4gdGhpcy5tYXhBbGxvd2VkRmlsZXM7XG4gIH1cblxuICBwcml2YXRlIGlzRmlsZXNBbk9iamVjdE9yQXJyYXkoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmZpbGVzID09PSAnb2JqZWN0JztcbiAgfVxuXG4gIHByaXZhdGUgaGFzRW1wdHlGaWxlcygpIHtcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuaXNGaWxlc0FycmF5RW1wdHkoKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5pc0FueUZpbGVFbXB0eSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBpc0FueUZpbGVFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc29tZShBcnJheS5mcm9tKHRoaXMuZmlsZXMpLCBbJ3NpemUnLCAwXSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyRXJyb3JzKCkge1xuICAgIGRlbGV0ZSB0aGlzLmVycm9yTWVzc2FnZTtcbiAgICB0aGlzLmVycm9ycyA9IGZhbHNlO1xuICAgIHRoaXMuZm9ybUNvbnRyb2w/LnNldEVycm9ycyhudWxsKTtcbiAgfVxuXG4gIHByaXZhdGUgcHJldmVudERlZmF1bHQoJGV2ZW50Pykge1xuICAgIGlmICgkZXZlbnQpIHtcbiAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29tcG9zZShmaWxlczogRmlsZUxpc3QpOiBEcm9wcGVkRmlsZVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlcykubWFwKGZpbGUgPT4gKHtcbiAgICAgIGZpbGUsXG4gICAgICByZWFkQXNKc29uOiBhc3luYyAoKSA9PiBKU09OLnBhcnNlKGF3YWl0IHRoaXMucmVhZChmaWxlLCBSZWFkQXNUeXBlLlRFWFQpKSxcbiAgICAgIHJlYWRBc1RleHQ6IGFzeW5jICgpID0+IHRoaXMucmVhZChmaWxlLCBSZWFkQXNUeXBlLlRFWFQpLFxuICAgICAgcmVhZEFzQXJyYXlCdWZmZXI6IGFzeW5jICgpID0+IHRoaXMucmVhZChmaWxlLCBSZWFkQXNUeXBlLkFSUkFZX0JVRkZFUiksXG4gICAgICByZWFkQXNCaW5hcnlTdHJpbmc6IGFzeW5jICgpID0+IHRoaXMucmVhZChmaWxlLCBSZWFkQXNUeXBlLkJJTkFSWV9TVFJJTkcpLFxuICAgICAgcmVhZEFzRGF0YVVSTDogYXN5bmMgKCkgPT4gdGhpcy5yZWFkKGZpbGUsIFJlYWRBc1R5cGUuREFUQV9VUkwpXG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWFkKGZpbGUsIHR5cGU6IFJlYWRBc1R5cGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSZWFkQXNUeXBlLlRFWFQ6IHtcbiAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFJlYWRBc1R5cGUuQVJSQVlfQlVGRkVSOiB7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUmVhZEFzVHlwZS5CSU5BUllfU1RSSU5HOiB7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyhmaWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFJlYWRBc1R5cGUuREFUQV9VUkw6IHtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHRoaXMub25Mb2FkKHJlYWRlciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Mb2FkKHJlYWRlciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHJlYWRlci5yZWFkeVN0YXRlICE9PSAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZWFkZXIuZXJyb3IpIHtcbiAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgIH1cbiAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcHBlZEZpbGUge1xuICBmaWxlOiBGaWxlO1xuICByZWFkQXNUZXh0KCk7XG4gIHJlYWRBc0FycmF5QnVmZmVyKCk7XG4gIHJlYWRBc0JpbmFyeVN0cmluZygpO1xuICByZWFkQXNEYXRhVVJMKCk7XG4gIHJlYWRBc0pzb24oKTtcbn1cblxuZW51bSBSZWFkQXNUeXBlIHtcbiAgVEVYVCxcbiAgREFUQV9VUkwsXG4gIEFSUkFZX0JVRkZFUixcbiAgQklOQVJZX1NUUklOR1xufVxuXG50eXBlIFNpemVJbk1lZ2FCeXRlcyA9IG51bWJlcjtcbnR5cGUgU2l6ZUluQnl0ZXMgPSBudW1iZXI7XG4iLCI8ZGl2XG4gIGNsYXNzPVwiZHJvcC16b25lXCJcbiAgKm5nSWY9XCIhc2hvdWxkU2hvd0ZpbGVzTGlzdCgpXCJcbiAgW25nQ2xhc3NdPVwieyAnaGFzLWVycm9ycyc6IGVycm9ycyB9XCJcbiAgW3N0eWxlLnBvaW50ZXJFdmVudHNdPVwibG9hZGluZyA/ICdub25lJyA6ICdhdXRvJ1wiXG4gICN6b25lXG4gIChkcmFnbGVhdmUpPVwic3RvcERyYWdnaW5nKClcIlxuICAoZHJvcCk9XCJvbkRyb3AoJGV2ZW50KVwiXG4gIChkcmFnb3Zlcik9XCJvbk92ZXIoKVwiXG4gIFtzdHlsZS5kaXNwbGF5XT1cImlzT3ZlciB8fCBhbHdheXNTaG93IHx8IGxvYWRpbmcgPyAnYmxvY2snIDogJ25vbmUnXCJcbiAgKGNsaWNrKT1cInNob3dQaWNrZXIoJGV2ZW50KVwiXG4gIHRhYmluZGV4PVwiMFwiXG4+XG4gIDxkaXYgY2xhc3M9XCJmaWxlLXBsYWNlaG9sZGVyXCIgZGF0YS1jeT1cImM4eS1maWxlLXBsYWNlaG9sZGVyLS1kcm9wLXpvbmVcIiBbbmdDbGFzc109XCJ7ICdkcmFnLW92ZXInOiBpc092ZXIgfVwiPlxuICAgIDxkaXYgKm5nSWY9XCJsb2FkaW5nXCIgY2xhc3M9XCJkLWZsZXggZC1jb2wgcC00IGZsZXgtY2VudGVyXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwicHJvZ3Jlc3MgcHJvZ3Jlc3Mtc3RyaXBlZCBhY3RpdmUgbS0wXCJcbiAgICAgICAgKm5nSWY9XCJwcm9ncmVzcyAhPT0gLTFcIlxuICAgICAgICBzdHlsZT1cIm1pbi13aWR0aDogNTAlXCJcbiAgICAgID5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicHJvZ3Jlc3MgKyAnJSdcIlxuICAgICAgICAgIGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCJcbiAgICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxuICAgICAgICAgIGFyaWEtdmFsdWVub3c9XCIwXCJcbiAgICAgICAgICBhcmlhLXZhbHVlbWluPVwiMFwiXG4gICAgICAgICAgYXJpYS12YWx1ZW1heD1cIjEwMFwiXG4gICAgICAgICAgW3N0eWxlLndpZHRoXT1cInByb2dyZXNzICsgJyUnXCJcbiAgICAgICAgPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lci1zbmFrZVwiICpuZ0lmPVwicHJvZ3Jlc3MgPT09IC0xXCI+PC9kaXY+XG4gICAgICA8cCAqbmdJZj1cIiFoYXNEcm9wQXJlYVNtYWxsQ2xhc3NcIiBjbGFzcz1cIm0tdC1hdXRvIG0tYi1hdXRvIG0tci04XCI+XG4gICAgICAgIHt7IGxvYWRpbmdNZXNzYWdlIHwgdHJhbnNsYXRlIH19XG4gICAgICA8L3A+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2ICpuZ0lmPVwiIWxvYWRpbmdcIiBjbGFzcz1cImhpbnQtcGxhY2Vob2xkZXIgcG9pbnRlclwiPlxuICAgICAgPGkgY2xhc3M9XCJkbHQtYzh5LWljb24te3sgaWNvbiB9fVwiPjwvaT5cbiAgICAgIDxwICpuZ0lmPVwiIWVycm9yc1wiPlxuICAgICAgICA8Yj57eyBtZXNzYWdlIHwgdHJhbnNsYXRlIH19PC9iPlxuICAgICAgICA8YnIgLz5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJhbHdheXNTaG93ICYmIGNsaWNrVG9PcGVuXCIgdHJhbnNsYXRlPjwvc3Bhbj5cbiAgICAgIDwvcD5cbiAgICAgIDxkaXYgKm5nSWY9XCJlcnJvcnNcIiBjbGFzcz1cImhhcy1lcnJvcnNcIj5cbiAgICAgICAgPHAgY2xhc3M9XCJmb3JtLWNvbnRyb2wtZmVlZGJhY2stbWVzc2FnZVwiPlxuICAgICAgICAgIHt7IGVycm9yTWVzc2FnZSB8IHRyYW5zbGF0ZSB9fVxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPGRpdlxuICBjbGFzcz1cImRyb3Atem9uZVwiXG4gICpuZ0lmPVwic2hvdWxkU2hvd0ZpbGVzTGlzdCgpXCJcbiAgW3N0eWxlLmRpc3BsYXldPVwiaXNPdmVyIHx8IGFsd2F5c1Nob3cgfHwgbG9hZGluZyA/ICdibG9jaycgOiAnbm9uZSdcIlxuICB0YWJpbmRleD1cIjBcIlxuPlxuICA8ZGl2ICpuZ0lmPVwibG9hZGluZ1wiIGNsYXNzPVwicC1hYnNvbHV0ZSBwLTQgZml0LXcgZml0LWggZC1mbGV4IGQtY29sIGotYy1jZW50ZXIgYS1pLWNlbnRlclwiPlxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwicHJvZ3Jlc3MgcHJvZ3Jlc3Mtc3RyaXBlZCBhY3RpdmUgbS0wXCJcbiAgICAgICpuZ0lmPVwicHJvZ3Jlc3MgIT09IC0xXCJcbiAgICAgIHN0eWxlPVwibWluLXdpZHRoOiA4MCVcIlxuICAgID5cbiAgICAgIDxkaXZcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJwcm9ncmVzcyArICclJ1wiXG4gICAgICAgIGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCJcbiAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgICAgICAgYXJpYS12YWx1ZW5vdz1cIjBcIlxuICAgICAgICBhcmlhLXZhbHVlbWluPVwiMFwiXG4gICAgICAgIGFyaWEtdmFsdWVtYXg9XCIxMDBcIlxuICAgICAgICBbc3R5bGUud2lkdGhdPVwicHJvZ3Jlc3MgKyAnJSdcIlxuICAgICAgPjwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgKm5nSWY9XCJwcm9ncmVzcyA9PT0gLTFcIj5cbiAgICAgIDxjOHktbG9hZGluZz48L2M4eS1sb2FkaW5nPlxuICAgIDwvZGl2PlxuICAgIDxwICpuZ0lmPVwiIWhhc0Ryb3BBcmVhU21hbGxDbGFzc1wiIGNsYXNzPVwibS1iLThcIj5cbiAgICAgIDxzdHJvbmc+XG4gICAgICAgIHt7IGxvYWRpbmdNZXNzYWdlIHwgdHJhbnNsYXRlIH19XG4gICAgICA8L3N0cm9uZz5cbiAgICA8L3A+XG4gIDwvZGl2PlxuICA8ZGl2ICpuZ0lmPVwiIWxvYWRpbmdcIiBjbGFzcz1cImZpbGUtcGxhY2Vob2xkZXIgcC00XCI+XG4gICAgPGRpdiBjbGFzcz1cImQtZmxleCBwLTQgYS1pLWNlbnRlclwiPlxuICAgICAgPGkgYzh5SWNvbj1cImZpbGUtb1wiIGNsYXNzPVwiaWNvbi0yMCBtLXItOFwiPjwvaT5cbiAgICAgIDxzcGFuIHRpdGxlPVwie3sgZmlsZXNOYW1lU3RyaW5nIH19XCIgY2xhc3M9XCJ0ZXh0LXRydW5jYXRlXCI+XG4gICAgICAgIHt7IGZpbGVzTmFtZVN0cmluZyB9fVxuICAgICAgPC9zcGFuPlxuICAgICAgPGJ1dHRvblxuICAgICAgICB0aXRsZT1cInt7ICdSZW1vdmUnIHwgdHJhbnNsYXRlIH19XCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCInUmVtb3ZlJyB8IHRyYW5zbGF0ZVwiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzcz1cImJ0biBidG4tZG90IGJ0bi1kb3QtLWRhbmdlciBzaG93T25Ib3ZlciBtLWwtYXV0b1wiXG4gICAgICA+XG4gICAgICAgIDxpIGM4eUljb249XCJtaW51cy1jaXJjbGVcIiAoY2xpY2spPVwib25EZWxldGUoKVwiPjwvaT5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuPGxhYmVsIGZvcj1cImZpbGVcIiBjbGFzcz1cInNyLW9ubHlcIj57eyAnU2VsZWN0IGZpbGUnIHwgdHJhbnNsYXRlIH19PC9sYWJlbD5cbjxpbnB1dFxuICAjcGlja2VyXG4gICpuZ0lmPVwiY2xpY2tUb09wZW5cIlxuICAoY2hhbmdlKT1cIm9uUGljaygkZXZlbnQpXCJcbiAgKGNsaWNrKT1cInBpY2tlci5mb2N1cygpXCJcbiAgKGJsdXIpPVwib25Ub3VjaGVkKClcIlxuICBbYWNjZXB0XT1cImFjY2VwdGVkRXh0c1wiXG4gIFttdWx0aXBsZV09XCJtYXhBbGxvd2VkRmlsZXMgPiAxXCJcbiAgdHlwZT1cImZpbGVcIlxuICBjbGFzcz1cImhpZGRlblwiXG4gIGlkPVwiZmlsZVwiXG4vPlxuPGRpdiAjYXJlYSBbaGlkZGVuXT1cImlzT3ZlciB8fCBsb2FkaW5nXCIgKGRyYWdvdmVyKT1cInRvZ2dsZSgpXCI+XG4gIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuIl19