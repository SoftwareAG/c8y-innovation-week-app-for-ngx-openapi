import { importProvidersFrom, Injectable, InjectionToken, Injector } from '@angular/core';
import { Router, ROUTES } from '@angular/router';
import { ViewContext } from './router.model';
import { ContextRouteService } from './context-route.service';
import { distinctUntilChanged, filter, shareReplay, take } from 'rxjs/operators';
import { fromTriggerOnce, hookGeneric, getInjectedHooks, InjectionType, ExtensionPointWithoutStateForPlugins } from '../common/extension-hooks';
import { PluginsResolveService } from '../plugins';
import { flatten } from 'lodash';
import { OptionsService } from '../common/options.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "./context-route.service";
import * as i3 from "../plugins";
import * as i4 from "../common/options.service";
/**
 * A hook to use for Multi Provider extension.
 * @deprecated Consider using the `hookRoute` function instead.
 */
export const HOOK_ROUTE = new InjectionToken('HOOK_ROUTE');
/**
 * You can either provide a single `Route` as parameter:
 * ```typescript
 *  hookRoute(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookRoute([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<Route>`
 * ```typescript
 *  export class MyRouteFactory implements ExtensionFactory<Route> {...}
 *  ...
 *  hookRoute(MyRouteFactory)
 * ```
 * A typed alternative to `HOOK_ROUTE`.
 * @param route The `Route`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookRoute(route, options) {
    return hookGeneric(route, HOOK_ROUTE, options);
}
/**
 * A service which defines routes for the application. You can use
 * HOOK_ROUTES or pass
 */
export class RouterService extends ExtensionPointWithoutStateForPlugins {
    constructor(rootInjector, router, contextRouteService, plugins, options) {
        super(rootInjector, plugins);
        this.router = router;
        this.contextRouteService = contextRouteService;
        this.state = new Map();
        this.items$ = this.setupItemsObservable();
        // We are doing a self subscription to add the new routes
        // to the router configuration.
        this.items$.subscribe((routes) => {
            const toAddRoutes = routes.filter((route) => {
                const path = `${route.context || ''}${route.path}`;
                const isAlreadyAdded = this.state.has(path);
                if (!isAlreadyAdded) {
                    this.state.set(path, route);
                }
                return !isAlreadyAdded;
            });
            this.addRoute(toAddRoutes);
        });
        plugins.pluginDetails$.subscribe(({ moduleRef, remoteNgModule }) => {
            this.resolveRouterForChildRoutes(moduleRef, remoteNgModule);
        });
        // only needed in case of pure angular application
        // otherwise handled by bridge service
        if (!options.upgrade) {
            plugins.allPluginsLoaded$
                .pipe(filter(tmp => !!tmp), take(1))
                .subscribe(() => {
                this.router.initialNavigation();
            });
        }
    }
    /**
     * Refresh the current context
     */
    refresh() {
        super.refresh();
        this.contextRouteService.refreshContext();
    }
    /**
     * Add a new route to the router configuration or a context.
     * @param route The route to add
     */
    addRoute(route) {
        this.addRoutes(Array.isArray(route) ? route : [route]);
    }
    /**
     * Determines if the given MO is an group or an device and returns
     * the correct href to link correctly to that MO.
     * @param groupOrDevice The MO of a group or the device.
     * @param prefix How should the link be prefixed.
     */
    getHref(groupOrDevice, prefix = '#/') {
        if (groupOrDevice.c8y_IsDeviceGroup || groupOrDevice.c8y_IsDynamicGroup) {
            return `${prefix}${ViewContext.Group.replace(':id', groupOrDevice.id)}`;
        }
        return `${prefix}${ViewContext.Device.replace(':id', groupOrDevice.id)}`;
    }
    setupItemsObservable() {
        return fromTriggerOnce(this.router, this.refresh$, [
            getInjectedHooks(HOOK_ROUTE, this.injectors, InjectionType.ROUTE),
            () => this.factories
        ]).pipe(distinctUntilChanged(), shareReplay(1));
    }
    addRoutes(routes) {
        // Empty route needs to be last as of navigation to angularjs routes
        // if ** route hit, the angularjs routes are loaded.
        const emptyRoute = this.router.config.find(r => r.path === '**');
        this.router.resetConfig([
            ...this.router.config.filter(r => r.path !== '**'),
            ...routes.map((r) => this.convertRoute(this.router.config, r)),
            emptyRoute
        ].filter(Boolean));
    }
    convertRoute(initialConfig, route) {
        if (route.context) {
            initialConfig.forEach((r) => {
                if (r.data && r.data.context === route.context) {
                    r.children = [route, ...(r.children || [])];
                }
            });
            return;
        }
        return route;
    }
    resolveRouterForChildRoutes(moduleRef, remoteNgModule) {
        // NOTE: stolen from lazy loaded routes from Angular itself.
        // https://github.com/angular/angular/blob/da58801f95c66c201e332189af25702bdd722f3f/packages/router/src/router_config_loader.ts#L103-L108
        const rawRoutes = flatten(moduleRef.injector.get(ROUTES, [], { self: true, optional: true }));
        if (rawRoutes.length > 0) {
            const routeWithInjector = rawRoutes.map(route => {
                route.providers = [importProvidersFrom(remoteNgModule)];
                return route;
            });
            this.addRoute(routeWithInjector);
        }
    }
}
RouterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: RouterService, deps: [{ token: i0.Injector }, { token: i1.Router }, { token: i2.ContextRouteService }, { token: i3.PluginsResolveService }, { token: i4.OptionsService }], target: i0.ɵɵFactoryTarget.Injectable });
RouterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: RouterService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: RouterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.Router }, { type: i2.ContextRouteService }, { type: i3.PluginsResolveService }, { type: i4.OptionsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3JvdXRlci9yb3V0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLFVBQVUsRUFDVixjQUFjLEVBQ2QsUUFBUSxFQUVULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDakQsT0FBTyxFQUF1QixXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUc5RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRixPQUFPLEVBRUwsZUFBZSxFQUVmLFdBQVcsRUFDWCxnQkFBZ0IsRUFDaEIsYUFBYSxFQUNiLG9DQUFvQyxFQUVyQyxNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNuRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ2pDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQzs7Ozs7O0FBc0IzRDs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUcsSUFBSSxjQUFjLENBQWUsWUFBWSxDQUFDLENBQUM7QUFFekU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBQyxLQUE2QixFQUFFLE9BQThCO0lBQ3JGLE9BQU8sV0FBVyxDQUFRLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUVEOzs7R0FHRztBQUlILE1BQU0sT0FBTyxhQUFjLFNBQVEsb0NB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RTtvQkFDOUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUM3QztZQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0gsT0FBTztTQUNSO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU8sMkJBQTJCLENBQUMsU0FBMkIsRUFBRSxjQUFtQjtRQUNsRiw0REFBNEQ7UUFDNUQseUlBQXlJO1FBQ3pJLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRTlGLElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDeEIsTUFBTSxpQkFBaUIsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUM5QyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsbUJBQW1CLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztnQkFDeEQsT0FBTyxLQUFLLENBQUM7WUFDZixDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNsQztJQUNILENBQUM7OzBHQXRIVSxhQUFhOzhHQUFiLGFBQWEsY0FGWixNQUFNOzJGQUVQLGFBQWE7a0JBSHpCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgaW1wb3J0UHJvdmlkZXJzRnJvbSxcbiAgSW5qZWN0YWJsZSxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEluamVjdG9yLFxuICBOZ01vZHVsZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciwgUk9VVEVTIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IFJvdXRlRmFjdG9yeSwgUm91dGUsIFZpZXdDb250ZXh0IH0gZnJvbSAnLi9yb3V0ZXIubW9kZWwnO1xuaW1wb3J0IHsgQ29udGV4dFJvdXRlU2VydmljZSB9IGZyb20gJy4vY29udGV4dC1yb3V0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IElNYW5hZ2VkT2JqZWN0IH0gZnJvbSAnQGM4eS9jbGllbnQnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgc2hhcmVSZXBsYXksIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBFeHRlbnNpb25GYWN0b3J5LFxuICBmcm9tVHJpZ2dlck9uY2UsXG4gIEdlbmVyaWNIb29rVHlwZSxcbiAgaG9va0dlbmVyaWMsXG4gIGdldEluamVjdGVkSG9va3MsXG4gIEluamVjdGlvblR5cGUsXG4gIEV4dGVuc2lvblBvaW50V2l0aG91dFN0YXRlRm9yUGx1Z2lucyxcbiAgSG9va09wdGlvbnNcbn0gZnJvbSAnLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBQbHVnaW5zUmVzb2x2ZVNlcnZpY2UgfSBmcm9tICcuLi9wbHVnaW5zJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgT3B0aW9uc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vb3B0aW9ucy5zZXJ2aWNlJztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gSE9PSyBjYW4gdXNlIGVpdGhlciBhIHB1cmUgdmFsdWU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiB7IC4uLmhvb2tWYWx1ZSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IFt7IC4uLmhvb2tWYWx1ZXMgfV0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIEV4dGVuc2lvbkZhY3Rvcnkgd2hpY2ggYWxsb3dzIHRvIGRlZmluZSBhIGdldCgpIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBnZXRzIGNhbGxlZCBvbiBlYWNoIG5hdmlnYXRpb24gd2l0aCB0aGUgY3VycmVudCByb3V0ZSBhbmQgY2FuIHJldHVybiB2YWx1ZXNcbiAqIGFzeW5jIChvYnNlcnZhYmxlIG9yIHByb21pc2UpLlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VGYWN0b3J5OiB7IGdldDogKHJvdXRlKSA9PiBkb1NvbWV0aGluZ0FzeW5jKHJvdXRlKSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVFeHRlbnNpb24gPSBSb3V0ZSB8IFJvdXRlW10gfCBFeHRlbnNpb25GYWN0b3J5PFJvdXRlPjtcblxuLyoqXG4gKiBBIGhvb2sgdG8gdXNlIGZvciBNdWx0aSBQcm92aWRlciBleHRlbnNpb24uXG4gKiBAZGVwcmVjYXRlZCBDb25zaWRlciB1c2luZyB0aGUgYGhvb2tSb3V0ZWAgZnVuY3Rpb24gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IEhPT0tfUk9VVEUgPSBuZXcgSW5qZWN0aW9uVG9rZW48Um91dGVGYWN0b3J5PignSE9PS19ST1VURScpO1xuXG4vKipcbiAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgYSBzaW5nbGUgYFJvdXRlYCBhcyBwYXJhbWV0ZXI6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgaG9va1JvdXRlKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tSb3V0ZShbLi4uXSlcbiAqIGBgYFxuICpcbiAqIE9yIHlvdSBwcm92aWRlIGFuIFNlcnZpY2UgdGhhdCBpbXBsZW1lbnRzIGBFeHRlbnNpb25GYWN0b3J5PFJvdXRlPmBcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBleHBvcnQgY2xhc3MgTXlSb3V0ZUZhY3RvcnkgaW1wbGVtZW50cyBFeHRlbnNpb25GYWN0b3J5PFJvdXRlPiB7Li4ufVxuICogIC4uLlxuICogIGhvb2tSb3V0ZShNeVJvdXRlRmFjdG9yeSlcbiAqIGBgYFxuICogQSB0eXBlZCBhbHRlcm5hdGl2ZSB0byBgSE9PS19ST1VURWAuXG4gKiBAcGFyYW0gcm91dGUgVGhlIGBSb3V0ZWAncyBvciBgRXh0ZW5zaW9uRmFjdG9yeWAgdG8gYmUgcHJvdmlkZWQuXG4gKiBAcmV0dXJucyBBbiBgUHJvdmlkZXJgIHRvIGJlIHByb3ZpZGVkIGluIHlvdXIgbW9kdWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaG9va1JvdXRlKHJvdXRlOiBHZW5lcmljSG9va1R5cGU8Um91dGU+LCBvcHRpb25zPzogUGFydGlhbDxIb29rT3B0aW9ucz4pIHtcbiAgcmV0dXJuIGhvb2tHZW5lcmljPFJvdXRlPihyb3V0ZSwgSE9PS19ST1VURSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgcm91dGVzIGZvciB0aGUgYXBwbGljYXRpb24uIFlvdSBjYW4gdXNlXG4gKiBIT09LX1JPVVRFUyBvciBwYXNzXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFJvdXRlclNlcnZpY2UgZXh0ZW5kcyBFeHRlbnNpb25Qb2ludFdpdGhvdXRTdGF0ZUZvclBsdWdpbnM8Um91dGU+IHtcbiAgcmVhZG9ubHkgc3RhdGUgPSBuZXcgTWFwPHN0cmluZywgUm91dGU+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcm9vdEluamVjdG9yOiBJbmplY3RvcixcbiAgICBwdWJsaWMgcm91dGVyOiBSb3V0ZXIsXG4gICAgcHJpdmF0ZSBjb250ZXh0Um91dGVTZXJ2aWNlOiBDb250ZXh0Um91dGVTZXJ2aWNlLFxuICAgIHBsdWdpbnM6IFBsdWdpbnNSZXNvbHZlU2VydmljZSxcbiAgICBvcHRpb25zOiBPcHRpb25zU2VydmljZVxuICApIHtcbiAgICBzdXBlcihyb290SW5qZWN0b3IsIHBsdWdpbnMpO1xuICAgIHRoaXMuaXRlbXMkID0gdGhpcy5zZXR1cEl0ZW1zT2JzZXJ2YWJsZSgpO1xuXG4gICAgLy8gV2UgYXJlIGRvaW5nIGEgc2VsZiBzdWJzY3JpcHRpb24gdG8gYWRkIHRoZSBuZXcgcm91dGVzXG4gICAgLy8gdG8gdGhlIHJvdXRlciBjb25maWd1cmF0aW9uLlxuICAgIHRoaXMuaXRlbXMkLnN1YnNjcmliZSgocm91dGVzOiBSb3V0ZVtdKSA9PiB7XG4gICAgICBjb25zdCB0b0FkZFJvdXRlcyA9IHJvdXRlcy5maWx0ZXIoKHJvdXRlOiBSb3V0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXRoID0gYCR7cm91dGUuY29udGV4dCB8fCAnJ30ke3JvdXRlLnBhdGh9YDtcbiAgICAgICAgY29uc3QgaXNBbHJlYWR5QWRkZWQgPSB0aGlzLnN0YXRlLmhhcyhwYXRoKTtcbiAgICAgICAgaWYgKCFpc0FscmVhZHlBZGRlZCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUuc2V0KHBhdGgsIHJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWlzQWxyZWFkeUFkZGVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZFJvdXRlKHRvQWRkUm91dGVzKTtcbiAgICB9KTtcblxuICAgIHBsdWdpbnMucGx1Z2luRGV0YWlscyQuc3Vic2NyaWJlKCh7IG1vZHVsZVJlZiwgcmVtb3RlTmdNb2R1bGUgfSkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlUm91dGVyRm9yQ2hpbGRSb3V0ZXMobW9kdWxlUmVmLCByZW1vdGVOZ01vZHVsZSk7XG4gICAgfSk7XG5cbiAgICAvLyBvbmx5IG5lZWRlZCBpbiBjYXNlIG9mIHB1cmUgYW5ndWxhciBhcHBsaWNhdGlvblxuICAgIC8vIG90aGVyd2lzZSBoYW5kbGVkIGJ5IGJyaWRnZSBzZXJ2aWNlXG4gICAgaWYgKCFvcHRpb25zLnVwZ3JhZGUpIHtcbiAgICAgIHBsdWdpbnMuYWxsUGx1Z2luc0xvYWRlZCRcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgZmlsdGVyKHRtcCA9PiAhIXRtcCksXG4gICAgICAgICAgdGFrZSgxKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucm91dGVyLmluaXRpYWxOYXZpZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgc3VwZXIucmVmcmVzaCgpO1xuICAgIHRoaXMuY29udGV4dFJvdXRlU2VydmljZS5yZWZyZXNoQ29udGV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyByb3V0ZSB0byB0aGUgcm91dGVyIGNvbmZpZ3VyYXRpb24gb3IgYSBjb250ZXh0LlxuICAgKiBAcGFyYW0gcm91dGUgVGhlIHJvdXRlIHRvIGFkZFxuICAgKi9cbiAgYWRkUm91dGUocm91dGU6IFJvdXRlIHwgUm91dGVbXSkge1xuICAgIHRoaXMuYWRkUm91dGVzKEFycmF5LmlzQXJyYXkocm91dGUpID8gcm91dGUgOiBbcm91dGVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBNTyBpcyBhbiBncm91cCBvciBhbiBkZXZpY2UgYW5kIHJldHVybnNcbiAgICogdGhlIGNvcnJlY3QgaHJlZiB0byBsaW5rIGNvcnJlY3RseSB0byB0aGF0IE1PLlxuICAgKiBAcGFyYW0gZ3JvdXBPckRldmljZSBUaGUgTU8gb2YgYSBncm91cCBvciB0aGUgZGV2aWNlLlxuICAgKiBAcGFyYW0gcHJlZml4IEhvdyBzaG91bGQgdGhlIGxpbmsgYmUgcHJlZml4ZWQuXG4gICAqL1xuICBnZXRIcmVmKGdyb3VwT3JEZXZpY2U6IElNYW5hZ2VkT2JqZWN0LCBwcmVmaXggPSAnIy8nKTogc3RyaW5nIHtcbiAgICBpZiAoZ3JvdXBPckRldmljZS5jOHlfSXNEZXZpY2VHcm91cCB8fCBncm91cE9yRGV2aWNlLmM4eV9Jc0R5bmFtaWNHcm91cCkge1xuICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke1ZpZXdDb250ZXh0Lkdyb3VwLnJlcGxhY2UoJzppZCcsIGdyb3VwT3JEZXZpY2UuaWQpfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcmVmaXh9JHtWaWV3Q29udGV4dC5EZXZpY2UucmVwbGFjZSgnOmlkJywgZ3JvdXBPckRldmljZS5pZCl9YDtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXR1cEl0ZW1zT2JzZXJ2YWJsZSgpOiBPYnNlcnZhYmxlPFJvdXRlW10+IHtcbiAgICByZXR1cm4gZnJvbVRyaWdnZXJPbmNlPFJvdXRlPih0aGlzLnJvdXRlciwgdGhpcy5yZWZyZXNoJCwgW1xuICAgICAgZ2V0SW5qZWN0ZWRIb29rczxSb3V0ZT4oSE9PS19ST1VURSwgdGhpcy5pbmplY3RvcnMsIEluamVjdGlvblR5cGUuUk9VVEUpLFxuICAgICAgKCkgPT4gdGhpcy5mYWN0b3JpZXNcbiAgICBdKS5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHNoYXJlUmVwbGF5KDEpKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUm91dGVzKHJvdXRlcykge1xuICAgIC8vIEVtcHR5IHJvdXRlIG5lZWRzIHRvIGJlIGxhc3QgYXMgb2YgbmF2aWdhdGlvbiB0byBhbmd1bGFyanMgcm91dGVzXG4gICAgLy8gaWYgKiogcm91dGUgaGl0LCB0aGUgYW5ndWxhcmpzIHJvdXRlcyBhcmUgbG9hZGVkLlxuICAgIGNvbnN0IGVtcHR5Um91dGUgPSB0aGlzLnJvdXRlci5jb25maWcuZmluZChyID0+IHIucGF0aCA9PT0gJyoqJyk7XG4gICAgdGhpcy5yb3V0ZXIucmVzZXRDb25maWcoXG4gICAgICBbXG4gICAgICAgIC4uLnRoaXMucm91dGVyLmNvbmZpZy5maWx0ZXIociA9PiByLnBhdGggIT09ICcqKicpLFxuICAgICAgICAuLi5yb3V0ZXMubWFwKChyOiBSb3V0ZSkgPT4gdGhpcy5jb252ZXJ0Um91dGUodGhpcy5yb3V0ZXIuY29uZmlnLCByKSksXG4gICAgICAgIGVtcHR5Um91dGVcbiAgICAgIF0uZmlsdGVyKEJvb2xlYW4pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgY29udmVydFJvdXRlKGluaXRpYWxDb25maWcsIHJvdXRlOiBSb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5jb250ZXh0KSB7XG4gICAgICBpbml0aWFsQ29uZmlnLmZvckVhY2goKHI6IFJvdXRlKSA9PiB7XG4gICAgICAgIGlmIChyLmRhdGEgJiYgci5kYXRhLmNvbnRleHQgPT09IHJvdXRlLmNvbnRleHQpIHtcbiAgICAgICAgICByLmNoaWxkcmVuID0gW3JvdXRlLCAuLi4oci5jaGlsZHJlbiB8fCBbXSldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlUm91dGVyRm9yQ2hpbGRSb3V0ZXMobW9kdWxlUmVmOiBOZ01vZHVsZVJlZjxhbnk+LCByZW1vdGVOZ01vZHVsZTogYW55KSB7XG4gICAgLy8gTk9URTogc3RvbGVuIGZyb20gbGF6eSBsb2FkZWQgcm91dGVzIGZyb20gQW5ndWxhciBpdHNlbGYuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL2RhNTg4MDFmOTVjNjZjMjAxZTMzMjE4OWFmMjU3MDJiZGQ3MjJmM2YvcGFja2FnZXMvcm91dGVyL3NyYy9yb3V0ZXJfY29uZmlnX2xvYWRlci50cyNMMTAzLUwxMDhcbiAgICBjb25zdCByYXdSb3V0ZXMgPSBmbGF0dGVuKG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoUk9VVEVTLCBbXSwgeyBzZWxmOiB0cnVlLCBvcHRpb25hbDogdHJ1ZSB9KSk7XG5cbiAgICBpZiAocmF3Um91dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJvdXRlV2l0aEluamVjdG9yID0gcmF3Um91dGVzLm1hcChyb3V0ZSA9PiB7XG4gICAgICAgIHJvdXRlLnByb3ZpZGVycyA9IFtpbXBvcnRQcm92aWRlcnNGcm9tKHJlbW90ZU5nTW9kdWxlKV07XG4gICAgICAgIHJldHVybiByb3V0ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRSb3V0ZShyb3V0ZVdpdGhJbmplY3Rvcik7XG4gICAgfVxuICB9XG59XG4iXX0=