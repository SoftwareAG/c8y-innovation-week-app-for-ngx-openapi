import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { concatMap, map, switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
export class ZipService {
    getEntries(zipFile) {
        return new Observable(subscriber => {
            const reader = new zip.BlobReader(zipFile);
            zip.createReader(reader, zipReader => {
                zipReader.getEntries(entries => {
                    subscriber.next(entries);
                    subscriber.complete();
                });
            }, message => {
                subscriber.error({ message });
            });
        });
    }
    getData(entry) {
        const data = new Observable(subscriber => {
            const writer = new zip.BlobWriter();
            entry.getData(writer, blob => {
                subscriber.next(blob);
                subscriber.complete();
            });
        });
        return data;
    }
    getJsonData(zipFile, fileEntryFilter) {
        return this.getEntries(zipFile).pipe(map(entries => {
            const entryFile = entries.find(entry => entry.filename === fileEntryFilter.filename);
            if (!entryFile) {
                throwError(`File not found ${JSON.stringify(fileEntryFilter)}`);
            }
            return entryFile;
        }), concatMap(entry => this.getData(entry)), switchMap(async (blob) => await blob.text()), map(text => JSON.parse(text)));
    }
}
ZipService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ZipService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ZipService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ZipService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ZipService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiemlwLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2NvbW1vbi96aXAuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOztBQUszRCxNQUFNLE9BQU8sVUFBVTtJQUNyQixVQUFVLENBQUMsT0FBYTtRQUN0QixPQUFPLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sTUFBTSxHQUFHLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMzQyxHQUFHLENBQUMsWUFBWSxDQUNkLE1BQU0sRUFDTixTQUFTLENBQUMsRUFBRTtnQkFDVixTQUFTLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUM3QixVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUN6QixVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ3hCLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxFQUNELE9BQU8sQ0FBQyxFQUFFO2dCQUNSLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ2hDLENBQUMsQ0FDRixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsT0FBTyxDQUFDLEtBQWU7UUFDckIsTUFBTSxJQUFJLEdBQUcsSUFBSSxVQUFVLENBQU8sVUFBVSxDQUFDLEVBQUU7WUFDN0MsTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxFQUFFLENBQUM7WUFFbkMsS0FBYSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUU7Z0JBQ3BDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3RCLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN4QixDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQWEsRUFBRSxlQUFxQztRQUM5RCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNsQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDWixNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFFBQVEsS0FBSyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDckYsSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDZCxVQUFVLENBQUMsa0JBQWtCLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2pFO1lBQ0QsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQyxDQUFDLEVBQ0YsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUN2QyxTQUFTLENBQUMsS0FBSyxFQUFDLElBQUksRUFBQyxFQUFFLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFDMUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUM5QixDQUFDO0lBQ0osQ0FBQzs7dUdBNUNVLFVBQVU7MkdBQVYsVUFBVSxjQURHLE1BQU07MkZBQ25CLFVBQVU7a0JBRHRCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY29uY2F0TWFwLCBtYXAsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZGVjbGFyZSBjb25zdCB6aXA6IGFueTtcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBaaXBTZXJ2aWNlIHtcbiAgZ2V0RW50cmllcyh6aXBGaWxlOiBGaWxlKTogT2JzZXJ2YWJsZTxaaXBFbnRyeVtdPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZXIgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IHppcC5CbG9iUmVhZGVyKHppcEZpbGUpO1xuICAgICAgemlwLmNyZWF0ZVJlYWRlcihcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICB6aXBSZWFkZXIgPT4ge1xuICAgICAgICAgIHppcFJlYWRlci5nZXRFbnRyaWVzKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGVudHJpZXMpO1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtZXNzYWdlID0+IHtcbiAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHsgbWVzc2FnZSB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldERhdGEoZW50cnk6IFppcEVudHJ5KTogT2JzZXJ2YWJsZTxCbG9iPiB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYnNlcnZhYmxlPEJsb2I+KHN1YnNjcmliZXIgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IHppcC5CbG9iV3JpdGVyKCk7XG5cbiAgICAgIChlbnRyeSBhcyBhbnkpLmdldERhdGEod3JpdGVyLCBibG9iID0+IHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGJsb2IpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGdldEpzb25EYXRhKHppcEZpbGU6IEZpbGUsIGZpbGVFbnRyeUZpbHRlcjogeyBmaWxlbmFtZTogc3RyaW5nIH0pOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJpZXMoemlwRmlsZSkucGlwZShcbiAgICAgIG1hcChlbnRyaWVzID0+IHtcbiAgICAgICAgY29uc3QgZW50cnlGaWxlID0gZW50cmllcy5maW5kKGVudHJ5ID0+IGVudHJ5LmZpbGVuYW1lID09PSBmaWxlRW50cnlGaWx0ZXIuZmlsZW5hbWUpO1xuICAgICAgICBpZiAoIWVudHJ5RmlsZSkge1xuICAgICAgICAgIHRocm93RXJyb3IoYEZpbGUgbm90IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoZmlsZUVudHJ5RmlsdGVyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnlGaWxlO1xuICAgICAgfSksXG4gICAgICBjb25jYXRNYXAoZW50cnkgPT4gdGhpcy5nZXREYXRhKGVudHJ5KSksXG4gICAgICBzd2l0Y2hNYXAoYXN5bmMgYmxvYiA9PiBhd2FpdCBibG9iLnRleHQoKSksXG4gICAgICBtYXAodGV4dCA9PiBKU09OLnBhcnNlKHRleHQpKVxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBaaXBFbnRyeSB7XG4gIHZlcnNpb246IG51bWJlcjtcbiAgYml0RmxhZzogbnVtYmVyO1xuICBjb21wcmVzc2lvbk1ldGhvZDogbnVtYmVyO1xuICBsYXN0TW9kRGF0ZVJhdzogbnVtYmVyO1xuICBsYXN0TW9kRGF0ZTogc3RyaW5nO1xuICBjcmMzMjogbnVtYmVyO1xuICBjb21wcmVzc2VkU2l6ZTogbnVtYmVyO1xuICB1bmNvbXByZXNzZWRTaXplOiBudW1iZXI7XG4gIGZpbGVuYW1lTGVuZ3RoOiBudW1iZXI7XG4gIGV4dHJhRmllbGRMZW5ndGg6IG51bWJlcjtcbiAgY29tbWVudExlbmd0aDogbnVtYmVyO1xuICBkaXJlY3Rvcnk6IGJvb2xlYW47XG4gIG9mZnNldDogMDtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgY29tbWVudDogc3RyaW5nO1xufVxuIl19