import { NavigationEnd } from '@angular/router';
import { castArray, flatten, groupBy, sortBy, uniq } from 'lodash-es';
import { BehaviorSubject, combineLatest, defer, from, isObservable, merge, of, race, Subject } from 'rxjs';
import { filter, map, startWith, switchMap } from 'rxjs/operators';
import { StateService } from './state-service.abstract';
export function fromTrigger(router, refresh, factories) {
    return merge(router.events.pipe(filter(evt => evt instanceof NavigationEnd)), ...castArray(refresh)).pipe(startWith(1), switchMap(() => fromFactories(factories, router)));
}
export function fromTriggerOnce(router, refresh, factories) {
    return merge(...castArray(refresh)).pipe(startWith(1), switchMap(() => fromFactories(factories, router)));
}
export var InjectionType;
(function (InjectionType) {
    InjectionType[InjectionType["COMPONENT"] = 0] = "COMPONENT";
    InjectionType[InjectionType["ROUTE"] = 1] = "ROUTE";
})(InjectionType || (InjectionType = {}));
export function getInjectedHooks(token, injectors, type = InjectionType.COMPONENT) {
    return () => flatten(injectors.map(injector => {
        const factoryOrFactories = injector.get(token, [], { self: true });
        const factories = Array.isArray(factoryOrFactories)
            ? flatten(factoryOrFactories)
            : [factoryOrFactories];
        if (injector.scopes?.has('root')) {
            return factories;
        }
        factories.forEach((factory) => {
            if (!factory.get && factory.injector !== null) {
                if (type === InjectionType.ROUTE) {
                    factory._injector = injector;
                }
                else {
                    factory.injector = injector;
                }
            }
        });
        return factories;
    }));
}
export function fromFactories(factories, router, withFirstEmpty = true) {
    return !Array.isArray(factories) || factories.length < 1
        ? of([])
        : defer(() => {
            const factoryObservables = resolveInjectedFactories(factories).map(f => {
                if (Array.isArray(f)) {
                    return toObservableOfArrays(f, withFirstEmpty);
                }
                if (isExtensionFactory(f)) {
                    return toObservableOfArrays(f.get(getActivatedRoute(router)), withFirstEmpty);
                }
                return toObservableOfArrays([f], withFirstEmpty);
            });
            return combineLatest(factoryObservables);
        }).pipe(map(results => sortByPriority([].concat(...results))), map(value => uniq(value)));
}
export function resolveInjectedFactories(factories) {
    return flatten(factories.map(f => {
        if (typeof f === 'function') {
            const func = f;
            return func();
        }
        return [f];
    }));
}
export function stateToFactory(componentsState) {
    const components$ = componentsState.pipe(map((componentSet) => [...componentSet]));
    return { get: () => components$ };
}
export function sortByPriority(items) {
    return sortBy(items, item => -(item?.priority || 0));
}
export function removeDuplicatesIds(items) {
    const grouped = groupBy(items, 'id');
    const itemsWithoutDuplicates = new Array();
    for (const key of Object.keys(grouped)) {
        if (key && key !== 'undefined') {
            const sortedByPrio = sortByPriority(grouped[key]);
            itemsWithoutDuplicates.push(sortedByPrio[0]);
        }
        else {
            itemsWithoutDuplicates.push(...grouped[key]);
        }
    }
    return sortByPriority(itemsWithoutDuplicates);
}
export function toObservableOfArrays(factoryResult, withFirstEmpty) {
    let observable;
    if (!factoryResult) {
        return of([]);
    }
    else {
        observable = toObservable(factoryResult);
        if (withFirstEmpty) {
            const withEmptyFirst = observable.pipe(startWith([]));
            observable = race(observable, withEmptyFirst);
        }
    }
    return observable.pipe(map(result => (Array.isArray(result) ? result : [result]).filter(item => !!item)));
}
export function isPromise(obj) {
    return !!obj && typeof obj.then === 'function';
}
export function isExtensionFactory(obj) {
    return !!obj && typeof obj.get === 'function';
}
/**
 * Converts any value provided to an Observable that emits this value once and then completes.
 * A convenience method to represent all the data as Observables rather than
 * a mixture of Observables and other types.
 *
 * @param value The value the resulting Observable will emit.
 */
export function toObservable(value) {
    if (isObservable(value)) {
        return value;
    }
    if (isPromise(value)) {
        return from(value);
    }
    return of(value);
}
export class ExtensionPointWithoutStateForPlugins {
    constructor(rootInjector, pluginService) {
        this.factories = [];
        this.refreshTrigger = new Subject();
        this.injectors = [rootInjector];
        pluginService.injectors$.subscribe(injector => {
            this.injectors.push(injector);
        });
        this.refresh$ = merge(this.refreshTrigger, pluginService.refresh$);
    }
    /**
     * Refresh the extension factories
     */
    refresh() {
        this.refreshTrigger.next();
    }
}
export class ExtensionPointForPlugins extends StateService {
    constructor(rootInjector, pluginService) {
        super();
        this.factories = [];
        this.state$ = new BehaviorSubject(new Set());
        this.refreshTrigger = new Subject();
        this.injectors = [rootInjector];
        pluginService.injectors$.subscribe(injector => {
            this.injectors.push(injector);
        });
        this.refresh$ = merge(this.refreshTrigger, pluginService.refresh$);
    }
    /**
     * Refresh the extension factories
     */
    refresh() {
        this.refreshTrigger.next();
    }
}
/**
 * Helper function to get the activated route in
 * a service (as ActivatedRoute injection only
 * works in components). Works as long as we only use
 * a tree and no child is active at the same time.
 *
 * @param router The current router
 */
export function getActivatedRoute(router) {
    if (router && router.routerState && router.routerState.root) {
        let route = router.routerState.root;
        while (route.firstChild) {
            route = route.firstChild;
        }
        return route;
    }
}
/**
 * A generic function to be used by specific implementations of the HOOK concept.
 * @param items The items that should be provided under the `useValue` or `useClass` attribute.
 * Allows an extension factory to be passed as an argument, which can create instances of type T.
 * @param token The InjectionToken/HOOK to be provided.
 * @param options If this is a multi provider or not (defaults to true) and provider type definition (defaults to ClassProvider) - `HookOptions`.
 * @returns A `Provider` (either `ValueProvider` or `ClassProvider`) to be provided in a module.
 */
export function hookGeneric(items, token, options) {
    const finalOptions = Object.assign({ multi: true, providerType: HookProviderTypes.ClassProvider }, options);
    const { multi, providerType } = finalOptions;
    if (typeof items !== 'function') {
        return {
            provide: token,
            useValue: items,
            multi
        };
    }
    if (providerType === HookProviderTypes.ExistingProvider) {
        return {
            provide: token,
            useExisting: items,
            multi
        };
    }
    return {
        provide: token,
        useClass: items,
        multi
    };
}
export var HookProviderTypes;
(function (HookProviderTypes) {
    HookProviderTypes["ExistingProvider"] = "ExistingProvider";
    HookProviderTypes["ClassProvider"] = "ClassProvider";
})(HookProviderTypes || (HookProviderTypes = {}));
export function allEntriesAreEqual(previous, next) {
    if (previous === next)
        return true;
    if (previous == null || next == null)
        return false;
    if (previous.length !== next.length)
        return false;
    for (let i = 0; i < previous.length; ++i) {
        if (previous[i] !== next[i])
            return false;
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5zaW9uLWhvb2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vZXh0ZW5zaW9uLWhvb2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFBLE9BQU8sRUFBa0IsYUFBYSxFQUFVLE1BQU0saUJBQWlCLENBQUM7QUFDeEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDdEUsT0FBTyxFQUNMLGVBQWUsRUFDZixhQUFhLEVBQ2IsS0FBSyxFQUNMLElBQUksRUFDSixZQUFZLEVBQ1osS0FBSyxFQUVMLEVBQUUsRUFDRixJQUFJLEVBQ0osT0FBTyxFQUNSLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRW5FLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUV4RCxNQUFNLFVBQVUsV0FBVyxDQUN6QixNQUFjLEVBQ2QsT0FBNEMsRUFDNUMsU0FNQztJQUVELE9BQU8sS0FBSyxDQUNWLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxhQUFhLENBQUMsQ0FBQyxFQUMvRCxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FDdEIsQ0FBQyxJQUFJLENBQ0osU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUNaLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUksU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQ3JELENBQUM7QUFDSixDQUFDO0FBRUQsTUFBTSxVQUFVLGVBQWUsQ0FDN0IsTUFBYyxFQUNkLE9BQTRDLEVBQzVDLFNBTUM7SUFFRCxPQUFPLEtBQUssQ0FBQyxHQUFHLFNBQVMsQ0FB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QUM7S0FDM0M7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDbGFzc1Byb3ZpZGVyLFxuICBFeGlzdGluZ1Byb3ZpZGVyLFxuICBJbmplY3Rpb25Ub2tlbixcbiAgSW5qZWN0b3IsXG4gIFR5cGUsXG4gIFZhbHVlUHJvdmlkZXJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSwgTmF2aWdhdGlvbkVuZCwgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IGNhc3RBcnJheSwgZmxhdHRlbiwgZ3JvdXBCeSwgc29ydEJ5LCB1bmlxIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7XG4gIEJlaGF2aW9yU3ViamVjdCxcbiAgY29tYmluZUxhdGVzdCxcbiAgZGVmZXIsXG4gIGZyb20sXG4gIGlzT2JzZXJ2YWJsZSxcbiAgbWVyZ2UsXG4gIE9ic2VydmFibGUsXG4gIG9mLFxuICByYWNlLFxuICBTdWJqZWN0XG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHN0YXJ0V2l0aCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUGx1Z2luc1Jlc29sdmVTZXJ2aWNlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuL3N0YXRlLXNlcnZpY2UuYWJzdHJhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyaWdnZXI8VD4oXG4gIHJvdXRlcjogUm91dGVyLFxuICByZWZyZXNoOiBPYnNlcnZhYmxlPGFueT4gfCBPYnNlcnZhYmxlPGFueT5bXSxcbiAgZmFjdG9yaWVzOiBBcnJheTxcbiAgICB8IFRcbiAgICB8IFRbXVxuICAgIHwgRXh0ZW5zaW9uRmFjdG9yeTxUPlxuICAgIHwgRXh0ZW5zaW9uRmFjdG9yeTxUPltdXG4gICAgfCAoKCkgPT4gVCB8IEV4dGVuc2lvbkZhY3Rvcnk8VD4gfCBBcnJheTxUIHwgRXh0ZW5zaW9uRmFjdG9yeTxUPj4pXG4gID5cbik6IE9ic2VydmFibGU8VFtdPiB7XG4gIHJldHVybiBtZXJnZShcbiAgICByb3V0ZXIuZXZlbnRzLnBpcGUoZmlsdGVyKGV2dCA9PiBldnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSksXG4gICAgLi4uY2FzdEFycmF5KHJlZnJlc2gpXG4gICkucGlwZShcbiAgICBzdGFydFdpdGgoMSksXG4gICAgc3dpdGNoTWFwKCgpID0+IGZyb21GYWN0b3JpZXM8VD4oZmFjdG9yaWVzLCByb3V0ZXIpKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyaWdnZXJPbmNlPFQ+KFxuICByb3V0ZXI6IFJvdXRlcixcbiAgcmVmcmVzaDogT2JzZXJ2YWJsZTxhbnk+IHwgT2JzZXJ2YWJsZTxhbnk+W10sXG4gIGZhY3RvcmllczogQXJyYXk8XG4gICAgfCBUXG4gICAgfCBUW11cbiAgICB8IEV4dGVuc2lvbkZhY3Rvcnk8VD5cbiAgICB8IEV4dGVuc2lvbkZhY3Rvcnk8VD5bXVxuICAgIHwgKCgpID0+IFQgfCBFeHRlbnNpb25GYWN0b3J5PFQ+IHwgQXJyYXk8VCB8IEV4dGVuc2lvbkZhY3Rvcnk8VD4+KVxuICA+XG4pOiBPYnNlcnZhYmxlPFRbXT4ge1xuICByZXR1cm4gbWVyZ2UoLi4uY2FzdEFycmF5KHJlZnJlc2gpKS5waXBlKFxuICAgIHN0YXJ0V2l0aCgxKSxcbiAgICBzd2l0Y2hNYXAoKCkgPT4gZnJvbUZhY3RvcmllczxUPihmYWN0b3JpZXMsIHJvdXRlcikpXG4gICk7XG59XG5cbmV4cG9ydCBlbnVtIEluamVjdGlvblR5cGUge1xuICBDT01QT05FTlQsXG4gIFJPVVRFXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmplY3RlZEhvb2tzPFQ+KFxuICB0b2tlbjogSW5qZWN0aW9uVG9rZW48VFtdPixcbiAgaW5qZWN0b3JzOiBJbmplY3RvcltdLFxuICB0eXBlID0gSW5qZWN0aW9uVHlwZS5DT01QT05FTlRcbik6ICgpID0+IFRbXSB7XG4gIHJldHVybiAoKSA9PlxuICAgIGZsYXR0ZW4oXG4gICAgICBpbmplY3RvcnMubWFwKGluamVjdG9yID0+IHtcbiAgICAgICAgY29uc3QgZmFjdG9yeU9yRmFjdG9yaWVzID0gaW5qZWN0b3IuZ2V0PFQgfCBUW10+KHRva2VuLCBbXSwgeyBzZWxmOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBmYWN0b3JpZXM6IFRbXSA9IEFycmF5LmlzQXJyYXkoZmFjdG9yeU9yRmFjdG9yaWVzKVxuICAgICAgICAgID8gZmxhdHRlbihmYWN0b3J5T3JGYWN0b3JpZXMpXG4gICAgICAgICAgOiBbZmFjdG9yeU9yRmFjdG9yaWVzXTtcbiAgICAgICAgaWYgKChpbmplY3RvciBhcyBhbnkpLnNjb3Blcz8uaGFzKCdyb290JykpIHtcbiAgICAgICAgICByZXR1cm4gZmFjdG9yaWVzO1xuICAgICAgICB9XG4gICAgICAgIGZhY3Rvcmllcy5mb3JFYWNoKChmYWN0b3J5OiBUIHwgRXh0ZW5zaW9uRmFjdG9yeTxUPikgPT4ge1xuICAgICAgICAgIGlmICghKGZhY3RvcnkgYXMgRXh0ZW5zaW9uRmFjdG9yeTxUPikuZ2V0ICYmIChmYWN0b3J5IGFzIGFueSkuaW5qZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBJbmplY3Rpb25UeXBlLlJPVVRFKSB7XG4gICAgICAgICAgICAgIChmYWN0b3J5IGFzIGFueSkuX2luamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAoZmFjdG9yeSBhcyBhbnkpLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhY3RvcmllcztcbiAgICAgIH0pXG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21GYWN0b3JpZXM8VD4oXG4gIGZhY3Rvcmllcz86IEFycmF5PFxuICAgIHwgVFxuICAgIHwgVFtdXG4gICAgfCBFeHRlbnNpb25GYWN0b3J5PFQ+XG4gICAgfCBFeHRlbnNpb25GYWN0b3J5PFQ+W11cbiAgICB8ICgoKSA9PiBUIHwgRXh0ZW5zaW9uRmFjdG9yeTxUPiB8IEFycmF5PFQgfCBFeHRlbnNpb25GYWN0b3J5PFQ+PilcbiAgPixcbiAgcm91dGVyPzogUm91dGVyLFxuICB3aXRoRmlyc3RFbXB0eSA9IHRydWVcbik6IE9ic2VydmFibGU8VFtdPiB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShmYWN0b3JpZXMpIHx8IGZhY3Rvcmllcy5sZW5ndGggPCAxXG4gICAgPyBvZihbXSlcbiAgICA6IGRlZmVyKCgpID0+IHtcbiAgICAgICAgY29uc3QgZmFjdG9yeU9ic2VydmFibGVzOiBPYnNlcnZhYmxlPFRbXT5bXSA9IHJlc29sdmVJbmplY3RlZEZhY3RvcmllcyhmYWN0b3JpZXMpLm1hcChmID0+IHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvT2JzZXJ2YWJsZU9mQXJyYXlzKGYsIHdpdGhGaXJzdEVtcHR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRXh0ZW5zaW9uRmFjdG9yeShmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvT2JzZXJ2YWJsZU9mQXJyYXlzKGYuZ2V0KGdldEFjdGl2YXRlZFJvdXRlKHJvdXRlcikpLCB3aXRoRmlyc3RFbXB0eSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRvT2JzZXJ2YWJsZU9mQXJyYXlzKFtmXSwgd2l0aEZpcnN0RW1wdHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoZmFjdG9yeU9ic2VydmFibGVzKTtcbiAgICAgIH0pLnBpcGUoXG4gICAgICAgIG1hcChyZXN1bHRzID0+IHNvcnRCeVByaW9yaXR5KFtdLmNvbmNhdCguLi5yZXN1bHRzKSkpLFxuICAgICAgICBtYXAodmFsdWUgPT4gdW5pcSh2YWx1ZSkpXG4gICAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUluamVjdGVkRmFjdG9yaWVzPFQ+KFxuICBmYWN0b3JpZXM6IEFycmF5PFxuICAgIHwgVFxuICAgIHwgVFtdXG4gICAgfCBFeHRlbnNpb25GYWN0b3J5PFQ+XG4gICAgfCBFeHRlbnNpb25GYWN0b3J5PFQ+W11cbiAgICB8ICgoKSA9PiBUIHwgRXh0ZW5zaW9uRmFjdG9yeTxUPiB8IEFycmF5PFQgfCBFeHRlbnNpb25GYWN0b3J5PFQ+PilcbiAgPlxuKTogQXJyYXk8VCB8IFRbXSB8IEV4dGVuc2lvbkZhY3Rvcnk8VD4+IHtcbiAgcmV0dXJuIGZsYXR0ZW4oXG4gICAgZmFjdG9yaWVzLm1hcChmID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBmdW5jID0gZiBhcyAoKSA9PiBUIHwgVFtdIHwgRXh0ZW5zaW9uRmFjdG9yeTxUPjtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZl07XG4gICAgfSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlVG9GYWN0b3J5PFQ+KGNvbXBvbmVudHNTdGF0ZSk6IEV4dGVuc2lvbkZhY3Rvcnk8VD4ge1xuICBjb25zdCBjb21wb25lbnRzJCA9IGNvbXBvbmVudHNTdGF0ZS5waXBlKG1hcCgoY29tcG9uZW50U2V0OiBTZXQ8VD4pID0+IFsuLi5jb21wb25lbnRTZXRdKSk7XG4gIHJldHVybiB7IGdldDogKCkgPT4gY29tcG9uZW50cyQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeVByaW9yaXR5PFQ+KGl0ZW1zOiBUW10pOiBUW10ge1xuICByZXR1cm4gc29ydEJ5KGl0ZW1zLCBpdGVtID0+IC0oaXRlbT8ucHJpb3JpdHkgfHwgMCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlc0lkczxUIGV4dGVuZHMgeyBpZD86IHN0cmluZzsgcHJpb3JpdHk/OiBudW1iZXIgfT4oaXRlbXM6IFRbXSk6IFRbXSB7XG4gIGNvbnN0IGdyb3VwZWQ6IHsgW2tleTogc3RyaW5nXTogVFtdIH0gPSBncm91cEJ5KGl0ZW1zLCAnaWQnKTtcbiAgY29uc3QgaXRlbXNXaXRob3V0RHVwbGljYXRlcyA9IG5ldyBBcnJheTxUPigpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhncm91cGVkKSkge1xuICAgIGlmIChrZXkgJiYga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qgc29ydGVkQnlQcmlvID0gc29ydEJ5UHJpb3JpdHkoZ3JvdXBlZFtrZXldKTtcbiAgICAgIGl0ZW1zV2l0aG91dER1cGxpY2F0ZXMucHVzaChzb3J0ZWRCeVByaW9bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtc1dpdGhvdXREdXBsaWNhdGVzLnB1c2goLi4uZ3JvdXBlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNvcnRCeVByaW9yaXR5KGl0ZW1zV2l0aG91dER1cGxpY2F0ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9PYnNlcnZhYmxlT2ZBcnJheXM8VD4oXG4gIGZhY3RvcnlSZXN1bHQ6IFQgfCBUW10gfCBQcm9taXNlPFQgfCBUW10+IHwgT2JzZXJ2YWJsZTxUIHwgVFtdPixcbiAgd2l0aEZpcnN0RW1wdHk6IGJvb2xlYW5cbik6IE9ic2VydmFibGU8VFtdPiB7XG4gIGxldCBvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPFQgfCBUW10+O1xuICBpZiAoIWZhY3RvcnlSZXN1bHQpIHtcbiAgICByZXR1cm4gb2YoW10pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmFibGUgPSB0b09ic2VydmFibGUoZmFjdG9yeVJlc3VsdCk7XG4gICAgaWYgKHdpdGhGaXJzdEVtcHR5KSB7XG4gICAgICBjb25zdCB3aXRoRW1wdHlGaXJzdCA9IG9ic2VydmFibGUucGlwZShzdGFydFdpdGgoW10pKTtcbiAgICAgIG9ic2VydmFibGUgPSByYWNlKG9ic2VydmFibGUsIHdpdGhFbXB0eUZpcnN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9ic2VydmFibGUucGlwZShcbiAgICBtYXAocmVzdWx0ID0+IChBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiBbcmVzdWx0XSkuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZTxUID0gYW55PihvYmo6IGFueSk6IG9iaiBpcyBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZW5zaW9uRmFjdG9yeTxUID0gYW55PihvYmo6IGFueSk6IG9iaiBpcyBFeHRlbnNpb25GYWN0b3J5PFQ+IHtcbiAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmouZ2V0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFueSB2YWx1ZSBwcm92aWRlZCB0byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhpcyB2YWx1ZSBvbmNlIGFuZCB0aGVuIGNvbXBsZXRlcy5cbiAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHRvIHJlcHJlc2VudCBhbGwgdGhlIGRhdGEgYXMgT2JzZXJ2YWJsZXMgcmF0aGVyIHRoYW5cbiAqIGEgbWl4dHVyZSBvZiBPYnNlcnZhYmxlcyBhbmQgb3RoZXIgdHlwZXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUgd2lsbCBlbWl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9PYnNlcnZhYmxlPFQ+KHZhbHVlOiBUIHwgUHJvbWlzZTxUPiB8IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgaWYgKGlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tKHZhbHVlIGFzIFByb21pc2U8VD4pO1xuICB9XG5cbiAgcmV0dXJuIG9mKHZhbHVlIGFzIFQpO1xufVxuXG4vKipcbiAqIEFsbG93cyB0byBleHRlbmQgdGhlIGV4aXN0aW5nIGFwcGxpY2F0aW9ucyBmcm9tIGEgbW9kdWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVuc2lvbkZhY3Rvcnk8VD4ge1xuICAvKipcbiAgICogQWxsb3dzIHRvIHJlc29sdmUgdGhlIGRhdGEgb2YgYW4gZXh0ZW5zaW9uIHBvaW50LlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIGNhbiBiZSBhIFByb21pc2Ugb3IgT2JzZXJ2YWJsZVxuICAgKiAoYWxsb3dpbmcgZm9yIGFzeW5jaHJvbm91cyBkYXRhIHJlc29sdXRpb24pLlxuICAgKlxuICAgKiBAcGFyYW0gYWN0aXZhdGVkUm91dGUgVGhlIGN1cnJlbnQgYWN0aXZhdGVkIHJvdXRlIChpZiBwb3NzaWJsZSB0byByZXNvbHZlKS5cbiAgICovXG4gIGdldChhY3RpdmF0ZWRSb3V0ZT86IEFjdGl2YXRlZFJvdXRlKTogT2JzZXJ2YWJsZTxUW10gfCBUPiB8IFByb21pc2U8VFtdIHwgVD4gfCBUW10gfCBUO1xufVxuXG4vKipcbiAqIEV4dGVuc2lvbiBwb2ludHMgYWxsb3cgdG8gZXh0ZW5kIHRoZSBhcHBsaWNhdGlvbiBmcm9tXG4gKiBhbnkgbW9kdWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZW5zaW9uUG9pbnQ8VD4ge1xuICAvKipcbiAgICogT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9mIGFycmF5IG9mIGV4dGVuc2lvbnMgYWN0aXZlIGF0IGFueSBnaXZlIHRpbWVcbiAgICovXG4gIHJlYWRvbmx5IGl0ZW1zJDogT2JzZXJ2YWJsZTxUW10+O1xuICAvKipcbiAgICogQWRkaXRpb25hbCBmYWN0b3JpZXMgdGhhdCBjYW4gYmUgYWRkZWQgZHluYW1pY2FsbHkuICh3aXRob3V0IGhvb2spXG4gICAqL1xuICBmYWN0b3JpZXM6IEV4dGVuc2lvbkZhY3Rvcnk8VD5bXTtcbiAgLyoqXG4gICAqIENhbGwgdGhlIGV4dGVuc2lvbiBmYWN0b3JpZXMgdG8gcmVmcmVzaCB0aGVtLlxuICAgKi9cbiAgcmVmcmVzaCgpO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRXh0ZW5zaW9uUG9pbnRXaXRob3V0U3RhdGVGb3JQbHVnaW5zPFQ+IGltcGxlbWVudHMgRXh0ZW5zaW9uUG9pbnQ8VD4ge1xuICBpdGVtcyQ6IE9ic2VydmFibGU8VFtdPjtcbiAgZmFjdG9yaWVzOiBFeHRlbnNpb25GYWN0b3J5PFQ+W10gPSBbXTtcbiAgcmVhZG9ubHkgcmVmcmVzaCQ6IE9ic2VydmFibGU8dm9pZD47XG4gIC8qKlxuICAgKiBBbGwgaW5qZWN0b3JzIHRvIHNlYXJjaCBmb3IgYW4gZXh0ZW5zaW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGluamVjdG9yczogSW5qZWN0b3JbXTtcbiAgcHJpdmF0ZSByZWFkb25seSByZWZyZXNoVHJpZ2dlciA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3Iocm9vdEluamVjdG9yOiBJbmplY3RvciwgcGx1Z2luU2VydmljZTogUGx1Z2luc1Jlc29sdmVTZXJ2aWNlKSB7XG4gICAgdGhpcy5pbmplY3RvcnMgPSBbcm9vdEluamVjdG9yXTtcbiAgICBwbHVnaW5TZXJ2aWNlLmluamVjdG9ycyQuc3Vic2NyaWJlKGluamVjdG9yID0+IHtcbiAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xuICAgIH0pO1xuICAgIHRoaXMucmVmcmVzaCQgPSBtZXJnZSh0aGlzLnJlZnJlc2hUcmlnZ2VyLCBwbHVnaW5TZXJ2aWNlLnJlZnJlc2gkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBleHRlbnNpb24gZmFjdG9yaWVzXG4gICAqL1xuICByZWZyZXNoKCk6IHZvaWQge1xuICAgIHRoaXMucmVmcmVzaFRyaWdnZXIubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgd2l0aGluIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZXh0ZW5kaW5nIGNsYXNzIGFuZCBzZXQgdGhlIGl0ZW1zJCBhdHRyaWJ1dGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2V0dXBJdGVtc09ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxUW10+O1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRXh0ZW5zaW9uUG9pbnRGb3JQbHVnaW5zPFQ+XG4gIGV4dGVuZHMgU3RhdGVTZXJ2aWNlXG4gIGltcGxlbWVudHMgRXh0ZW5zaW9uUG9pbnQ8VD5cbntcbiAgaXRlbXMkOiBPYnNlcnZhYmxlPFRbXT47XG4gIGZhY3RvcmllczogRXh0ZW5zaW9uRmFjdG9yeTxUPltdID0gW107XG4gIHJlYWRvbmx5IHJlZnJlc2gkOiBPYnNlcnZhYmxlPHZvaWQ+O1xuICByZWFkb25seSBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFNldDxUPj4obmV3IFNldDxUPigpKTtcbiAgLyoqXG4gICAqIEFsbCBpbmplY3RvcnMgdG8gc2VhcmNoIGZvciBhbiBleHRlbnNpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgaW5qZWN0b3JzOiBJbmplY3RvcltdO1xuICBwcml2YXRlIHJlYWRvbmx5IHJlZnJlc2hUcmlnZ2VyID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihyb290SW5qZWN0b3I6IEluamVjdG9yLCBwbHVnaW5TZXJ2aWNlOiBQbHVnaW5zUmVzb2x2ZVNlcnZpY2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaW5qZWN0b3JzID0gW3Jvb3RJbmplY3Rvcl07XG4gICAgcGx1Z2luU2VydmljZS5pbmplY3RvcnMkLnN1YnNjcmliZShpbmplY3RvciA9PiB7XG4gICAgICB0aGlzLmluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZnJlc2gkID0gbWVyZ2UodGhpcy5yZWZyZXNoVHJpZ2dlciwgcGx1Z2luU2VydmljZS5yZWZyZXNoJCk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgZXh0ZW5zaW9uIGZhY3Rvcmllc1xuICAgKi9cbiAgcmVmcmVzaCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlZnJlc2hUcmlnZ2VyLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG91bGQgYmUgY2FsbGVkIHdpdGhpbiB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGV4dGVuZGluZyBjbGFzcyBhbmQgc2V0IHRoZSBpdGVtcyQgYXR0cmlidXRlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNldHVwSXRlbXNPYnNlcnZhYmxlKCk6IE9ic2VydmFibGU8VFtdPjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBhY3RpdmF0ZWQgcm91dGUgaW5cbiAqIGEgc2VydmljZSAoYXMgQWN0aXZhdGVkUm91dGUgaW5qZWN0aW9uIG9ubHlcbiAqIHdvcmtzIGluIGNvbXBvbmVudHMpLiBXb3JrcyBhcyBsb25nIGFzIHdlIG9ubHkgdXNlXG4gKiBhIHRyZWUgYW5kIG5vIGNoaWxkIGlzIGFjdGl2ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICpcbiAqIEBwYXJhbSByb3V0ZXIgVGhlIGN1cnJlbnQgcm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpdmF0ZWRSb3V0ZShyb3V0ZXI6IFJvdXRlcik6IEFjdGl2YXRlZFJvdXRlIHtcbiAgaWYgKHJvdXRlciAmJiByb3V0ZXIucm91dGVyU3RhdGUgJiYgcm91dGVyLnJvdXRlclN0YXRlLnJvb3QpIHtcbiAgICBsZXQgcm91dGUgPSByb3V0ZXIucm91dGVyU3RhdGUucm9vdDtcbiAgICB3aGlsZSAocm91dGUuZmlyc3RDaGlsZCkge1xuICAgICAgcm91dGUgPSByb3V0ZS5maXJzdENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGU7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgR2VuZXJpY0hvb2tUeXBlPFQ+ID0gVCB8IFRbXSB8IFR5cGU8RXh0ZW5zaW9uRmFjdG9yeTxUPj47XG5leHBvcnQgdHlwZSBIb29rVmFsdWVUeXBlPFQ+ID0gVCB8IFRbXSB8IFR5cGU8VD47XG5cbi8qKlxuICogQSBnZW5lcmljIGZ1bmN0aW9uIHRvIGJlIHVzZWQgYnkgc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBIT09LIGNvbmNlcHQuXG4gKiBAcGFyYW0gaXRlbXMgVGhlIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIHByb3ZpZGVkIHVuZGVyIHRoZSBgdXNlVmFsdWVgIG9yIGB1c2VDbGFzc2AgYXR0cmlidXRlLlxuICogQWxsb3dzIGFuIGV4dGVuc2lvbiBmYWN0b3J5IHRvIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudCwgd2hpY2ggY2FuIGNyZWF0ZSBpbnN0YW5jZXMgb2YgdHlwZSBULlxuICogQHBhcmFtIHRva2VuIFRoZSBJbmplY3Rpb25Ub2tlbi9IT09LIHRvIGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIG9wdGlvbnMgSWYgdGhpcyBpcyBhIG11bHRpIHByb3ZpZGVyIG9yIG5vdCAoZGVmYXVsdHMgdG8gdHJ1ZSkgYW5kIHByb3ZpZGVyIHR5cGUgZGVmaW5pdGlvbiAoZGVmYXVsdHMgdG8gQ2xhc3NQcm92aWRlcikgLSBgSG9va09wdGlvbnNgLlxuICogQHJldHVybnMgQSBgUHJvdmlkZXJgIChlaXRoZXIgYFZhbHVlUHJvdmlkZXJgIG9yIGBDbGFzc1Byb3ZpZGVyYCkgdG8gYmUgcHJvdmlkZWQgaW4gYSBtb2R1bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBob29rR2VuZXJpYzxUPihcbiAgaXRlbXM6IEdlbmVyaWNIb29rVHlwZTxUPiB8IEhvb2tWYWx1ZVR5cGU8VD4sXG4gIHRva2VuOiBJbmplY3Rpb25Ub2tlbjxUPixcbiAgb3B0aW9ucz86IFBhcnRpYWw8SG9va09wdGlvbnM+XG4pOiBWYWx1ZVByb3ZpZGVyIHwgQ2xhc3NQcm92aWRlciB8IEV4aXN0aW5nUHJvdmlkZXIge1xuICBjb25zdCBmaW5hbE9wdGlvbnM6IEhvb2tPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICB7IG11bHRpOiB0cnVlLCBwcm92aWRlclR5cGU6IEhvb2tQcm92aWRlclR5cGVzLkNsYXNzUHJvdmlkZXIgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIGNvbnN0IHsgbXVsdGksIHByb3ZpZGVyVHlwZSB9ID0gZmluYWxPcHRpb25zO1xuICBpZiAodHlwZW9mIGl0ZW1zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3ZpZGU6IHRva2VuLFxuICAgICAgdXNlVmFsdWU6IGl0ZW1zLFxuICAgICAgbXVsdGlcbiAgICB9IGFzIFZhbHVlUHJvdmlkZXI7XG4gIH1cblxuICBpZiAocHJvdmlkZXJUeXBlID09PSBIb29rUHJvdmlkZXJUeXBlcy5FeGlzdGluZ1Byb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3ZpZGU6IHRva2VuLFxuICAgICAgdXNlRXhpc3Rpbmc6IGl0ZW1zLFxuICAgICAgbXVsdGlcbiAgICB9IGFzIEV4aXN0aW5nUHJvdmlkZXI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb3ZpZGU6IHRva2VuLFxuICAgIHVzZUNsYXNzOiBpdGVtcyxcbiAgICBtdWx0aVxuICB9IGFzIENsYXNzUHJvdmlkZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIEhvb2tPcHRpb25zIHtcbiAgbXVsdGk6IGJvb2xlYW47XG4gIHByb3ZpZGVyVHlwZTogSG9va1Byb3ZpZGVyVHlwZXM7XG59XG5cbmV4cG9ydCBlbnVtIEhvb2tQcm92aWRlclR5cGVzIHtcbiAgRXhpc3RpbmdQcm92aWRlciA9ICdFeGlzdGluZ1Byb3ZpZGVyJyxcbiAgQ2xhc3NQcm92aWRlciA9ICdDbGFzc1Byb3ZpZGVyJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsRW50cmllc0FyZUVxdWFsKHByZXZpb3VzOiBBcnJheTx1bmtub3duPiwgbmV4dDogQXJyYXk8dW5rbm93bj4pOiBib29sZWFuIHtcbiAgaWYgKHByZXZpb3VzID09PSBuZXh0KSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHByZXZpb3VzID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwcmV2aW91cy5sZW5ndGggIT09IG5leHQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcmV2aW91c1tpXSAhPT0gbmV4dFtpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl19