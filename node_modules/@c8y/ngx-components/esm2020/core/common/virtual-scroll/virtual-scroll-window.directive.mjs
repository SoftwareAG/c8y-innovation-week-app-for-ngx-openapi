import { coerceNumberProperty } from '@angular/cdk/coercion';
import { VIRTUAL_SCROLL_STRATEGY } from '@angular/cdk/scrolling';
import { Directive, forwardRef, Input } from '@angular/core';
import { VirtualScrollWindowStrategy } from './virtual-scroll-window-strategy';
import * as i0 from "@angular/core";
/**
 * Provider factory for `VirtualScrollWindowStrategy` that simply extracts the already created
 * `VirtualScrollWindowStrategy` from the given directive.
 * @param windowDir The instance of `VirtualScrollWindowDirective` to extract the
 *     `VirtualScrollWindowStrategy` from.
 */
export function _virtualScrollWindowStrategyFactory(windowDir) {
    return windowDir._scrollStrategy;
}
// This is an adapted version of the original CdkFixedSizeVirtualScroll
// https://github.com/angular/components/blob/master/src/cdk/scrolling/fixed-size-virtual-scroll.ts
export class VirtualScrollWindowDirective {
    constructor() {
        this._itemSizePx = 20;
        this._minBufferPx = 100;
        this._maxBufferPx = 200;
        this._offsetSizePx = 0;
        /** The scroll strategy used by this directive. */
        this._scrollStrategy = new VirtualScrollWindowStrategy(this.itemSizePx, this.offsetSizePx, this.minBufferPx, this.maxBufferPx);
    }
    /** The size of the items in the list (in pixels). */
    get itemSizePx() {
        return this._itemSizePx;
    }
    set itemSizePx(value) {
        this._itemSizePx = coerceNumberProperty(value);
    }
    /**
     * The minimum amount of buffer rendered beyond the viewport (in pixels).
     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
     */
    get minBufferPx() {
        return this._minBufferPx;
    }
    set minBufferPx(value) {
        this._minBufferPx = coerceNumberProperty(value);
    }
    /**
     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
     */
    get maxBufferPx() {
        return this._maxBufferPx;
    }
    set maxBufferPx(value) {
        this._maxBufferPx = coerceNumberProperty(value);
    }
    /** The size of the offset (in pixels). */
    get offsetSizePx() {
        return this._offsetSizePx;
    }
    set offsetSizePx(value) {
        this._offsetSizePx = coerceNumberProperty(value);
    }
    ngOnChanges() {
        this._scrollStrategy.updateItemAndBufferSize(this.itemSizePx, this.offsetSizePx, this.minBufferPx, this.maxBufferPx);
    }
}
VirtualScrollWindowDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: VirtualScrollWindowDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
VirtualScrollWindowDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.7", type: VirtualScrollWindowDirective, selector: "cdk-virtual-scroll-viewport[windowVirtualScrollStrategy]", inputs: { itemSizePx: "itemSizePx", minBufferPx: "minBufferPx", maxBufferPx: "maxBufferPx", offsetSizePx: "offsetSizePx" }, providers: [
        {
            provide: VIRTUAL_SCROLL_STRATEGY,
            useFactory: _virtualScrollWindowStrategyFactory,
            deps: [forwardRef(() => VirtualScrollWindowDirective)]
        }
    ], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: VirtualScrollWindowDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'cdk-virtual-scroll-viewport[windowVirtualScrollStrategy]',
                    providers: [
                        {
                            provide: VIRTUAL_SCROLL_STRATEGY,
                            useFactory: _virtualScrollWindowStrategyFactory,
                            deps: [forwardRef(() => VirtualScrollWindowDirective)]
                        }
                    ]
                }]
        }], propDecorators: { itemSizePx: [{
                type: Input
            }], minBufferPx: [{
                type: Input
            }], maxBufferPx: [{
                type: Input
            }], offsetSizePx: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC1zY3JvbGwtd2luZG93LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2NvcmUvY29tbW9uL3ZpcnR1YWwtc2Nyb2xsL3ZpcnR1YWwtc2Nyb2xsLXdpbmRvdy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDN0QsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakUsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDOztBQUUvRTs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxtQ0FBbUMsQ0FBQyxTQUF1QztJQUN6RixPQUFPLFNBQVMsQ0FBQyxlQUFlLENBQUM7QUFDbkMsQ0FBQztBQUVELHVFQUF1RTtBQUN2RSxtR0FBbUc7QUFXbkcsTUFBTSxPQUFPLDRCQUE0QjtJQVZ6QztRQW1CRSxnQkFBVyxHQUFHLEVBQUUsQ0FBQztRQWFqQixpQkFBWSxHQUFHLEdBQUcsQ0FBQztRQVluQixpQkFBWSxHQUFHLEdBQUcsQ0FBQztRQVVuQixrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUVsQixrREFBa0Q7UUFDbEQsb0JBQWUsR0FBZ0MsSUFBSSwyQkFBMkIsQ0FDNUUsSUFBSSxDQUFDLFVBQVUsRUFDZixJQUFJLENBQUMsWUFBWSxFQUNqQixJQUFJLENBQUMsV0FBVyxFQUNoQixJQUFJLENBQUMsV0FBVyxDQUNqQixDQUFDO0tBVUg7SUE3REMscURBQXFEO0lBQ3JELElBQ0ksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDO0lBQ0QsSUFBSSxVQUFVLENBQUMsS0FBYTtRQUMxQixJQUFJLENBQUMsV0FBVyxHQUFHLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFHRDs7O09BR0c7SUFDSCxJQUNJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUNELElBQUksV0FBVyxDQUFDLEtBQWE7UUFDM0IsSUFBSSxDQUFDLFlBQVksR0FBRyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBR0Q7O09BRUc7SUFDSCxJQUNJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUNELElBQUksV0FBVyxDQUFDLEtBQWE7UUFDM0IsSUFBSSxDQUFDLFlBQVksR0FBRyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBR0QsMENBQTBDO0lBQzFDLElBQ0ksWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM1QixDQUFDO0lBQ0QsSUFBSSxZQUFZLENBQUMsS0FBYTtRQUM1QixJQUFJLENBQUMsYUFBYSxHQUFHLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFXRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLGVBQWUsQ0FBQyx1QkFBdUIsQ0FDMUMsSUFBSSxDQUFDLFVBQVUsRUFDZixJQUFJLENBQUMsWUFBWSxFQUNqQixJQUFJLENBQUMsV0FBVyxFQUNoQixJQUFJLENBQUMsV0FBVyxDQUNqQixDQUFDO0lBQ0osQ0FBQzs7eUhBN0RVLDRCQUE0Qjs2R0FBNUIsNEJBQTRCLCtNQVI1QjtRQUNUO1lBQ0UsT0FBTyxFQUFFLHVCQUF1QjtZQUNoQyxVQUFVLEVBQUUsbUNBQW1DO1lBQy9DLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQ3ZEO0tBQ0Y7MkZBRVUsNEJBQTRCO2tCQVZ4QyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSwwREFBMEQ7b0JBQ3BFLFNBQVMsRUFBRTt3QkFDVDs0QkFDRSxPQUFPLEVBQUUsdUJBQXVCOzRCQUNoQyxVQUFVLEVBQUUsbUNBQW1DOzRCQUMvQyxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLDZCQUE2QixDQUFDLENBQUM7eUJBQ3ZEO3FCQUNGO2lCQUNGOzhCQUlLLFVBQVU7c0JBRGIsS0FBSztnQkFjRixXQUFXO3NCQURkLEtBQUs7Z0JBYUYsV0FBVztzQkFEZCxLQUFLO2dCQVdGLFlBQVk7c0JBRGYsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvZXJjZU51bWJlclByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IFZJUlRVQUxfU0NST0xMX1NUUkFURUdZIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIGZvcndhcmRSZWYsIElucHV0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxXaW5kb3dTdHJhdGVneSB9IGZyb20gJy4vdmlydHVhbC1zY3JvbGwtd2luZG93LXN0cmF0ZWd5JztcblxuLyoqXG4gKiBQcm92aWRlciBmYWN0b3J5IGZvciBgVmlydHVhbFNjcm9sbFdpbmRvd1N0cmF0ZWd5YCB0aGF0IHNpbXBseSBleHRyYWN0cyB0aGUgYWxyZWFkeSBjcmVhdGVkXG4gKiBgVmlydHVhbFNjcm9sbFdpbmRvd1N0cmF0ZWd5YCBmcm9tIHRoZSBnaXZlbiBkaXJlY3RpdmUuXG4gKiBAcGFyYW0gd2luZG93RGlyIFRoZSBpbnN0YW5jZSBvZiBgVmlydHVhbFNjcm9sbFdpbmRvd0RpcmVjdGl2ZWAgdG8gZXh0cmFjdCB0aGVcbiAqICAgICBgVmlydHVhbFNjcm9sbFdpbmRvd1N0cmF0ZWd5YCBmcm9tLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX3ZpcnR1YWxTY3JvbGxXaW5kb3dTdHJhdGVneUZhY3Rvcnkod2luZG93RGlyOiBWaXJ0dWFsU2Nyb2xsV2luZG93RGlyZWN0aXZlKSB7XG4gIHJldHVybiB3aW5kb3dEaXIuX3Njcm9sbFN0cmF0ZWd5O1xufVxuXG4vLyBUaGlzIGlzIGFuIGFkYXB0ZWQgdmVyc2lvbiBvZiB0aGUgb3JpZ2luYWwgQ2RrRml4ZWRTaXplVmlydHVhbFNjcm9sbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvY29tcG9uZW50cy9ibG9iL21hc3Rlci9zcmMvY2RrL3Njcm9sbGluZy9maXhlZC1zaXplLXZpcnR1YWwtc2Nyb2xsLnRzXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdjZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnRbd2luZG93VmlydHVhbFNjcm9sbFN0cmF0ZWd5XScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IFZJUlRVQUxfU0NST0xMX1NUUkFURUdZLFxuICAgICAgdXNlRmFjdG9yeTogX3ZpcnR1YWxTY3JvbGxXaW5kb3dTdHJhdGVneUZhY3RvcnksXG4gICAgICBkZXBzOiBbZm9yd2FyZFJlZigoKSA9PiBWaXJ0dWFsU2Nyb2xsV2luZG93RGlyZWN0aXZlKV1cbiAgICB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbFNjcm9sbFdpbmRvd0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgaXRlbXMgaW4gdGhlIGxpc3QgKGluIHBpeGVscykuICovXG4gIEBJbnB1dCgpXG4gIGdldCBpdGVtU2l6ZVB4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1TaXplUHg7XG4gIH1cbiAgc2V0IGl0ZW1TaXplUHgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2l0ZW1TaXplUHggPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgX2l0ZW1TaXplUHggPSAyMDtcblxuICAvKipcbiAgICogVGhlIG1pbmltdW0gYW1vdW50IG9mIGJ1ZmZlciByZW5kZXJlZCBiZXlvbmQgdGhlIHZpZXdwb3J0IChpbiBwaXhlbHMpLlxuICAgKiBJZiB0aGUgYW1vdW50IG9mIGJ1ZmZlciBkaXBzIGJlbG93IHRoaXMgbnVtYmVyLCBtb3JlIGl0ZW1zIHdpbGwgYmUgcmVuZGVyZWQuIERlZmF1bHRzIHRvIDEwMHB4LlxuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IG1pbkJ1ZmZlclB4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX21pbkJ1ZmZlclB4O1xuICB9XG4gIHNldCBtaW5CdWZmZXJQeCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fbWluQnVmZmVyUHggPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgX21pbkJ1ZmZlclB4ID0gMTAwO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHBpeGVscyB3b3J0aCBvZiBidWZmZXIgdG8gcmVuZGVyIGZvciB3aGVuIHJlbmRlcmluZyBuZXcgaXRlbXMuIERlZmF1bHRzIHRvIDIwMHB4LlxuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IG1heEJ1ZmZlclB4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX21heEJ1ZmZlclB4O1xuICB9XG4gIHNldCBtYXhCdWZmZXJQeCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fbWF4QnVmZmVyUHggPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgX21heEJ1ZmZlclB4ID0gMjAwO1xuXG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgb2Zmc2V0IChpbiBwaXhlbHMpLiAqL1xuICBASW5wdXQoKVxuICBnZXQgb2Zmc2V0U2l6ZVB4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldFNpemVQeDtcbiAgfVxuICBzZXQgb2Zmc2V0U2l6ZVB4KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9vZmZzZXRTaXplUHggPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgX29mZnNldFNpemVQeCA9IDA7XG5cbiAgLyoqIFRoZSBzY3JvbGwgc3RyYXRlZ3kgdXNlZCBieSB0aGlzIGRpcmVjdGl2ZS4gKi9cbiAgX3Njcm9sbFN0cmF0ZWd5OiBWaXJ0dWFsU2Nyb2xsV2luZG93U3RyYXRlZ3kgPSBuZXcgVmlydHVhbFNjcm9sbFdpbmRvd1N0cmF0ZWd5KFxuICAgIHRoaXMuaXRlbVNpemVQeCxcbiAgICB0aGlzLm9mZnNldFNpemVQeCxcbiAgICB0aGlzLm1pbkJ1ZmZlclB4LFxuICAgIHRoaXMubWF4QnVmZmVyUHhcbiAgKTtcblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICB0aGlzLl9zY3JvbGxTdHJhdGVneS51cGRhdGVJdGVtQW5kQnVmZmVyU2l6ZShcbiAgICAgIHRoaXMuaXRlbVNpemVQeCxcbiAgICAgIHRoaXMub2Zmc2V0U2l6ZVB4LFxuICAgICAgdGhpcy5taW5CdWZmZXJQeCxcbiAgICAgIHRoaXMubWF4QnVmZmVyUHhcbiAgICApO1xuICB9XG59XG4iXX0=