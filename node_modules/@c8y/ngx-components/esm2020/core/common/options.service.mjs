import { InjectionToken, Optional, Inject, Injectable } from '@angular/core';
import { camelCase, isUndefined } from 'lodash-es';
import { ApplicationOptions } from './ApplicationOptions';
import { hookGeneric } from './extension-hooks';
import { SystemOptionsService, TenantOptionsService } from '@c8y/ngx-components/api';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/ngx-components/api";
/**
 * @deprecated Consider using the `hookOptions` function instead.
 */
export const HOOK_OPTIONS = new InjectionToken('HOOK_OPTIONS');
/**
 * You can either provide a single `ApplicationOptions` as parameter:
 * ```typescript
 *  hookOptions(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookOptions([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<ApplicationOptions>`
 * ```typescript
 *  export class MyApplicationOptionsFactory implements ExtensionFactory<ApplicationOptions> {...}
 *  ...
 *  hookOptions(MyApplicationOptionsFactory)
 * ```
 * A typed alternative to `HOOK_OPTIONS`.
 * @param options The `ApplicationOptions`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookOptions(options, hookOptions) {
    return hookGeneric(options, HOOK_OPTIONS, hookOptions);
}
/**
 * A service that allows to set or get application options
 * which configure the default behavior of the UI.
 */
export class OptionsService extends ApplicationOptions {
    constructor(options, systemOptionsService, tenantOptionService) {
        super();
        this.systemOptionsService = systemOptionsService;
        this.tenantOptionService = tenantOptionService;
        this.setupOptions(options);
    }
    /**
     * Returns an application option used to configure the UI.
     * @param optionKey The application options key.
     * @param defaultValue A value to return if non is set.
     * @param attemptParse Indicates whether the value should be parsed with JSON.parse.
     */
    get(optionKey, defaultValue, attemptParse) {
        let value = this[optionKey];
        if (typeof value === 'undefined') {
            value = this[camelCase(optionKey)];
        }
        if (attemptParse) {
            return this.parseOptionRawValue(value, defaultValue);
        }
        return typeof value !== 'undefined' ? value : defaultValue;
    }
    /**
     * Sets an application option.
     * @param key The key to set.
     * @param value The value to set.
     */
    set(key, value) {
        this[camelCase(key)] = value;
    }
    /**
     * Gets support url from tenant options.
     * If response returns '404 not found' it gets the support url from application options.
     * If the support link within application options is not provided the UI will use the system options.
     * Is the support link explicitly set to false it will be hidden.
     *
     * @returns Returns support url or false.
     */
    async getSupportUrl() {
        let url = await this.getTenantOption('configuration', 'system.support.url');
        if (isUndefined(url)) {
            url = this.supportUrl;
        }
        this.supportUrl = isUndefined(url)
            ? (await this.getSystemOption('support', 'url')) || false
            : url;
        return this.supportUrl;
    }
    /**
     * Returns if the tenant allows to show the activate-support user menu entry.
     * Note: Only if system-level support-user/enabled is false we can activate it at tenant level.
     */
    async getActivateSupportUser() {
        const option = await this.getSystemOption('support-user', 'enabled', true);
        return !option;
    }
    /**
     * Gets a value from the system service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    async getSystemOption(category, key, defaultValue) {
        return this.getOptionFromService(category, key, this.systemOptionsService, defaultValue);
    }
    /**
     * Gets a value from the tenant service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    async getTenantOption(category, key, defaultValue) {
        return this.getOptionFromService(category, key, this.tenantOptionService, defaultValue);
    }
    setupOptions(options) {
        if (options) {
            if (!Array.isArray(options)) {
                options = [options];
            }
            options.forEach(optionMap => {
                if (optionMap) {
                    Object.keys(optionMap).forEach(key => {
                        this[camelCase(key)] = optionMap[key];
                    });
                }
            });
        }
    }
    async getOptionFromService(category, key, service, defaultValue) {
        try {
            const { data } = await service.detail({ category, key });
            return this.parseOptionRawValue(data.value, defaultValue);
        }
        catch (ex) {
            return defaultValue;
        }
    }
    parseOptionRawValue(rawValue, defaultValue) {
        let value;
        try {
            value = JSON.parse(rawValue);
        }
        catch (e) {
            value = isUndefined(rawValue) ? defaultValue : rawValue;
        }
        return value;
    }
}
OptionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: OptionsService, deps: [{ token: HOOK_OPTIONS, optional: true }, { token: i1.SystemOptionsService }, { token: i1.TenantOptionsService }], target: i0.ɵɵFactoryTarget.Injectable });
OptionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: OptionsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: OptionsService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [HOOK_OPTIONS]
                }] }, { type: i1.SystemOptionsService }, { type: i1.TenantOptionsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9ucy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vb3B0aW9ucy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0UsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDbkQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDMUQsT0FBTyxFQUFxQyxXQUFXLEVBQWUsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7O0FBRXJGOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLElBQUksY0FBYyxDQUM1QyxjQUFjLENBQ2YsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3pCLE9BQTRDLEVBQzVDLFdBQWtDO0lBRWxDLE9BQU8sV0FBVyxDQUFxQixPQUFPLEVBQUUsWUFBWSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFFRDs7O0dBR0c7QUFFSCxNQUFNLE9BQU8sY0FBZSxTQUFRLGtCQUFrQjtJQUVwRCxZQUNvQyxPQUFPLEVBQ2pDLG9CQUEwQyxFQUMxQyxtQkFBeUM7UUFFakQsS0FBSyxFQUFFLENBQUM7UUFIQSx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBQzFDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBc0I7UUFHakQsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxHQUFHLENBQWMsU0FBK0IsRUFBRSxZQUFrQixFQUFFLFlBQXNCO1FBQzFGLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM1QixJQUFJLE9BQU8sS0FBSyxLQUFLLFdBQVcsRUFBRTtZQUNoQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxZQUFZLEVBQUU7WUFDaEIsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ3REO1FBQ0QsT0FBTyxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO0lBQzdELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLEdBQVcsRUFBRSxLQUFVO1FBQ3pCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsYUFBYTtRQUNqQixJQUFJLEdBQUcsR0FBcUIsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1FBQzlGLElBQUksV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3BCLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1NBQ3ZCO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDO1lBQ2hDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLO1lBQ3pELENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDUixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxzQkFBc0I7UUFDMUIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0UsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FDbkIsUUFBZ0IsRUFDaEIsR0FBVyxFQUNYLFlBQWdCO1FBRWhCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFJLFFBQVEsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzlGLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUNuQixRQUFnQixFQUNoQixHQUFXLEVBQ1gsWUFBZ0I7UUFFaEIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUksUUFBUSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDN0YsQ0FBQztJQUVPLFlBQVksQ0FBQyxPQUFxQjtRQUN4QyxJQUFJLE9BQU8sRUFBRTtZQUNYLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUMzQixPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNyQjtZQUNELE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLElBQUksU0FBUyxFQUFFO29CQUNiLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUNuQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN4QyxDQUFDLENBQUMsQ0FBQztpQkFDSjtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLG9CQUFvQixDQUNoQyxRQUFnQixFQUNoQixHQUFXLEVBQ1gsT0FBb0QsRUFDcEQsWUFBZTtRQUVmLElBQUk7WUFDRixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDekQsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQztTQUMzRDtRQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ1gsT0FBTyxZQUFZLENBQUM7U0FDckI7SUFDSCxDQUFDO0lBRU8sbUJBQW1CLENBQWEsUUFBZ0IsRUFBRSxZQUFlO1FBQ3ZFLElBQUksS0FBaUIsQ0FBQztRQUN0QixJQUFJO1lBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDOUI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLEtBQUssR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1NBQ3pEO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDOzsyR0FwSVUsY0FBYyxrQkFHSCxZQUFZOytHQUh2QixjQUFjLGNBREQsTUFBTTsyRkFDbkIsY0FBYztrQkFEMUIsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OzBCQUk3QixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgT3B0aW9uYWwsIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvbk9wdGlvbnMgfSBmcm9tICcuL0FwcGxpY2F0aW9uT3B0aW9ucyc7XG5pbXBvcnQgeyBFeHRlbnNpb25GYWN0b3J5LCBHZW5lcmljSG9va1R5cGUsIGhvb2tHZW5lcmljLCBIb29rT3B0aW9ucyB9IGZyb20gJy4vZXh0ZW5zaW9uLWhvb2tzJztcbmltcG9ydCB7IFN5c3RlbU9wdGlvbnNTZXJ2aWNlLCBUZW5hbnRPcHRpb25zU2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvYXBpJztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBDb25zaWRlciB1c2luZyB0aGUgYGhvb2tPcHRpb25zYCBmdW5jdGlvbiBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgSE9PS19PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuPEV4dGVuc2lvbkZhY3Rvcnk8QXBwbGljYXRpb25PcHRpb25zPj4oXG4gICdIT09LX09QVElPTlMnXG4pO1xuXG4vKipcbiAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgYSBzaW5nbGUgYEFwcGxpY2F0aW9uT3B0aW9uc2AgYXMgcGFyYW1ldGVyOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tPcHRpb25zKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tPcHRpb25zKFsuLi5dKVxuICogYGBgXG4gKlxuICogT3IgeW91IHByb3ZpZGUgYW4gU2VydmljZSB0aGF0IGltcGxlbWVudHMgYEV4dGVuc2lvbkZhY3Rvcnk8QXBwbGljYXRpb25PcHRpb25zPmBcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBleHBvcnQgY2xhc3MgTXlBcHBsaWNhdGlvbk9wdGlvbnNGYWN0b3J5IGltcGxlbWVudHMgRXh0ZW5zaW9uRmFjdG9yeTxBcHBsaWNhdGlvbk9wdGlvbnM+IHsuLi59XG4gKiAgLi4uXG4gKiAgaG9va09wdGlvbnMoTXlBcHBsaWNhdGlvbk9wdGlvbnNGYWN0b3J5KVxuICogYGBgXG4gKiBBIHR5cGVkIGFsdGVybmF0aXZlIHRvIGBIT09LX09QVElPTlNgLlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIGBBcHBsaWNhdGlvbk9wdGlvbnNgJ3Mgb3IgYEV4dGVuc2lvbkZhY3RvcnlgIHRvIGJlIHByb3ZpZGVkLlxuICogQHJldHVybnMgQW4gYFByb3ZpZGVyYCB0byBiZSBwcm92aWRlZCBpbiB5b3VyIG1vZHVsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhvb2tPcHRpb25zKFxuICBvcHRpb25zOiBHZW5lcmljSG9va1R5cGU8QXBwbGljYXRpb25PcHRpb25zPixcbiAgaG9va09wdGlvbnM/OiBQYXJ0aWFsPEhvb2tPcHRpb25zPlxuKSB7XG4gIHJldHVybiBob29rR2VuZXJpYzxBcHBsaWNhdGlvbk9wdGlvbnM+KG9wdGlvbnMsIEhPT0tfT1BUSU9OUywgaG9va09wdGlvbnMpO1xufVxuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGFsbG93cyB0byBzZXQgb3IgZ2V0IGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAqIHdoaWNoIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgVUkuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgT3B0aW9uc1NlcnZpY2UgZXh0ZW5kcyBBcHBsaWNhdGlvbk9wdGlvbnMge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoSE9PS19PUFRJT05TKSBvcHRpb25zLFxuICAgIHByaXZhdGUgc3lzdGVtT3B0aW9uc1NlcnZpY2U6IFN5c3RlbU9wdGlvbnNTZXJ2aWNlLFxuICAgIHByaXZhdGUgdGVuYW50T3B0aW9uU2VydmljZTogVGVuYW50T3B0aW9uc1NlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFwcGxpY2F0aW9uIG9wdGlvbiB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgVUkuXG4gICAqIEBwYXJhbSBvcHRpb25LZXkgVGhlIGFwcGxpY2F0aW9uIG9wdGlvbnMga2V5LlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEEgdmFsdWUgdG8gcmV0dXJuIGlmIG5vbiBpcyBzZXQuXG4gICAqIEBwYXJhbSBhdHRlbXB0UGFyc2UgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHZhbHVlIHNob3VsZCBiZSBwYXJzZWQgd2l0aCBKU09OLnBhcnNlLlxuICAgKi9cbiAgZ2V0PFQgPSB1bmtub3duPihvcHRpb25LZXk6IGtleW9mIE9wdGlvbnNTZXJ2aWNlLCBkZWZhdWx0VmFsdWU/OiBhbnksIGF0dGVtcHRQYXJzZT86IGJvb2xlYW4pOiBUIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzW29wdGlvbktleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gdGhpc1tjYW1lbENhc2Uob3B0aW9uS2V5KV07XG4gICAgfVxuICAgIGlmIChhdHRlbXB0UGFyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT3B0aW9uUmF3VmFsdWUodmFsdWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBhcHBsaWNhdGlvbiBvcHRpb24uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKi9cbiAgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgdGhpc1tjYW1lbENhc2Uoa2V5KV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHN1cHBvcnQgdXJsIGZyb20gdGVuYW50IG9wdGlvbnMuXG4gICAqIElmIHJlc3BvbnNlIHJldHVybnMgJzQwNCBub3QgZm91bmQnIGl0IGdldHMgdGhlIHN1cHBvcnQgdXJsIGZyb20gYXBwbGljYXRpb24gb3B0aW9ucy5cbiAgICogSWYgdGhlIHN1cHBvcnQgbGluayB3aXRoaW4gYXBwbGljYXRpb24gb3B0aW9ucyBpcyBub3QgcHJvdmlkZWQgdGhlIFVJIHdpbGwgdXNlIHRoZSBzeXN0ZW0gb3B0aW9ucy5cbiAgICogSXMgdGhlIHN1cHBvcnQgbGluayBleHBsaWNpdGx5IHNldCB0byBmYWxzZSBpdCB3aWxsIGJlIGhpZGRlbi5cbiAgICpcbiAgICogQHJldHVybnMgUmV0dXJucyBzdXBwb3J0IHVybCBvciBmYWxzZS5cbiAgICovXG4gIGFzeW5jIGdldFN1cHBvcnRVcmwoKSB7XG4gICAgbGV0IHVybDogc3RyaW5nIHwgYm9vbGVhbiA9IGF3YWl0IHRoaXMuZ2V0VGVuYW50T3B0aW9uKCdjb25maWd1cmF0aW9uJywgJ3N5c3RlbS5zdXBwb3J0LnVybCcpO1xuICAgIGlmIChpc1VuZGVmaW5lZCh1cmwpKSB7XG4gICAgICB1cmwgPSB0aGlzLnN1cHBvcnRVcmw7XG4gICAgfVxuICAgIHRoaXMuc3VwcG9ydFVybCA9IGlzVW5kZWZpbmVkKHVybClcbiAgICAgID8gKGF3YWl0IHRoaXMuZ2V0U3lzdGVtT3B0aW9uKCdzdXBwb3J0JywgJ3VybCcpKSB8fCBmYWxzZVxuICAgICAgOiB1cmw7XG4gICAgcmV0dXJuIHRoaXMuc3VwcG9ydFVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSB0ZW5hbnQgYWxsb3dzIHRvIHNob3cgdGhlIGFjdGl2YXRlLXN1cHBvcnQgdXNlciBtZW51IGVudHJ5LlxuICAgKiBOb3RlOiBPbmx5IGlmIHN5c3RlbS1sZXZlbCBzdXBwb3J0LXVzZXIvZW5hYmxlZCBpcyBmYWxzZSB3ZSBjYW4gYWN0aXZhdGUgaXQgYXQgdGVuYW50IGxldmVsLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWN0aXZhdGVTdXBwb3J0VXNlcigpIHtcbiAgICBjb25zdCBvcHRpb24gPSBhd2FpdCB0aGlzLmdldFN5c3RlbU9wdGlvbignc3VwcG9ydC11c2VyJywgJ2VuYWJsZWQnLCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgZnJvbSB0aGUgc3lzdGVtIHNlcnZpY2UgYW5kIHBhcnNlcyBpdC5cbiAgICpcbiAgICogQHBhcmFtIGNhdGVnb3J5IFRoZSBjYXRlZ29yeSBmb3IgdGhpcyBvcHRpb24uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBmb3IgdGhhdCBvcHRpb24uXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgaWYgdGhlIG9wdGlvbiB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgYXN5bmMgZ2V0U3lzdGVtT3B0aW9uPFQgPSBzdHJpbmc+KFxuICAgIGNhdGVnb3J5OiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlPzogVFxuICApOiBQcm9taXNlPFQgfCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25Gcm9tU2VydmljZTxUPihjYXRlZ29yeSwga2V5LCB0aGlzLnN5c3RlbU9wdGlvbnNTZXJ2aWNlLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0ZW5hbnQgc2VydmljZSBhbmQgcGFyc2VzIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgVGhlIGNhdGVnb3J5IGZvciB0aGlzIG9wdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB0aGF0IG9wdGlvbi5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCBpZiB0aGUgb3B0aW9uIHdhcyBub3QgZm91bmQuXG4gICAqL1xuICBhc3luYyBnZXRUZW5hbnRPcHRpb248VCA9IHN0cmluZz4oXG4gICAgY2F0ZWdvcnk6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU/OiBUXG4gICk6IFByb21pc2U8VCB8IHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmdldE9wdGlvbkZyb21TZXJ2aWNlPFQ+KGNhdGVnb3J5LCBrZXksIHRoaXMudGVuYW50T3B0aW9uU2VydmljZSwgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBPcHRpb25zKG9wdGlvbnM6IGFueVtdIHwgbnVsbCkge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZm9yRWFjaChvcHRpb25NYXAgPT4ge1xuICAgICAgICBpZiAob3B0aW9uTWFwKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9uTWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzW2NhbWVsQ2FzZShrZXkpXSA9IG9wdGlvbk1hcFtrZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldE9wdGlvbkZyb21TZXJ2aWNlPFQgPSBzdHJpbmc+KFxuICAgIGNhdGVnb3J5OiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgc2VydmljZTogU3lzdGVtT3B0aW9uc1NlcnZpY2UgfCBUZW5hbnRPcHRpb25zU2VydmljZSxcbiAgICBkZWZhdWx0VmFsdWU6IFRcbiAgKTogUHJvbWlzZTxUIHwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc2VydmljZS5kZXRhaWwoeyBjYXRlZ29yeSwga2V5IH0pO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcHRpb25SYXdWYWx1ZShkYXRhLnZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VPcHRpb25SYXdWYWx1ZTxUID0gc3RyaW5nPihyYXdWYWx1ZTogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IFQpOiBUIHwgc3RyaW5nIHtcbiAgICBsZXQgdmFsdWU6IFQgfCBzdHJpbmc7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gSlNPTi5wYXJzZShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFsdWUgPSBpc1VuZGVmaW5lZChyYXdWYWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiByYXdWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4iXX0=