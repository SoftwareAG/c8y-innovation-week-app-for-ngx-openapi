import { Injectable } from '@angular/core';
import { InventoryBinaryService, SystemOptionsService } from '@c8y/client';
import { every, first, flatten, get, isNaN, isUndefined, keys, map, uniq, min } from 'lodash-es';
import { saveAs } from 'file-saver';
import { BehaviorSubject, Observable, of, throwError } from 'rxjs';
import { catchError, switchMap, startWith, share } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/client";
export var GENERIC_FILE_TYPE;
(function (GENERIC_FILE_TYPE) {
    GENERIC_FILE_TYPE["ARCHIVE"] = "archive";
    GENERIC_FILE_TYPE["AUDIO"] = "audio";
    GENERIC_FILE_TYPE["CODE"] = "code";
    GENERIC_FILE_TYPE["EXCEL"] = "excel";
    GENERIC_FILE_TYPE["IMAGE"] = "image";
    GENERIC_FILE_TYPE["PDF"] = "pdf";
    GENERIC_FILE_TYPE["POWERPOINT"] = "powerpoint";
    GENERIC_FILE_TYPE["TEXT"] = "text";
    GENERIC_FILE_TYPE["VIDEO"] = "video";
    GENERIC_FILE_TYPE["WORD"] = "word";
    GENERIC_FILE_TYPE["EPL"] = "epl";
})(GENERIC_FILE_TYPE || (GENERIC_FILE_TYPE = {}));
export class FilesService {
    constructor(systemOptionsService, inventoryBinaryService) {
        this.systemOptionsService = systemOptionsService;
        this.inventoryBinaryService = inventoryBinaryService;
        this.DEFAULT_BYTES_LIMIT = 52428800;
        this.FILENAME_MAX_LENGTH = 128;
        this.fileTypeExtensionsMap = {
            [GENERIC_FILE_TYPE.ARCHIVE]: {
                exts: ['7z', 'apk', 'cab', 'gz', 'iso', 'jar', 'rar', 'tar', 'zip']
            },
            [GENERIC_FILE_TYPE.AUDIO]: {
                exts: ['3gp', 'aiff', 'aac', 'amr', 'm4a', 'm4p', 'mp3', 'oga', 'ogg', 'raw', 'wav', 'wma']
            },
            [GENERIC_FILE_TYPE.CODE]: {
                exts: ['aspx', 'exe', 'htm', 'html', 'jad', 'js', 'json', 'jsp', 'php', 'xml']
            },
            [GENERIC_FILE_TYPE.EXCEL]: {
                exts: ['xls', 'xlsx']
            },
            [GENERIC_FILE_TYPE.IMAGE]: {
                exts: ['bmp', 'gif', 'jpeg', 'jpg', 'png', 'tiff', 'svg', 'ico', 'apng', 'webp']
            },
            [GENERIC_FILE_TYPE.PDF]: {
                exts: ['pdf']
            },
            [GENERIC_FILE_TYPE.POWERPOINT]: {
                exts: ['ppt', 'pptx']
            },
            [GENERIC_FILE_TYPE.TEXT]: {
                exts: ['txt']
            },
            [GENERIC_FILE_TYPE.VIDEO]: {
                exts: ['asf', 'avi', 'flv', 'mov', 'mp4', 'ogv', 'qt', 'rm', 'rmvb', 'wmv', '3gp']
            },
            [GENERIC_FILE_TYPE.WORD]: {
                exts: ['doc', 'docx']
            },
            [GENERIC_FILE_TYPE.EPL]: {
                exts: ['mon']
            }
        };
        this.fileSizeLimitCfg = {
            systemOption: {
                category: 'files',
                key: 'max.size'
            },
            defaultBytesLimit: this.DEFAULT_BYTES_LIMIT,
            actualBytesLimit: undefined
        };
    }
    /**
     * Checks if files have valid size.
     * @param files Files to check.
     * @returns Returns true if each file has the correct size.
     */
    async haveValidSizes(files, maxFileSizeInBytes) {
        const limit = min([maxFileSizeInBytes, await this.loadBytesSizeLimit()]);
        return every(files, (f) => {
            return this.size(f) <= limit;
        });
    }
    /**
     * Checks the system file size limit, if not available returns the default value.
     * Default limit: [DEFAULT_BYTES_LIMIT]{@link DEFAULT_BYTES_LIMIT}
     * @returns Returns promise with the limit value.
     */
    async loadBytesSizeLimit() {
        let bytesLimit = this.DEFAULT_BYTES_LIMIT;
        if (this.fileSizeLimitCfg.actualBytesLimit) {
            return this.fileSizeLimitCfg.actualBytesLimit;
        }
        const { systemOption } = this.fileSizeLimitCfg;
        try {
            const { data: { value: actualBytesLimit } } = await this.systemOptionsService.detail(systemOption);
            if (!actualBytesLimit) {
                return bytesLimit;
            }
            const parsedActualBytesLimit = parseInt(actualBytesLimit, 10);
            if (isNaN(parsedActualBytesLimit)) {
                return bytesLimit;
            }
            this.fileSizeLimitCfg.actualBytesLimit = parsedActualBytesLimit;
            bytesLimit = parsedActualBytesLimit;
        }
        catch (error) {
            // do nothing
        }
        return bytesLimit;
    }
    /**
     * Checks the size of the file
     * @param file File to check.
     * @returns Returns size of the file in bytes.
     */
    size(file) {
        const fileLength = get(file, 'length') || get(file, 'size');
        const attachments = get(file, '_attachments');
        const attachmentsObj = get(attachments, first(keys(attachments)));
        return isUndefined(fileLength) ? get(attachmentsObj, 'length') : fileLength;
    }
    /**
     * Checks whether files have allowed extensions.
     * If the accept parameter is not specified, all extensions are accepted.
     * @param files Files to check.
     * @param accept String of comma separated file extensions and generic types ([GENERIC_FILE_TYPE]{@link GENERIC_FILE_TYPE}), e.g. .zip,.7z,excel.
     * @returns  Returns true if each file has allowed extension.
     */
    haveValidExtensions(files, accept) {
        if (!accept) {
            return true;
        }
        const filesArray = files.item
            ? Array.from(files)
            : Array.isArray(files)
                ? files
                : [files];
        const filesExts = filesArray.map((file) => this.getFileExtension(file)?.toLowerCase());
        const allowedExts = this.extractFileExtensions(accept);
        return filesExts.every(ext => allowedExts.includes(ext));
    }
    /**
     * Checks if each file has a valid filename length.
     * @param files Files to check.
     * @returns Returns true if each file has a valid filename length.
     */
    checkMaxLength(files) {
        return every(files, (f) => {
            return this.FILENAME_MAX_LENGTH > f.name.length;
        });
    }
    /**
     * Extracts the file extension.
     * @param file File from which the extension should be extracted.
     * @returns Returns the file extension or undefined if the file has no extension.
     */
    getFileExtension(file) {
        const fileNameAndFileExt = file.name.split('.');
        if (fileNameAndFileExt.length === 1) {
            // no file ext
            return undefined;
        }
        return fileNameAndFileExt.pop();
    }
    /**
     * List of file extensions.
     * @returns Returns list of file extensions.
     */
    getFileExtensions() {
        return uniq(flatten(map(this.fileTypeExtensionsMap, ({ exts }) => exts)));
    }
    /**
     * The list of generic file types.
     * @returns Returns the list of generic file types.
     */
    getGenericFileTypes() {
        return Object.keys(this.fileTypeExtensionsMap);
    }
    /**
     * @ignore
     */
    mapGenericFileTypesToExtensions(genericFileTypes = []) {
        const fileExts = genericFileTypes.map(gT => {
            const { exts } = this.fileTypeExtensionsMap[gT];
            return exts;
        });
        return uniq(flatten(fileExts));
    }
    /**
     * Extracts a list of file extensions from a string.
     * Can accept generic file types check: [GENERIC_FILE_TYPE]{@link GENERIC_FILE_TYPE}.
     *
     * @param str String from which the file extensions are extracted (comma separated values).
     * Accepted string format:
     * * ".zip,.iso",
     * * "zip,ISO",
     * * "archive".
     * Important: generic types cannot contain a dot. All values with a dot are treated as a normal extension.
     * @returns Returns a list of the file extensions.
     */
    extractFileExtensions(str) {
        if (!str) {
            return [];
        }
        const types = str.split(',').map(t => t.toLowerCase().trim());
        const genericTypes = types.filter((t) => this.isGenericType(t));
        const defaultFileExts = types.filter((t) => !this.isGenericType(t));
        const allTypes = [
            ...this.mapGenericFileTypesToExtensions(genericTypes),
            ...defaultFileExts
        ].map(t => t.replace('.', ''));
        return uniq(allTypes);
    }
    /**
     * Converts a file to a base64 image string.
     *
     * @param file The file to convert to base 64.
     * @returns The image string in base64 format.
     */
    toBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(String(reader.result));
            reader.onerror = error => reject(error);
        });
    }
    /**
     * Allows to get a File representation of an managed object binary. Can be used
     * to convert this file toBase64 to show it to the end-user.
     * @param binary The binary managed object
     * @returns The file representation.
     */
    async getFile(binary) {
        const res = await this.inventoryBinaryService.download(binary.id);
        const arrayBuffer = await res.arrayBuffer();
        return new File([arrayBuffer], binary.name, { type: binary.contentType });
    }
    /**
     * Allows to calculate the hash sum of the provided file.
     * @param file The file to hash.
     * @returns The SHA-256 hash of the file.
     */
    async getHashSumOfFile(file) {
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(bytes => bytes.toString(16).padStart(2, '0')).join('');
        return hashHex;
    }
    /**
     * Allows to download a file (opens the browser download prompt).
     * @param binary The binary managed object.
     */
    async download(binary) {
        const file = await this.getFile(binary);
        saveAs(file);
    }
    /**
     * Loads the file to JavaScript memory.
     * Returns an observable that emits progression status object,
     * and after download is completed, blob property is populated with Blob result object.
     * Unsubscribing from the returned observable aborts the file fetch request.
     *
     * @param binary The binary managed object.
     */
    fetchFileWithProgress$(binary) {
        const progress = {
            totalBytes: +binary.length,
            bufferedBytes: 0,
            percentage: 0,
            bytesPerSecond: 0
        };
        return of(new AbortController()).pipe(switchMap(async (abortController) => ({
            abortController,
            startTimestamp: new Date().getTime(),
            response: await this.inventoryBinaryService.download(binary.id, {
                signal: abortController.signal
            })
        })), switchMap(({ response, abortController, startTimestamp }) => this.processResponse$(abortController, response, startTimestamp, progress, binary.type)), startWith(progress), share(), catchError(err => throwError(err)));
    }
    uploadFileWithProgress$(file) {
        const uploadStartTimestamp = new Date().getTime();
        const subject = new BehaviorSubject({
            percentage: 0,
            totalBytes: null,
            bufferedBytes: 0,
            bytesPerSecond: 0
        });
        const onProgress = (event) => {
            const eventTimestamp = new Date().getTime();
            const duration = eventTimestamp - uploadStartTimestamp;
            subject.next({
                percentage: Math.round((event.loaded / event.total) * 100),
                totalBytes: event.total,
                bufferedBytes: event.loaded,
                bytesPerSecond: Math.round(event.loaded / Math.round(duration / 1000))
            });
        };
        const xhr = this.inventoryBinaryService.createWithProgress(file, onProgress);
        const uploadPromise = this.inventoryBinaryService.getXMLHttpResponse(xhr);
        uploadPromise.then(() => {
            subject.complete();
        });
        return subject.asObservable();
    }
    processResponse$(abortController, response, startTimestamp, progress, binaryType) {
        return new Observable(sub => {
            const reader = response.body.getReader();
            const chunks = [];
            const readStream = async () => {
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            progress.blob = new Blob(chunks, { type: binaryType });
                            sub.next({ ...progress });
                            sub.complete();
                            break;
                        }
                        chunks.push(value);
                        progress.bufferedBytes += value.length;
                        const currentTimestamp = new Date().getTime();
                        const timestampDiff = currentTimestamp - startTimestamp;
                        progress.bytesPerSecond = Math.round(progress.bufferedBytes / Math.round(timestampDiff / 1000));
                        progress.percentage = Math.round((progress.bufferedBytes / progress.totalBytes) * 100);
                        sub.next({ ...progress });
                    }
                }
                catch (e) {
                    abortController.abort();
                    sub.error(e);
                }
            };
            readStream();
            return {
                unsubscribe() {
                    abortController.abort();
                    sub.complete();
                }
            };
        });
    }
    isGenericType(type) {
        return Object.values(GENERIC_FILE_TYPE).includes(type);
    }
}
FilesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilesService, deps: [{ token: i1.SystemOptionsService }, { token: i1.InventoryBinaryService }], target: i0.ɵɵFactoryTarget.Injectable });
FilesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilesService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.SystemOptionsService }, { type: i1.InventoryBinaryService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvY29tbW9uL2ZpbGVzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBR0wsc0JBQXNCLEVBQ3RCLG9CQUFvQixFQUNyQixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ2pHLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDcEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQVd6RSxNQUFNLENBQU4sSUFBWSxpQkFZWDtBQVpELFdBQVksaUJBQWlCO0lBQzNCLHdDQUFtQixDQUFBO0lBQ25CLG9DQUFlLENBQUE7SUFDZixrQ0FBYSxDQUFBO0lBQ2Isb0NBQWUsQ0FBQTtJQUNmLG9DQUFlLENBQUE7SUFDZixnQ0FBVyxDQUFBO0lBQ1gsOENBQXlCLENBQUE7SUFDekIsa0NBQWEsQ0FBQTtJQUNiLG9DQUFlLENBQUE7SUFDZixrQ0FBYSxDQUFBO0lBQ2IsZ0NBQVcsQ0FBQTtBQUNiLENBQUMsRUFaVyxpQkFBaUIsS0FBakIsaUJBQWlCLFFBWTVCO0FBRUQsTUFBTSxPQUFPLFlBQVk7SUFpRHZCLFlBQ1Usb0JBQTBDLEVBQzFDLHNCQUE4QztRQUQ5Qyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FB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QUFVLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQzt3QkFDdkYsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsUUFBUSxFQUFFLENBQUMsQ0FBQztxQkFDM0I7aUJBQ0Y7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUN4QixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNkO1lBQ0gsQ0FBQyxDQUFDO1lBQ0YsVUFBVSxFQUFFLENBQUM7WUFFYixPQUFPO2dCQUNMLFdBQVc7b0JBQ1QsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUN4QixHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2pCLENBQUM7YUFDRixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sYUFBYSxDQUFDLElBQVk7UUFDaEMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsUUFBUSxDQUFDLElBQXlCLENBQUMsQ0FBQztJQUM5RSxDQUFDOzt5R0F6WFUsWUFBWTs2R0FBWixZQUFZLGNBREMsTUFBTTsyRkFDbkIsWUFBWTtrQkFEeEIsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBJRmV0Y2hSZXNwb25zZSxcbiAgSU1hbmFnZWRPYmplY3RCaW5hcnksXG4gIEludmVudG9yeUJpbmFyeVNlcnZpY2UsXG4gIFN5c3RlbU9wdGlvbnNTZXJ2aWNlXG59IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IGV2ZXJ5LCBmaXJzdCwgZmxhdHRlbiwgZ2V0LCBpc05hTiwgaXNVbmRlZmluZWQsIGtleXMsIG1hcCwgdW5pcSwgbWluIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgc3dpdGNoTWFwLCBzdGFydFdpdGgsIHNoYXJlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSAnc3RyZWFtJztcblxuZXhwb3J0IGludGVyZmFjZSBJRmV0Y2hXaXRoUHJvZ3Jlc3Mge1xuICB0b3RhbEJ5dGVzOiBudW1iZXI7XG4gIGJ1ZmZlcmVkQnl0ZXM6IG51bWJlcjtcbiAgcGVyY2VudGFnZTogbnVtYmVyO1xuICBieXRlc1BlclNlY29uZDogbnVtYmVyO1xuICBibG9iPzogQmxvYjtcbn1cblxuZXhwb3J0IGVudW0gR0VORVJJQ19GSUxFX1RZUEUge1xuICBBUkNISVZFID0gJ2FyY2hpdmUnLFxuICBBVURJTyA9ICdhdWRpbycsXG4gIENPREUgPSAnY29kZScsXG4gIEVYQ0VMID0gJ2V4Y2VsJyxcbiAgSU1BR0UgPSAnaW1hZ2UnLFxuICBQREYgPSAncGRmJyxcbiAgUE9XRVJQT0lOVCA9ICdwb3dlcnBvaW50JyxcbiAgVEVYVCA9ICd0ZXh0JyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBXT1JEID0gJ3dvcmQnLFxuICBFUEwgPSAnZXBsJ1xufVxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBGaWxlc1NlcnZpY2Uge1xuICByZWFkb25seSBERUZBVUxUX0JZVEVTX0xJTUlUID0gNTI0Mjg4MDA7XG4gIHJlYWRvbmx5IEZJTEVOQU1FX01BWF9MRU5HVEggPSAxMjg7XG5cbiAgZmlsZVR5cGVFeHRlbnNpb25zTWFwOiB7IFtrZXk6IHN0cmluZ106IHsgZXh0czogc3RyaW5nW10gfSB9ID0ge1xuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5BUkNISVZFXToge1xuICAgICAgZXh0czogWyc3eicsICdhcGsnLCAnY2FiJywgJ2d6JywgJ2lzbycsICdqYXInLCAncmFyJywgJ3RhcicsICd6aXAnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkFVRElPXToge1xuICAgICAgZXh0czogWyczZ3AnLCAnYWlmZicsICdhYWMnLCAnYW1yJywgJ200YScsICdtNHAnLCAnbXAzJywgJ29nYScsICdvZ2cnLCAncmF3JywgJ3dhdicsICd3bWEnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkNPREVdOiB7XG4gICAgICBleHRzOiBbJ2FzcHgnLCAnZXhlJywgJ2h0bScsICdodG1sJywgJ2phZCcsICdqcycsICdqc29uJywgJ2pzcCcsICdwaHAnLCAneG1sJ11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5FWENFTF06IHtcbiAgICAgIGV4dHM6IFsneGxzJywgJ3hsc3gnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLklNQUdFXToge1xuICAgICAgZXh0czogWydibXAnLCAnZ2lmJywgJ2pwZWcnLCAnanBnJywgJ3BuZycsICd0aWZmJywgJ3N2ZycsICdpY28nLCAnYXBuZycsICd3ZWJwJ11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5QREZdOiB7XG4gICAgICBleHRzOiBbJ3BkZiddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuUE9XRVJQT0lOVF06IHtcbiAgICAgIGV4dHM6IFsncHB0JywgJ3BwdHgnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLlRFWFRdOiB7XG4gICAgICBleHRzOiBbJ3R4dCddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuVklERU9dOiB7XG4gICAgICBleHRzOiBbJ2FzZicsICdhdmknLCAnZmx2JywgJ21vdicsICdtcDQnLCAnb2d2JywgJ3F0JywgJ3JtJywgJ3JtdmInLCAnd212JywgJzNncCddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuV09SRF06IHtcbiAgICAgIGV4dHM6IFsnZG9jJywgJ2RvY3gnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkVQTF06IHtcbiAgICAgIGV4dHM6IFsnbW9uJ11cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBmaWxlU2l6ZUxpbWl0Q2ZnID0ge1xuICAgIHN5c3RlbU9wdGlvbjoge1xuICAgICAgY2F0ZWdvcnk6ICdmaWxlcycsXG4gICAgICBrZXk6ICdtYXguc2l6ZSdcbiAgICB9LFxuICAgIGRlZmF1bHRCeXRlc0xpbWl0OiB0aGlzLkRFRkFVTFRfQllURVNfTElNSVQsXG4gICAgYWN0dWFsQnl0ZXNMaW1pdDogdW5kZWZpbmVkXG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBzeXN0ZW1PcHRpb25zU2VydmljZTogU3lzdGVtT3B0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBpbnZlbnRvcnlCaW5hcnlTZXJ2aWNlOiBJbnZlbnRvcnlCaW5hcnlTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGZpbGVzIGhhdmUgdmFsaWQgc2l6ZS5cbiAgICogQHBhcmFtIGZpbGVzIEZpbGVzIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgZWFjaCBmaWxlIGhhcyB0aGUgY29ycmVjdCBzaXplLlxuICAgKi9cbiAgYXN5bmMgaGF2ZVZhbGlkU2l6ZXMoZmlsZXM6IEZpbGVMaXN0LCBtYXhGaWxlU2l6ZUluQnl0ZXM/OiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBsaW1pdCA9IG1pbihbbWF4RmlsZVNpemVJbkJ5dGVzLCBhd2FpdCB0aGlzLmxvYWRCeXRlc1NpemVMaW1pdCgpXSk7XG4gICAgcmV0dXJuIGV2ZXJ5KGZpbGVzLCAoZjogRmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZShmKSA8PSBsaW1pdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN5c3RlbSBmaWxlIHNpemUgbGltaXQsIGlmIG5vdCBhdmFpbGFibGUgcmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICogRGVmYXVsdCBsaW1pdDogW0RFRkFVTFRfQllURVNfTElNSVRde0BsaW5rIERFRkFVTFRfQllURVNfTElNSVR9XG4gICAqIEByZXR1cm5zIFJldHVybnMgcHJvbWlzZSB3aXRoIHRoZSBsaW1pdCB2YWx1ZS5cbiAgICovXG4gIGFzeW5jIGxvYWRCeXRlc1NpemVMaW1pdCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGxldCBieXRlc0xpbWl0ID0gdGhpcy5ERUZBVUxUX0JZVEVTX0xJTUlUO1xuICAgIGlmICh0aGlzLmZpbGVTaXplTGltaXRDZmcuYWN0dWFsQnl0ZXNMaW1pdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZVNpemVMaW1pdENmZy5hY3R1YWxCeXRlc0xpbWl0O1xuICAgIH1cbiAgICBjb25zdCB7IHN5c3RlbU9wdGlvbiB9ID0gdGhpcy5maWxlU2l6ZUxpbWl0Q2ZnO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YTogeyB2YWx1ZTogYWN0dWFsQnl0ZXNMaW1pdCB9XG4gICAgICB9ID0gYXdhaXQgdGhpcy5zeXN0ZW1PcHRpb25zU2VydmljZS5kZXRhaWwoc3lzdGVtT3B0aW9uKTtcblxuICAgICAgaWYgKCFhY3R1YWxCeXRlc0xpbWl0KSB7XG4gICAgICAgIHJldHVybiBieXRlc0xpbWl0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRBY3R1YWxCeXRlc0xpbWl0ID0gcGFyc2VJbnQoYWN0dWFsQnl0ZXNMaW1pdCwgMTApO1xuICAgICAgaWYgKGlzTmFOKHBhcnNlZEFjdHVhbEJ5dGVzTGltaXQpKSB7XG4gICAgICAgIHJldHVybiBieXRlc0xpbWl0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbGVTaXplTGltaXRDZmcuYWN0dWFsQnl0ZXNMaW1pdCA9IHBhcnNlZEFjdHVhbEJ5dGVzTGltaXQ7XG4gICAgICBieXRlc0xpbWl0ID0gcGFyc2VkQWN0dWFsQnl0ZXNMaW1pdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNMaW1pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHNpemUgb2YgdGhlIGZpbGVcbiAgICogQHBhcmFtIGZpbGUgRmlsZSB0byBjaGVjay5cbiAgICogQHJldHVybnMgUmV0dXJucyBzaXplIG9mIHRoZSBmaWxlIGluIGJ5dGVzLlxuICAgKi9cbiAgc2l6ZShmaWxlOiBGaWxlIHwgSU1hbmFnZWRPYmplY3RCaW5hcnkpOiBudW1iZXIge1xuICAgIGNvbnN0IGZpbGVMZW5ndGggPSBnZXQoZmlsZSwgJ2xlbmd0aCcpIHx8IGdldChmaWxlLCAnc2l6ZScpO1xuICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gZ2V0KGZpbGUsICdfYXR0YWNobWVudHMnKTtcbiAgICBjb25zdCBhdHRhY2htZW50c09iaiA9IGdldChhdHRhY2htZW50cywgZmlyc3Qoa2V5cyhhdHRhY2htZW50cykpKTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoZmlsZUxlbmd0aCkgPyBnZXQoYXR0YWNobWVudHNPYmosICdsZW5ndGgnKSA6IGZpbGVMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgZmlsZXMgaGF2ZSBhbGxvd2VkIGV4dGVuc2lvbnMuXG4gICAqIElmIHRoZSBhY2NlcHQgcGFyYW1ldGVyIGlzIG5vdCBzcGVjaWZpZWQsIGFsbCBleHRlbnNpb25zIGFyZSBhY2NlcHRlZC5cbiAgICogQHBhcmFtIGZpbGVzIEZpbGVzIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0gYWNjZXB0IFN0cmluZyBvZiBjb21tYSBzZXBhcmF0ZWQgZmlsZSBleHRlbnNpb25zIGFuZCBnZW5lcmljIHR5cGVzIChbR0VORVJJQ19GSUxFX1RZUEVde0BsaW5rIEdFTkVSSUNfRklMRV9UWVBFfSksIGUuZy4gLnppcCwuN3osZXhjZWwuXG4gICAqIEByZXR1cm5zICBSZXR1cm5zIHRydWUgaWYgZWFjaCBmaWxlIGhhcyBhbGxvd2VkIGV4dGVuc2lvbi5cbiAgICovXG4gIGhhdmVWYWxpZEV4dGVuc2lvbnMoZmlsZXM6IEZpbGVMaXN0IHwgRmlsZSB8IEZpbGVbXSwgYWNjZXB0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWFjY2VwdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVzQXJyYXkgPSAoZmlsZXMgYXMgRmlsZUxpc3QpLml0ZW1cbiAgICAgID8gQXJyYXkuZnJvbShmaWxlcyBhcyBGaWxlTGlzdClcbiAgICAgIDogQXJyYXkuaXNBcnJheShmaWxlcylcbiAgICAgID8gZmlsZXNcbiAgICAgIDogW2ZpbGVzXTtcblxuICAgIGNvbnN0IGZpbGVzRXh0cyA9IGZpbGVzQXJyYXkubWFwKChmaWxlOiBGaWxlKSA9PiB0aGlzLmdldEZpbGVFeHRlbnNpb24oZmlsZSk/LnRvTG93ZXJDYXNlKCkpO1xuICAgIGNvbnN0IGFsbG93ZWRFeHRzID0gdGhpcy5leHRyYWN0RmlsZUV4dGVuc2lvbnMoYWNjZXB0KTtcbiAgICByZXR1cm4gZmlsZXNFeHRzLmV2ZXJ5KGV4dCA9PiBhbGxvd2VkRXh0cy5pbmNsdWRlcyhleHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgZWFjaCBmaWxlIGhhcyBhIHZhbGlkIGZpbGVuYW1lIGxlbmd0aC5cbiAgICogQHBhcmFtIGZpbGVzIEZpbGVzIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgZWFjaCBmaWxlIGhhcyBhIHZhbGlkIGZpbGVuYW1lIGxlbmd0aC5cbiAgICovXG4gIGNoZWNrTWF4TGVuZ3RoKGZpbGVzOiBGaWxlTGlzdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBldmVyeShmaWxlcywgKGY6IEZpbGUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLkZJTEVOQU1FX01BWF9MRU5HVEggPiBmLm5hbWUubGVuZ3RoO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICogQHBhcmFtIGZpbGUgRmlsZSBmcm9tIHdoaWNoIHRoZSBleHRlbnNpb24gc2hvdWxkIGJlIGV4dHJhY3RlZC5cbiAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZmlsZSBleHRlbnNpb24gb3IgdW5kZWZpbmVkIGlmIHRoZSBmaWxlIGhhcyBubyBleHRlbnNpb24uXG4gICAqL1xuICBnZXRGaWxlRXh0ZW5zaW9uKGZpbGU6IEZpbGUpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGZpbGVOYW1lQW5kRmlsZUV4dCA9IGZpbGUubmFtZS5zcGxpdCgnLicpO1xuICAgIGlmIChmaWxlTmFtZUFuZEZpbGVFeHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBubyBmaWxlIGV4dFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVOYW1lQW5kRmlsZUV4dC5wb3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgUmV0dXJucyBsaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucy5cbiAgICovXG4gIGdldEZpbGVFeHRlbnNpb25zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdW5pcShmbGF0dGVuKG1hcCh0aGlzLmZpbGVUeXBlRXh0ZW5zaW9uc01hcCwgKHsgZXh0cyB9KSA9PiBleHRzKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGdlbmVyaWMgZmlsZSB0eXBlcy5cbiAgICogQHJldHVybnMgUmV0dXJucyB0aGUgbGlzdCBvZiBnZW5lcmljIGZpbGUgdHlwZXMuXG4gICAqL1xuICBnZXRHZW5lcmljRmlsZVR5cGVzKCk6IEdFTkVSSUNfRklMRV9UWVBFW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmZpbGVUeXBlRXh0ZW5zaW9uc01hcCkgYXMgR0VORVJJQ19GSUxFX1RZUEVbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBtYXBHZW5lcmljRmlsZVR5cGVzVG9FeHRlbnNpb25zKGdlbmVyaWNGaWxlVHlwZXM6IEdFTkVSSUNfRklMRV9UWVBFW10gPSBbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBmaWxlRXh0cyA9IGdlbmVyaWNGaWxlVHlwZXMubWFwKGdUID0+IHtcbiAgICAgIGNvbnN0IHsgZXh0cyB9ID0gdGhpcy5maWxlVHlwZUV4dGVuc2lvbnNNYXBbZ1RdO1xuICAgICAgcmV0dXJuIGV4dHM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdW5pcShmbGF0dGVuKGZpbGVFeHRzKSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGEgbGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgZnJvbSBhIHN0cmluZy5cbiAgICogQ2FuIGFjY2VwdCBnZW5lcmljIGZpbGUgdHlwZXMgY2hlY2s6IFtHRU5FUklDX0ZJTEVfVFlQRV17QGxpbmsgR0VORVJJQ19GSUxFX1RZUEV9LlxuICAgKlxuICAgKiBAcGFyYW0gc3RyIFN0cmluZyBmcm9tIHdoaWNoIHRoZSBmaWxlIGV4dGVuc2lvbnMgYXJlIGV4dHJhY3RlZCAoY29tbWEgc2VwYXJhdGVkIHZhbHVlcykuXG4gICAqIEFjY2VwdGVkIHN0cmluZyBmb3JtYXQ6XG4gICAqICogXCIuemlwLC5pc29cIixcbiAgICogKiBcInppcCxJU09cIixcbiAgICogKiBcImFyY2hpdmVcIi5cbiAgICogSW1wb3J0YW50OiBnZW5lcmljIHR5cGVzIGNhbm5vdCBjb250YWluIGEgZG90LiBBbGwgdmFsdWVzIHdpdGggYSBkb3QgYXJlIHRyZWF0ZWQgYXMgYSBub3JtYWwgZXh0ZW5zaW9uLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZmlsZSBleHRlbnNpb25zLlxuICAgKi9cbiAgZXh0cmFjdEZpbGVFeHRlbnNpb25zKHN0cjogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHR5cGVzID0gc3RyLnNwbGl0KCcsJykubWFwKHQgPT4gdC50b0xvd2VyQ2FzZSgpLnRyaW0oKSk7XG5cbiAgICBjb25zdCBnZW5lcmljVHlwZXMgPSB0eXBlcy5maWx0ZXIoKHQ6IHN0cmluZykgPT4gdGhpcy5pc0dlbmVyaWNUeXBlKHQpKTtcbiAgICBjb25zdCBkZWZhdWx0RmlsZUV4dHMgPSB0eXBlcy5maWx0ZXIoKHQ6IHN0cmluZykgPT4gIXRoaXMuaXNHZW5lcmljVHlwZSh0KSk7XG5cbiAgICBjb25zdCBhbGxUeXBlcyA9IFtcbiAgICAgIC4uLnRoaXMubWFwR2VuZXJpY0ZpbGVUeXBlc1RvRXh0ZW5zaW9ucyhnZW5lcmljVHlwZXMgYXMgR0VORVJJQ19GSUxFX1RZUEVbXSksXG4gICAgICAuLi5kZWZhdWx0RmlsZUV4dHNcbiAgICBdLm1hcCh0ID0+IHQucmVwbGFjZSgnLicsICcnKSk7XG5cbiAgICByZXR1cm4gdW5pcShhbGxUeXBlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBmaWxlIHRvIGEgYmFzZTY0IGltYWdlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgdG8gY29udmVydCB0byBiYXNlIDY0LlxuICAgKiBAcmV0dXJucyBUaGUgaW1hZ2Ugc3RyaW5nIGluIGJhc2U2NCBmb3JtYXQuXG4gICAqL1xuICB0b0Jhc2U2NChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoU3RyaW5nKHJlYWRlci5yZXN1bHQpKTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZXJyb3IgPT4gcmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gZ2V0IGEgRmlsZSByZXByZXNlbnRhdGlvbiBvZiBhbiBtYW5hZ2VkIG9iamVjdCBiaW5hcnkuIENhbiBiZSB1c2VkXG4gICAqIHRvIGNvbnZlcnQgdGhpcyBmaWxlIHRvQmFzZTY0IHRvIHNob3cgaXQgdG8gdGhlIGVuZC11c2VyLlxuICAgKiBAcGFyYW0gYmluYXJ5IFRoZSBiaW5hcnkgbWFuYWdlZCBvYmplY3RcbiAgICogQHJldHVybnMgVGhlIGZpbGUgcmVwcmVzZW50YXRpb24uXG4gICAqL1xuICBhc3luYyBnZXRGaWxlKGJpbmFyeTogSU1hbmFnZWRPYmplY3RCaW5hcnkpOiBQcm9taXNlPEZpbGU+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmludmVudG9yeUJpbmFyeVNlcnZpY2UuZG93bmxvYWQoYmluYXJ5LmlkKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgRmlsZShbYXJyYXlCdWZmZXJdLCBiaW5hcnkubmFtZSwgeyB0eXBlOiBiaW5hcnkuY29udGVudFR5cGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRvIGNhbGN1bGF0ZSB0aGUgaGFzaCBzdW0gb2YgdGhlIHByb3ZpZGVkIGZpbGUuXG4gICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIGhhc2guXG4gICAqIEByZXR1cm5zIFRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIGZpbGUuXG4gICAqL1xuICBhc3luYyBnZXRIYXNoU3VtT2ZGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBidWZmZXIpO1xuICAgIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpO1xuICAgIGNvbnN0IGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKGJ5dGVzID0+IGJ5dGVzLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gaGFzaEhleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gZG93bmxvYWQgYSBmaWxlIChvcGVucyB0aGUgYnJvd3NlciBkb3dubG9hZCBwcm9tcHQpLlxuICAgKiBAcGFyYW0gYmluYXJ5IFRoZSBiaW5hcnkgbWFuYWdlZCBvYmplY3QuXG4gICAqL1xuICBhc3luYyBkb3dubG9hZChiaW5hcnk6IElNYW5hZ2VkT2JqZWN0QmluYXJ5KSB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMuZ2V0RmlsZShiaW5hcnkpO1xuICAgIHNhdmVBcyhmaWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgZmlsZSB0byBKYXZhU2NyaXB0IG1lbW9yeS5cbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgcHJvZ3Jlc3Npb24gc3RhdHVzIG9iamVjdCxcbiAgICogYW5kIGFmdGVyIGRvd25sb2FkIGlzIGNvbXBsZXRlZCwgYmxvYiBwcm9wZXJ0eSBpcyBwb3B1bGF0ZWQgd2l0aCBCbG9iIHJlc3VsdCBvYmplY3QuXG4gICAqIFVuc3Vic2NyaWJpbmcgZnJvbSB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSBhYm9ydHMgdGhlIGZpbGUgZmV0Y2ggcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIGJpbmFyeSBUaGUgYmluYXJ5IG1hbmFnZWQgb2JqZWN0LlxuICAgKi9cbiAgZmV0Y2hGaWxlV2l0aFByb2dyZXNzJChiaW5hcnk6IElNYW5hZ2VkT2JqZWN0QmluYXJ5KTogT2JzZXJ2YWJsZTxJRmV0Y2hXaXRoUHJvZ3Jlc3M+IHtcbiAgICBjb25zdCBwcm9ncmVzczogSUZldGNoV2l0aFByb2dyZXNzID0ge1xuICAgICAgdG90YWxCeXRlczogK2JpbmFyeS5sZW5ndGgsXG4gICAgICBidWZmZXJlZEJ5dGVzOiAwLFxuICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgIGJ5dGVzUGVyU2Vjb25kOiAwXG4gICAgfTtcblxuICAgIHJldHVybiBvZihuZXcgQWJvcnRDb250cm9sbGVyKCkpLnBpcGUoXG4gICAgICBzd2l0Y2hNYXAoYXN5bmMgYWJvcnRDb250cm9sbGVyID0+ICh7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICAgc3RhcnRUaW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICByZXNwb25zZTogYXdhaXQgdGhpcy5pbnZlbnRvcnlCaW5hcnlTZXJ2aWNlLmRvd25sb2FkKGJpbmFyeS5pZCwge1xuICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KVxuICAgICAgfSkpLFxuICAgICAgc3dpdGNoTWFwKCh7IHJlc3BvbnNlLCBhYm9ydENvbnRyb2xsZXIsIHN0YXJ0VGltZXN0YW1wIH0pID0+XG4gICAgICAgIHRoaXMucHJvY2Vzc1Jlc3BvbnNlJChhYm9ydENvbnRyb2xsZXIsIHJlc3BvbnNlLCBzdGFydFRpbWVzdGFtcCwgcHJvZ3Jlc3MsIGJpbmFyeS50eXBlKVxuICAgICAgKSxcbiAgICAgIHN0YXJ0V2l0aChwcm9ncmVzcyksXG4gICAgICBzaGFyZSgpLFxuICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhyb3dFcnJvcihlcnIpKVxuICAgICk7XG4gIH1cblxuICB1cGxvYWRGaWxlV2l0aFByb2dyZXNzJChmaWxlOiBTdHJlYW0gfCBCdWZmZXIgfCBGaWxlIHwgQmxvYik6IE9ic2VydmFibGU8SUZldGNoV2l0aFByb2dyZXNzPiB7XG4gICAgY29uc3QgdXBsb2FkU3RhcnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCBzdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxJRmV0Y2hXaXRoUHJvZ3Jlc3M+KHtcbiAgICAgIHBlcmNlbnRhZ2U6IDAsXG4gICAgICB0b3RhbEJ5dGVzOiBudWxsLFxuICAgICAgYnVmZmVyZWRCeXRlczogMCxcbiAgICAgIGJ5dGVzUGVyU2Vjb25kOiAwXG4gICAgfSk7XG4gICAgY29uc3Qgb25Qcm9ncmVzcyA9IChldmVudDogUHJvZ3Jlc3NFdmVudCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gZXZlbnRUaW1lc3RhbXAgLSB1cGxvYWRTdGFydFRpbWVzdGFtcDtcbiAgICAgIHN1YmplY3QubmV4dCh7XG4gICAgICAgIHBlcmNlbnRhZ2U6IE1hdGgucm91bmQoKGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKSAqIDEwMCksXG4gICAgICAgIHRvdGFsQnl0ZXM6IGV2ZW50LnRvdGFsLFxuICAgICAgICBidWZmZXJlZEJ5dGVzOiBldmVudC5sb2FkZWQsXG4gICAgICAgIGJ5dGVzUGVyU2Vjb25kOiBNYXRoLnJvdW5kKGV2ZW50LmxvYWRlZCAvIE1hdGgucm91bmQoZHVyYXRpb24gLyAxMDAwKSlcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCB4aHIgPSB0aGlzLmludmVudG9yeUJpbmFyeVNlcnZpY2UuY3JlYXRlV2l0aFByb2dyZXNzKGZpbGUsIG9uUHJvZ3Jlc3MpO1xuICAgIGNvbnN0IHVwbG9hZFByb21pc2UgPSB0aGlzLmludmVudG9yeUJpbmFyeVNlcnZpY2UuZ2V0WE1MSHR0cFJlc3BvbnNlKHhocik7XG4gICAgdXBsb2FkUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHN1YmplY3QuY29tcGxldGUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzUmVzcG9uc2UkKFxuICAgIGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICAgIHJlc3BvbnNlOiBJRmV0Y2hSZXNwb25zZSxcbiAgICBzdGFydFRpbWVzdGFtcDogbnVtYmVyLFxuICAgIHByb2dyZXNzOiBJRmV0Y2hXaXRoUHJvZ3Jlc3MsXG4gICAgYmluYXJ5VHlwZTogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8SUZldGNoV2l0aFByb2dyZXNzPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YiA9PiB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG5cbiAgICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzLmJsb2IgPSBuZXcgQmxvYihjaHVua3MsIHsgdHlwZTogYmluYXJ5VHlwZSB9KTtcbiAgICAgICAgICAgICAgc3ViLm5leHQoeyAuLi5wcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgc3ViLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIHByb2dyZXNzLmJ1ZmZlcmVkQnl0ZXMgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wRGlmZiA9IGN1cnJlbnRUaW1lc3RhbXAgLSBzdGFydFRpbWVzdGFtcDtcbiAgICAgICAgICAgIHByb2dyZXNzLmJ5dGVzUGVyU2Vjb25kID0gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MuYnVmZmVyZWRCeXRlcyAvIE1hdGgucm91bmQodGltZXN0YW1wRGlmZiAvIDEwMDApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHJvZ3Jlc3MucGVyY2VudGFnZSA9IE1hdGgucm91bmQoKHByb2dyZXNzLmJ1ZmZlcmVkQnl0ZXMgLyBwcm9ncmVzcy50b3RhbEJ5dGVzKSAqIDEwMCk7XG4gICAgICAgICAgICBzdWIubmV4dCh7IC4uLnByb2dyZXNzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgIHN1Yi5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgc3ViLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGlzR2VuZXJpY1R5cGUodHlwZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoR0VORVJJQ19GSUxFX1RZUEUpLmluY2x1ZGVzKHR5cGUgYXMgR0VORVJJQ19GSUxFX1RZUEUpO1xuICB9XG59XG4iXX0=