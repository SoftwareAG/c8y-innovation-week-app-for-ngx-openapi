import { DatePipe as NgDatePipe, DATE_PIPE_DEFAULT_OPTIONS } from '@angular/common';
import { Inject, LOCALE_ID, Pipe, Optional } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { gettext } from '../i18n/gettext';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
/**
 * The range of times supported by ECMAScript Date objects in milliseconds.
 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1
 */
export const ES_MAX_TIME_MILLISECONDS = 8640000000000000;
/**
 * Formats a date value according to locale rules. If no other format specified it defaults to `medium`
 * used as standard date/time format.
 *
 * Extends Angular's DatePipe in a way so that date values exceeding the range supported by ECMAScript
 * are displayed as earliest/latest supported point in time printed in the desired format pre- or postfixed
 * by the word `before` or `after`, respectively.
 * In all other cases the pipe behaves as the standard [DatePipe]{@link https://angular.io/api/common/DatePipe}.
 *
 * ```html
 * <span class="highlight">{{ deadline | c8yDate }}</span> <!-- e.g. 7 May 2020, 17:45:19 (en-GB) or 07.05.2020, 17:45:19 (de) -->
 * <span>{{ lastUpdated | c8yDate: 'a h:MM:ss' }}</span> <!-- e.g. pm 5:45:19 -->
 * <span>{{ 8640000000000000 + 1 | c8yDate }}</span> <!-- e.g. after 13 Sep 275760, 03:00:00 --> ```
 */
export class DatePipe extends NgDatePipe {
    constructor(locale, translateService, defaultTimezone) {
        super(locale, defaultTimezone?.timezone);
        this.translateService = translateService;
    }
    transform(value, format = 'medium', timezone, locale) {
        let valueInBounds = value;
        let valueBefore = false;
        let valueBeyond = false;
        if (typeof value === 'number' && !isNaN(value)) {
            valueInBounds = Math.min(value, ES_MAX_TIME_MILLISECONDS);
            valueInBounds = Math.max(valueInBounds, -ES_MAX_TIME_MILLISECONDS);
            valueBefore = value < -ES_MAX_TIME_MILLISECONDS;
            valueBeyond = value > ES_MAX_TIME_MILLISECONDS;
        }
        let result = super.transform(valueInBounds, format, timezone, locale);
        if (valueBefore) {
            result = this.translateService.instant(gettext(`before {{date}}`), { date: result });
        }
        else if (valueBeyond) {
            result = this.translateService.instant(gettext(`after {{date}}`), { date: result });
        }
        return result;
    }
}
DatePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DatePipe, deps: [{ token: LOCALE_ID }, { token: i1.TranslateService }, { token: DATE_PIPE_DEFAULT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Pipe });
DatePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: DatePipe, name: "c8yDate" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DatePipe, decorators: [{
            type: Pipe,
            args: [{ name: 'c8yDate' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i1.TranslateService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DATE_PIPE_DEFAULT_OPTIONS]
                }, {
                    type: Optional
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vZGF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLElBQUksVUFBVSxFQUFFLHlCQUF5QixFQUFrQixNQUFNLGlCQUFpQixDQUFDO0FBQ3BHLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7QUFFMUM7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sd0JBQXdCLEdBQUcsZ0JBQWdCLENBQUM7QUFFekQ7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUVILE1BQU0sT0FBTyxRQUFTLFNBQVEsVUFBVTtJQUN0QyxZQUNxQixNQUFjLEVBQ3pCLGdCQUFrQyxFQUNLLGVBQWdDO1FBRS9FLEtBQUssQ0FBQyxNQUFNLEVBQUUsZUFBZSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBSGpDLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7SUFJNUMsQ0FBQztJQUVELFNBQVMsQ0FBQyxLQUFVLEVBQUUsTUFBTSxHQUFHLFFBQVEsRUFBRSxRQUFpQixFQUFFLE1BQWU7UUFDekUsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQzFCLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFFeEIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDOUMsYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLHdCQUF3QixDQUFDLENBQUM7WUFDMUQsYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUMsd0JBQXdCLENBQUMsQ0FBQztZQUVuRSxXQUFXLEdBQUcsS0FBSyxHQUFHLENBQUMsd0JBQXdCLENBQUM7WUFDaEQsV0FBVyxHQUFHLEtBQUssR0FBRyx3QkFBd0IsQ0FBQztTQUNoRDtRQUNELElBQUksTUFBTSxHQUFXLEtBQUssQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFOUUsSUFBSSxXQUFXLEVBQUU7WUFDZixNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQ3RGO2FBQU0sSUFBSSxXQUFXLEVBQUU7WUFDdEIsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztTQUNyRjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O3FHQTlCVSxRQUFRLGtCQUVULFNBQVMsNkNBRVQseUJBQXlCO21HQUp4QixRQUFROzJGQUFSLFFBQVE7a0JBRHBCLElBQUk7bUJBQUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFOzswQkFHcEIsTUFBTTsyQkFBQyxTQUFTOzswQkFFaEIsTUFBTTsyQkFBQyx5QkFBeUI7OzBCQUFHLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRlUGlwZSBhcyBOZ0RhdGVQaXBlLCBEQVRFX1BJUEVfREVGQVVMVF9PUFRJT05TLCBEYXRlUGlwZUNvbmZpZyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIExPQ0FMRV9JRCwgUGlwZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IGdldHRleHQgfSBmcm9tICcuLi9pMThuL2dldHRleHQnO1xuXG4vKipcbiAqIFRoZSByYW5nZSBvZiB0aW1lcyBzdXBwb3J0ZWQgYnkgRUNNQVNjcmlwdCBEYXRlIG9iamVjdHMgaW4gbWlsbGlzZWNvbmRzLlxuICogQHNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuOS4xLjFcbiAqL1xuZXhwb3J0IGNvbnN0IEVTX01BWF9USU1FX01JTExJU0VDT05EUyA9IDg2NDAwMDAwMDAwMDAwMDA7XG5cbi8qKlxuICogRm9ybWF0cyBhIGRhdGUgdmFsdWUgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy4gSWYgbm8gb3RoZXIgZm9ybWF0IHNwZWNpZmllZCBpdCBkZWZhdWx0cyB0byBgbWVkaXVtYFxuICogdXNlZCBhcyBzdGFuZGFyZCBkYXRlL3RpbWUgZm9ybWF0LlxuICpcbiAqIEV4dGVuZHMgQW5ndWxhcidzIERhdGVQaXBlIGluIGEgd2F5IHNvIHRoYXQgZGF0ZSB2YWx1ZXMgZXhjZWVkaW5nIHRoZSByYW5nZSBzdXBwb3J0ZWQgYnkgRUNNQVNjcmlwdFxuICogYXJlIGRpc3BsYXllZCBhcyBlYXJsaWVzdC9sYXRlc3Qgc3VwcG9ydGVkIHBvaW50IGluIHRpbWUgcHJpbnRlZCBpbiB0aGUgZGVzaXJlZCBmb3JtYXQgcHJlLSBvciBwb3N0Zml4ZWRcbiAqIGJ5IHRoZSB3b3JkIGBiZWZvcmVgIG9yIGBhZnRlcmAsIHJlc3BlY3RpdmVseS5cbiAqIEluIGFsbCBvdGhlciBjYXNlcyB0aGUgcGlwZSBiZWhhdmVzIGFzIHRoZSBzdGFuZGFyZCBbRGF0ZVBpcGVde0BsaW5rIGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29tbW9uL0RhdGVQaXBlfS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8c3BhbiBjbGFzcz1cImhpZ2hsaWdodFwiPnt7IGRlYWRsaW5lIHwgYzh5RGF0ZSB9fTwvc3Bhbj4gPCEtLSBlLmcuIDcgTWF5IDIwMjAsIDE3OjQ1OjE5IChlbi1HQikgb3IgMDcuMDUuMjAyMCwgMTc6NDU6MTkgKGRlKSAtLT5cbiAqIDxzcGFuPnt7IGxhc3RVcGRhdGVkIHwgYzh5RGF0ZTogJ2EgaDpNTTpzcycgfX08L3NwYW4+IDwhLS0gZS5nLiBwbSA1OjQ1OjE5IC0tPlxuICogPHNwYW4+e3sgODY0MDAwMDAwMDAwMDAwMCArIDEgfCBjOHlEYXRlIH19PC9zcGFuPiA8IS0tIGUuZy4gYWZ0ZXIgMTMgU2VwIDI3NTc2MCwgMDM6MDA6MDAgLS0+IGBgYFxuICovXG5AUGlwZSh7IG5hbWU6ICdjOHlEYXRlJyB9KVxuZXhwb3J0IGNsYXNzIERhdGVQaXBlIGV4dGVuZHMgTmdEYXRlUGlwZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoTE9DQUxFX0lEKSBsb2NhbGU6IHN0cmluZyxcbiAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UsXG4gICAgQEluamVjdChEQVRFX1BJUEVfREVGQVVMVF9PUFRJT05TKSBAT3B0aW9uYWwoKSBkZWZhdWx0VGltZXpvbmU/OiBEYXRlUGlwZUNvbmZpZ1xuICApIHtcbiAgICBzdXBlcihsb2NhbGUsIGRlZmF1bHRUaW1lem9uZT8udGltZXpvbmUpO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGZvcm1hdCA9ICdtZWRpdW0nLCB0aW1lem9uZT86IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogYW55IHtcbiAgICBsZXQgdmFsdWVJbkJvdW5kcyA9IHZhbHVlO1xuICAgIGxldCB2YWx1ZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCB2YWx1ZUJleW9uZCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdmFsdWVJbkJvdW5kcyA9IE1hdGgubWluKHZhbHVlLCBFU19NQVhfVElNRV9NSUxMSVNFQ09ORFMpO1xuICAgICAgdmFsdWVJbkJvdW5kcyA9IE1hdGgubWF4KHZhbHVlSW5Cb3VuZHMsIC1FU19NQVhfVElNRV9NSUxMSVNFQ09ORFMpO1xuXG4gICAgICB2YWx1ZUJlZm9yZSA9IHZhbHVlIDwgLUVTX01BWF9USU1FX01JTExJU0VDT05EUztcbiAgICAgIHZhbHVlQmV5b25kID0gdmFsdWUgPiBFU19NQVhfVElNRV9NSUxMSVNFQ09ORFM7XG4gICAgfVxuICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IHN1cGVyLnRyYW5zZm9ybSh2YWx1ZUluQm91bmRzLCBmb3JtYXQsIHRpbWV6b25lLCBsb2NhbGUpO1xuXG4gICAgaWYgKHZhbHVlQmVmb3JlKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuaW5zdGFudChnZXR0ZXh0KGBiZWZvcmUge3tkYXRlfX1gKSwgeyBkYXRlOiByZXN1bHQgfSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZUJleW9uZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoZ2V0dGV4dChgYWZ0ZXIge3tkYXRlfX1gKSwgeyBkYXRlOiByZXN1bHQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIl19