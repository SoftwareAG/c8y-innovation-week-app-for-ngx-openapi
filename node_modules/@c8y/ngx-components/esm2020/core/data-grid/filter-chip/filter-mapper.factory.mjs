import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { castArray } from 'lodash-es';
import { hookGeneric } from '../../common/extension-hooks';
import * as i0 from "@angular/core";
const HOOK_FILTER_MAPPER = new InjectionToken('HOOK_FILTER_MAPPER');
/**
 * You can either provide a single `FilterMapper` as parameter:
 * ```typescript
 *  hookFilterMapper(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookFilterMapper([...])
 * ```
 *
 * Or you provide an Service that implements `FilterMapper`
 * ```typescript
 *  export class MyFilterMapper implements FilterMapper {...}
 *  ...
 *  hookFilterMapper(MyFilterMapper)
 * ```
 * A typed alternative to using `HOOK_FILTER_MAPPER`.
 * @param mapper A filter mapper, e.g. `BooleanFilterMapper`, or `ExtensionFactory` to be provided.
 * @param options If this is a multi provider or not (defaults to true) and provider type definition (defaults to ClassProvider) - `HookOptions`.
 * @returns An `Provider` to be provided in your module.
 */
export function hookFilterMapper(mapper, options) {
    return hookGeneric(mapper, HOOK_FILTER_MAPPER, options);
}
export class FilterMapperFactory {
    constructor(fieldMappers) {
        this.map = {};
        fieldMappers.forEach(fieldMapper => {
            castArray(fieldMapper.fieldType).forEach(type => {
                this.map[type] = fieldMapper;
            });
        });
    }
    get(type) {
        if (type === undefined || type === null) {
            throw new Error('Invalid input: type is undefined or null');
        }
        if (typeof type !== 'string' && typeof type !== 'function') {
            throw new Error(`Invalid input: type must be a string or a Type<FieldType>, but received ${typeof type}`);
        }
        const typeName = typeof type === 'string' ? type : type.name;
        const mapper = this.map[typeName];
        if (!mapper) {
            throw new Error(`Could not find FilterMapper for type ${typeName}`);
        }
        return mapper;
    }
}
FilterMapperFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilterMapperFactory, deps: [{ token: HOOK_FILTER_MAPPER, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
FilterMapperFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilterMapperFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilterMapperFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: Array, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [HOOK_FILTER_MAPPER]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLW1hcHBlci5mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vY29yZS9kYXRhLWdyaWQvZmlsdGVyLWNoaXAvZmlsdGVyLW1hcHBlci5mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFFbkYsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUN0QyxPQUFPLEVBRUwsV0FBVyxFQUdaLE1BQU0sOEJBQThCLENBQUM7O0FBR3RDLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxjQUFjLENBQXdCLG9CQUFvQixDQUFDLENBQUM7QUF5QjNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkc7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLE1BQW1DLEVBQ25DLE9BQThCO0lBRTlCLE9BQU8sV0FBVyxDQUFlLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN4RSxDQUFDO0FBRUQsTUFBTSxPQUFPLG1CQUFtQjtJQUU5QixZQUdFLFlBQWlDO1FBRWpDLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBRWQsWUFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUNqQyxTQUFTLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDOUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxXQUFXLENBQUM7WUFDL0IsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxHQUFHLENBQUMsSUFBOEI7UUFDaEMsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO1NBQzdEO1FBQ0QsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLElBQUksT0FBTyxJQUFJLEtBQUssVUFBVSxFQUFFO1lBQzFELE1BQU0sSUFBSSxLQUFLLENBQ2IsMkVBQTJFLE9BQU8sSUFBSSxFQUFFLENBQ3pGLENBQUM7U0FDSDtRQUNELE1BQU0sUUFBUSxHQUFHLE9BQU8sSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQzdELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDckU7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztnSEEvQlUsbUJBQW1CLGtCQUlwQixrQkFBa0I7b0hBSmpCLG1CQUFtQixjQUROLE1BQU07MkZBQ25CLG1CQUFtQjtrQkFEL0IsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OzBCQUk3QixRQUFROzswQkFDUixNQUFNOzJCQUFDLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIE9wdGlvbmFsLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWVsZFR5cGUgfSBmcm9tICdAbmd4LWZvcm1seS9jb3JlJztcbmltcG9ydCB7IGNhc3RBcnJheSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQge1xuICBFeHRlbnNpb25GYWN0b3J5LFxuICBob29rR2VuZXJpYyxcbiAgSG9va09wdGlvbnMsXG4gIEhvb2tWYWx1ZVR5cGVcbn0gZnJvbSAnLi4vLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBGaWx0ZXJNYXBwZXIgfSBmcm9tICcuLi9kYXRhLWdyaWQubW9kZWwnO1xuXG5jb25zdCBIT09LX0ZJTFRFUl9NQVBQRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW48RmlsdGVyTWFwcGVyRXh0ZW5zaW9uPignSE9PS19GSUxURVJfTUFQUEVSJyk7XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIEhPT0sgY2FuIHVzZSBlaXRoZXIgYSBwdXJlIHZhbHVlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VWYWx1ZTogeyAuLi5ob29rVmFsdWUgfSwgbXVsdGk6IHRydWUgfVxuICogYGBgXG4gKlxuICogT3IgYW4gYXJyYXkgdG8gZGlyZWN0bHkgcmVnaXN0ZXIgbXVsdGlwbGU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiBbeyAuLi5ob29rVmFsdWVzIH1dLCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiAgKiBPciBhIGNsYXNzIHRvIHJlZ2lzdGVyOlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VFeGlzdGluZzogQm9vbGVhbkZpbHRlck1hcHBlciwgbXVsdGk6IHRydWUgfVxuICogYGBgXG4gKlxuICogT3IgYW4gRXh0ZW5zaW9uRmFjdG9yeSB7QGxpbmsgRXh0ZW5zaW9uRmFjdG9yeX06XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZUZhY3Rvcnk6IChyb3V0ZSkgPT4gZG9Tb21ldGhpbmdBc3luYyhyb3V0ZSksIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBGaWx0ZXJNYXBwZXJFeHRlbnNpb24gPSBGaWx0ZXJNYXBwZXIgfCBGaWx0ZXJNYXBwZXJbXSB8IEV4dGVuc2lvbkZhY3Rvcnk8RmlsdGVyTWFwcGVyPjtcblxuLyoqXG4gKiBZb3UgY2FuIGVpdGhlciBwcm92aWRlIGEgc2luZ2xlIGBGaWx0ZXJNYXBwZXJgIGFzIHBhcmFtZXRlcjpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBob29rRmlsdGVyTWFwcGVyKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tGaWx0ZXJNYXBwZXIoWy4uLl0pXG4gKiBgYGBcbiAqXG4gKiBPciB5b3UgcHJvdmlkZSBhbiBTZXJ2aWNlIHRoYXQgaW1wbGVtZW50cyBgRmlsdGVyTWFwcGVyYFxuICogYGBgdHlwZXNjcmlwdFxuICogIGV4cG9ydCBjbGFzcyBNeUZpbHRlck1hcHBlciBpbXBsZW1lbnRzIEZpbHRlck1hcHBlciB7Li4ufVxuICogIC4uLlxuICogIGhvb2tGaWx0ZXJNYXBwZXIoTXlGaWx0ZXJNYXBwZXIpXG4gKiBgYGBcbiAqIEEgdHlwZWQgYWx0ZXJuYXRpdmUgdG8gdXNpbmcgYEhPT0tfRklMVEVSX01BUFBFUmAuXG4gKiBAcGFyYW0gbWFwcGVyIEEgZmlsdGVyIG1hcHBlciwgZS5nLiBgQm9vbGVhbkZpbHRlck1hcHBlcmAsIG9yIGBFeHRlbnNpb25GYWN0b3J5YCB0byBiZSBwcm92aWRlZC5cbiAqIEBwYXJhbSBvcHRpb25zIElmIHRoaXMgaXMgYSBtdWx0aSBwcm92aWRlciBvciBub3QgKGRlZmF1bHRzIHRvIHRydWUpIGFuZCBwcm92aWRlciB0eXBlIGRlZmluaXRpb24gKGRlZmF1bHRzIHRvIENsYXNzUHJvdmlkZXIpIC0gYEhvb2tPcHRpb25zYC5cbiAqIEByZXR1cm5zIEFuIGBQcm92aWRlcmAgdG8gYmUgcHJvdmlkZWQgaW4geW91ciBtb2R1bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBob29rRmlsdGVyTWFwcGVyKFxuICBtYXBwZXI6IEhvb2tWYWx1ZVR5cGU8RmlsdGVyTWFwcGVyPixcbiAgb3B0aW9ucz86IFBhcnRpYWw8SG9va09wdGlvbnM+XG4pIHtcbiAgcmV0dXJuIGhvb2tHZW5lcmljPEZpbHRlck1hcHBlcj4obWFwcGVyLCBIT09LX0ZJTFRFUl9NQVBQRVIsIG9wdGlvbnMpO1xufVxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBGaWx0ZXJNYXBwZXJGYWN0b3J5IHtcbiAgbWFwOiBvYmplY3Q7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChIT09LX0ZJTFRFUl9NQVBQRVIpXG4gICAgZmllbGRNYXBwZXJzOiBBcnJheTxGaWx0ZXJNYXBwZXI+XG4gICkge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBmaWVsZE1hcHBlcnMuZm9yRWFjaChmaWVsZE1hcHBlciA9PiB7XG4gICAgICBjYXN0QXJyYXkoZmllbGRNYXBwZXIuZmllbGRUeXBlKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICB0aGlzLm1hcFt0eXBlXSA9IGZpZWxkTWFwcGVyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQodHlwZTogc3RyaW5nIHwgVHlwZTxGaWVsZFR5cGU+KTogRmlsdGVyTWFwcGVyIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dDogdHlwZSBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGlucHV0OiB0eXBlIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBUeXBlPEZpZWxkVHlwZT4sIGJ1dCByZWNlaXZlZCAke3R5cGVvZiB0eXBlfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA6IHR5cGUubmFtZTtcbiAgICBjb25zdCBtYXBwZXIgPSB0aGlzLm1hcFt0eXBlTmFtZV07XG4gICAgaWYgKCFtYXBwZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgRmlsdGVyTWFwcGVyIGZvciB0eXBlICR7dHlwZU5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwZXI7XG4gIH1cbn1cbiJdfQ==