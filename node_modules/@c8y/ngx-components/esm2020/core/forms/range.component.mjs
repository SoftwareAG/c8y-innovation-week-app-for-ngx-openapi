import { Component, ContentChild, forwardRef, TemplateRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { toNumber } from 'lodash-es';
import { RangeDirective } from './range.directive';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/**
 * An component which renders a range slider in Cumulocity layout. You need
 * to wrap the default range input in this component.
 *
 * Example:
 * ```
 * <c8y-range>
 *   <input id="range" type="range" min="0" max="100000" value="0" step="1">
 * </c8y-range>
 * ```
 */
export class RangeComponent {
    /**
     * @ignore
     * @param obj The value to update
     */
    writeValue(obj) {
        this.range.elementRef.nativeElement.value = obj;
        this.updateValue();
    }
    /**
     * @ignore
     * @param fn The function to register for changes
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @ignore
     * @param fn The function to register for changes
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        this.updateValue();
        this.range.elementRef.nativeElement.addEventListener('input', () => this.updateValue());
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        this.range.elementRef.nativeElement.removeEventListener('input', () => this.updateValue());
    }
    /**
     * @ignore
     */
    updateValue() {
        const rangeValue = this.range.elementRef.nativeElement.value;
        this.value = toNumber(rangeValue);
        if (this.onChange) {
            this.onChange(this.value);
        }
        this.updatePosition();
    }
    /**
     * Updates the position of the slider
     */
    updatePosition() {
        const range = this.range.elementRef.nativeElement;
        const newValue = Number(((range.value - range.min) * 100) / (range.max - range.min));
        const newPosition = 12 - newValue * 0.24;
        this.left = `calc(${newValue}% + (${newPosition}px))`;
    }
}
RangeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: RangeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RangeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: RangeComponent, selector: "c8y-range", providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => RangeComponent),
            multi: true
        }
    ], queries: [{ propertyName: "range", first: true, predicate: RangeDirective, descendants: true, static: true }, { propertyName: "rangeValue", first: true, predicate: ["c8yRangeValue"], descendants: true, static: true }], ngImport: i0, template: "<div class=\"range-wrap\" style=\"--track-width: {{left}}\">\n  <div class=\"range-value\" [style.left]=\"left\">\n    <span *ngIf=\"!rangeValue\">{{ value }}</span>\n    <ng-container *ngTemplateOutlet=\"rangeValue\"></ng-container>\n  </div>\n  <ng-content></ng-content>\n</div>\n", dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: RangeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-range', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => RangeComponent),
                            multi: true
                        }
                    ], template: "<div class=\"range-wrap\" style=\"--track-width: {{left}}\">\n  <div class=\"range-value\" [style.left]=\"left\">\n    <span *ngIf=\"!rangeValue\">{{ value }}</span>\n    <ng-container *ngTemplateOutlet=\"rangeValue\"></ng-container>\n  </div>\n  <ng-content></ng-content>\n</div>\n" }]
        }], propDecorators: { range: [{
                type: ContentChild,
                args: [RangeDirective, { static: true }]
            }], rangeValue: [{
                type: ContentChild,
                args: ['c8yRangeValue', { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9mb3Jtcy9yYW5nZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9jb3JlL2Zvcm1zL3JhbmdlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBYSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUYsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDckMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7QUFFbkQ7Ozs7Ozs7Ozs7R0FVRztBQVlILE1BQU0sT0FBTyxjQUFjO0lBNEJ6Qjs7O09BR0c7SUFDSCxVQUFVLENBQUMsR0FBZTtRQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUNoRCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7T0FHRztJQUNILGdCQUFnQixDQUFDLEVBQWM7UUFDN0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7T0FHRztJQUNILGlCQUFpQixDQUFDLEVBQWM7UUFDOUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQzFGLENBQUM7SUFFRDs7T0FFRztJQUNILFdBQVc7UUFDVCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQzdGLENBQUM7SUFFRDs7T0FFRztJQUNILFdBQVc7UUFDVCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDO1FBQzdELElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQjtRQUNELElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxjQUFjO1FBQ1osTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO1FBQ2xELE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3JGLE1BQU0sV0FBVyxHQUFHLEVBQUUsR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUSxRQUFRLFFBQVEsV0FBVyxNQUFNLENBQUM7SUFDeEQsQ0FBQzs7MkdBeEZVLGNBQWM7K0ZBQWQsY0FBYyxvQ0FSZDtRQUNUO1lBQ0UsT0FBTyxFQUFFLGlCQUFpQjtZQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLGNBQWMsQ0FBQztZQUM3QyxLQUFLLEVBQUUsSUFBSTtTQUNaO0tBQ0YsNkRBTWEsY0FBYywwS0MvQjlCLDRSQU9BOzJGRG9CYSxjQUFjO2tCQVgxQixTQUFTOytCQUNFLFdBQVcsYUFFVjt3QkFDVDs0QkFDRSxPQUFPLEVBQUUsaUJBQWlCOzRCQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxlQUFlLENBQUM7NEJBQzdDLEtBQUssRUFBRSxJQUFJO3lCQUNaO3FCQUNGOzhCQU9ELEtBQUs7c0JBREosWUFBWTt1QkFBQyxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQU05QyxVQUFVO3NCQURULFlBQVk7dUJBQUMsZUFBZSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBmb3J3YXJkUmVmLCBPbkRlc3Ryb3ksIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyB0b051bWJlciB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBSYW5nZURpcmVjdGl2ZSB9IGZyb20gJy4vcmFuZ2UuZGlyZWN0aXZlJztcblxuLyoqXG4gKiBBbiBjb21wb25lbnQgd2hpY2ggcmVuZGVycyBhIHJhbmdlIHNsaWRlciBpbiBDdW11bG9jaXR5IGxheW91dC4gWW91IG5lZWRcbiAqIHRvIHdyYXAgdGhlIGRlZmF1bHQgcmFuZ2UgaW5wdXQgaW4gdGhpcyBjb21wb25lbnQuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogPGM4eS1yYW5nZT5cbiAqICAgPGlucHV0IGlkPVwicmFuZ2VcIiB0eXBlPVwicmFuZ2VcIiBtaW49XCIwXCIgbWF4PVwiMTAwMDAwXCIgdmFsdWU9XCIwXCIgc3RlcD1cIjFcIj5cbiAqIDwvYzh5LXJhbmdlPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1yYW5nZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9yYW5nZS5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFuZ2VDb21wb25lbnQpLFxuICAgICAgbXVsdGk6IHRydWVcbiAgICB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgUmFuZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgLyoqXG4gICAqIFRoZSByYW5nZSBpbnB1dFxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChSYW5nZURpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSlcbiAgcmFuZ2U6IFJhbmdlRGlyZWN0aXZlO1xuICAvKipcbiAgICogVGhlIHJhbmdlIHZhbHVlIHNsaWRlclxuICAgKi9cbiAgQENvbnRlbnRDaGlsZCgnYzh5UmFuZ2VWYWx1ZScsIHsgc3RhdGljOiB0cnVlIH0pXG4gIHJhbmdlVmFsdWU6IFRlbXBsYXRlUmVmPHVua25vd24+O1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqL1xuICB2YWx1ZTogbnVtYmVyO1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgZnJvbSBsZWZ0XG4gICAqL1xuICBsZWZ0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNoYW5nZTogKHZhbHVlOiBudW1iZXIpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvblRvdWNoZWQ6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogQHBhcmFtIG9iaiBUaGUgdmFsdWUgdG8gdXBkYXRlXG4gICAqL1xuICB3cml0ZVZhbHVlKG9iajogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMucmFuZ2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gb2JqO1xuICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgZm9yIGNoYW5nZXNcbiAgICovXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0gZm4gVGhlIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGZvciBjaGFuZ2VzXG4gICAqL1xuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgICB0aGlzLnJhbmdlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHRoaXMudXBkYXRlVmFsdWUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yYW5nZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB0aGlzLnVwZGF0ZVZhbHVlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHVwZGF0ZVZhbHVlKCkge1xuICAgIGNvbnN0IHJhbmdlVmFsdWUgPSB0aGlzLnJhbmdlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZTtcbiAgICB0aGlzLnZhbHVlID0gdG9OdW1iZXIocmFuZ2VWYWx1ZSk7XG4gICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgIHRoaXMub25DaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2xpZGVyXG4gICAqL1xuICB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMucmFuZ2UuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gTnVtYmVyKCgocmFuZ2UudmFsdWUgLSByYW5nZS5taW4pICogMTAwKSAvIChyYW5nZS5tYXggLSByYW5nZS5taW4pKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IDEyIC0gbmV3VmFsdWUgKiAwLjI0O1xuICAgIHRoaXMubGVmdCA9IGBjYWxjKCR7bmV3VmFsdWV9JSArICgke25ld1Bvc2l0aW9ufXB4KSlgO1xuICB9XG59XG4iLCI8ZGl2IGNsYXNzPVwicmFuZ2Utd3JhcFwiIHN0eWxlPVwiLS10cmFjay13aWR0aDoge3tsZWZ0fX1cIj5cbiAgPGRpdiBjbGFzcz1cInJhbmdlLXZhbHVlXCIgW3N0eWxlLmxlZnRdPVwibGVmdFwiPlxuICAgIDxzcGFuICpuZ0lmPVwiIXJhbmdlVmFsdWVcIj57eyB2YWx1ZSB9fTwvc3Bhbj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicmFuZ2VWYWx1ZVwiPjwvbmctY29udGFpbmVyPlxuICA8L2Rpdj5cbiAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+XG4iXX0=