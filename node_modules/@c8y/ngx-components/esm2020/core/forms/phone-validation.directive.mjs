import { NG_VALIDATORS } from '@angular/forms';
import { Directive } from '@angular/core';
import { parsePhoneNumberFromString } from 'libphonenumber-js/max';
import * as i0 from "@angular/core";
export class PhoneValidationDirective {
    constructor() {
        this.allowedCharactersPattern = /^[/\d\-+ ]*$/;
    }
    validate(control) {
        const valid = this.validateInternationalPhoneNumber(control);
        return valid ? null : { internationalPhoneNumber: true };
    }
    validateInternationalPhoneNumber(control) {
        let numberValid;
        try {
            const phoneNumber = parsePhoneNumberFromString(control.value);
            numberValid = this.allowedCharactersPattern.test(control.value) && phoneNumber.isValid();
            if (numberValid && control.value !== phoneNumber.format('E.164')) {
                control.setValue(phoneNumber.format('E.164'), {
                    emitEvent: false,
                    emitModelToViewChange: false
                });
            }
        }
        catch (e) {
            numberValid = !control.value;
        }
        return numberValid;
    }
}
PhoneValidationDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: PhoneValidationDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
PhoneValidationDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.7", type: PhoneValidationDirective, selector: "[c8yPhoneValidation]", providers: [{ provide: NG_VALIDATORS, useExisting: PhoneValidationDirective, multi: true }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: PhoneValidationDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[c8yPhoneValidation]',
                    providers: [{ provide: NG_VALIDATORS, useExisting: PhoneValidationDirective, multi: true }]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGhvbmUtdmFsaWRhdGlvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2Zvcm1zL3Bob25lLXZhbGlkYXRpb24uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxhQUFhLEVBQThCLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0UsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMxQyxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7QUFNbkUsTUFBTSxPQUFPLHdCQUF3QjtJQUpyQztRQUtFLDZCQUF3QixHQUFHLGNBQWMsQ0FBQztLQXVCM0M7SUFyQkMsUUFBUSxDQUFDLE9BQXdCO1FBQy9CLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3RCxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLHdCQUF3QixFQUFFLElBQUksRUFBRSxDQUFDO0lBQzNELENBQUM7SUFFTyxnQ0FBZ0MsQ0FBQyxPQUF3QjtRQUMvRCxJQUFJLFdBQVcsQ0FBQztRQUNoQixJQUFJO1lBQ0YsTUFBTSxXQUFXLEdBQUcsMEJBQTBCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlELFdBQVcsR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDekYsSUFBSSxXQUFXLElBQUksT0FBTyxDQUFDLEtBQUssS0FBSyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNoRSxPQUFPLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQzVDLFNBQVMsRUFBRSxLQUFLO29CQUNoQixxQkFBcUIsRUFBRSxLQUFLO2lCQUM3QixDQUFDLENBQUM7YUFDSjtTQUNGO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixXQUFXLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO1NBQzlCO1FBQ0QsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQzs7cUhBdkJVLHdCQUF3Qjt5R0FBeEIsd0JBQXdCLCtDQUZ4QixDQUFDLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsd0JBQXdCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDOzJGQUVoRix3QkFBd0I7a0JBSnBDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLHNCQUFzQjtvQkFDaEMsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsMEJBQTBCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDO2lCQUM1RiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdG9yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBwYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZyB9IGZyb20gJ2xpYnBob25lbnVtYmVyLWpzL21heCc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjOHlQaG9uZVZhbGlkYXRpb25dJyxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogUGhvbmVWYWxpZGF0aW9uRGlyZWN0aXZlLCBtdWx0aTogdHJ1ZSB9XVxufSlcbmV4cG9ydCBjbGFzcyBQaG9uZVZhbGlkYXRpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuICBhbGxvd2VkQ2hhcmFjdGVyc1BhdHRlcm4gPSAvXlsvXFxkXFwtKyBdKiQvO1xuXG4gIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IHsgW2tleTogc3RyaW5nXTogYW55IH0gfCBudWxsIHtcbiAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGVJbnRlcm5hdGlvbmFsUGhvbmVOdW1iZXIoY29udHJvbCk7XG4gICAgcmV0dXJuIHZhbGlkID8gbnVsbCA6IHsgaW50ZXJuYXRpb25hbFBob25lTnVtYmVyOiB0cnVlIH07XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlSW50ZXJuYXRpb25hbFBob25lTnVtYmVyKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCkge1xuICAgIGxldCBudW1iZXJWYWxpZDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSBwYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZyhjb250cm9sLnZhbHVlKTtcbiAgICAgIG51bWJlclZhbGlkID0gdGhpcy5hbGxvd2VkQ2hhcmFjdGVyc1BhdHRlcm4udGVzdChjb250cm9sLnZhbHVlKSAmJiBwaG9uZU51bWJlci5pc1ZhbGlkKCk7XG4gICAgICBpZiAobnVtYmVyVmFsaWQgJiYgY29udHJvbC52YWx1ZSAhPT0gcGhvbmVOdW1iZXIuZm9ybWF0KCdFLjE2NCcpKSB7XG4gICAgICAgIGNvbnRyb2wuc2V0VmFsdWUocGhvbmVOdW1iZXIuZm9ybWF0KCdFLjE2NCcpLCB7XG4gICAgICAgICAgZW1pdEV2ZW50OiBmYWxzZSxcbiAgICAgICAgICBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG51bWJlclZhbGlkID0gIWNvbnRyb2wudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudW1iZXJWYWxpZDtcbiAgfVxufVxuIl19