import { FormControl } from '@angular/forms';
import { forkJoin, of } from 'rxjs';
import { map } from 'rxjs/operators';
export const ARRAY_VALIDATION_PREFIX = 'INNER_ARRAY_ERROR_';
/**
 * This method can alter how validators work. It can be used in cases where there is need to validate FormControl
 * that as value, takes array of elements. This allows to reuse validators, that works for such elements.
 * For example if  Validators.minLength(3) is used on control that takes string as value, validator will return error
 * if string is less than 3 characters. If same is done on array of strings, validator will return error if array
 * has less than 3 elements.
 *
 * validateArrayElements(Validators.minLength(3)) method makes it possible to check every member of array if it has minimum 3 characters.
 * If there are elements that raise error, it will be possible to extract these errors using item index.
 *
 * As a example, this can be used for custom form elements, which manipulates array of elements,
 * and there is need to display corresponding error messages for every array member that is displayed, while still using
 * Angular's Validation approach.
 *
 * Errors that are generated by this helper are prefixed with 'INNER_ARRAY_ERROR_'. Reason for this is to prevent overwriting normal validation
 * errors that could have same key
 *
 * @Example
 *
 * let control = new FormControl(['1234', '123456', '123', [Validators.minLength(5), validateArrayElements(Validators.minLength(5))] ])
 *
 * this FormControl has validation errors:
 *
 * {
 *   "INNER_ARRAY_ERROR_minlength": {
 *      isArrayError: true, originalKey: minlength, entries: [
 *        {index: 0, errorData: {requiredLength: 5, actualLength: 4}},
 *        {index: 2, errorData: {requiredLength: 5, actualLength: 3}},
 *      ]
 *    },
 *    "minlength"; {requiredLength: 5, actualLength: 3}
 * }
 *
 * @param {ValidatorFn} validator
 */
export function validateArrayElements(validator) {
    return (control) => {
        const values = control.value;
        if (!Array.isArray(values)) {
            return { valueNotArray: true };
        }
        const validationErrors = values.map(value => validator(new FormControl(value)));
        const convertedErrors = generateArrayRelatedErrors(validationErrors);
        return convertedErrors;
    };
}
/**
 * Async version of validateArrayElements.
 *
 * Note that Angular by design doesn't execute async validators if synchronous validators returns any error.
 * @param {AsyncValidatorFn} validator
 */
export function asyncValidateArrayElements(validator) {
    return (control) => {
        const values = control.value;
        if (!Array.isArray(values)) {
            return of({ valueNotArray: true });
        }
        const observables = values.map(value => validator(new FormControl(value)));
        return forkJoin(observables).pipe(map(errors => generateArrayRelatedErrors(errors)));
    };
}
function generateArrayRelatedErrors(errors) {
    const errorObject = {};
    errors.forEach((error, index) => {
        if (!error) {
            return;
        }
        const errorKeys = Object.keys(error);
        if (errorKeys.length) {
            errorKeys.forEach(key => {
                const prefixedKey = ARRAY_VALIDATION_PREFIX + key;
                if (!errorObject[prefixedKey]) {
                    errorObject[prefixedKey] = { isArrayError: true, originalKey: key, entries: [] };
                }
                errorObject[prefixedKey].entries.push({ index, errorData: error[key] });
            });
        }
    });
    return Object.keys(errorObject).length ? errorObject : null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUtYXJyYXktZWxlbWVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2Zvcm1zL3ZhbGlkYXRlLWFycmF5LWVsZW1lbnRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFHTCxXQUFXLEVBR1osTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsUUFBUSxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNoRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckMsTUFBTSxDQUFDLE1BQU0sdUJBQXVCLEdBQUcsb0JBQW9CLENBQUM7QUFZNUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQ0c7QUFDSCxNQUFNLFVBQVUscUJBQXFCLENBQUMsU0FBc0I7SUFDMUQsT0FBTyxDQUFDLE9BQXdCLEVBQTZDLEVBQUU7UUFDN0UsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztRQUM3QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUMxQixPQUFPLEVBQUUsYUFBYSxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ2hDO1FBQ0QsTUFBTSxnQkFBZ0IsR0FBdUIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUM5RCxTQUFTLENBQUMsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FDbEMsQ0FBQztRQUNGLE1BQU0sZUFBZSxHQUEwQiwwQkFBMEIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzVGLE9BQU8sZUFBZSxDQUFDO0lBQ3pCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSwwQkFBMEIsQ0FBQyxTQUEyQjtJQUNwRSxPQUFPLENBQUMsT0FBd0IsRUFBZ0MsRUFBRTtRQUNoRSxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzFCLE9BQU8sRUFBRSxDQUFDLEVBQUUsYUFBYSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7U0FDcEM7UUFDRCxNQUFNLFdBQVcsR0FFYixNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUzRCxPQUFPLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZGLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLDBCQUEwQixDQUFDLE1BQXNDO0lBQ3hFLE1BQU0sV0FBVyxHQUEwQixFQUFFLENBQUM7SUFFOUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUM5QixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsT0FBTztTQUNSO1FBQ0QsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEVBQUU7WUFDcEIsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDdEIsTUFBTSxXQUFXLEdBQUcsdUJBQXVCLEdBQUcsR0FBRyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFFO29CQUM3QixXQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxDQUFDO2lCQUNsRjtnQkFDRCxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMxRSxDQUFDLENBQUMsQ0FBQztTQUNKO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUM5RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWJzdHJhY3RDb250cm9sLFxuICBBc3luY1ZhbGlkYXRvckZuLFxuICBGb3JtQ29udHJvbCxcbiAgVmFsaWRhdGlvbkVycm9ycyxcbiAgVmFsaWRhdG9yRm5cbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgZm9ya0pvaW4sIE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBjb25zdCBBUlJBWV9WQUxJREFUSU9OX1BSRUZJWCA9ICdJTk5FUl9BUlJBWV9FUlJPUl8nO1xuXG5leHBvcnQgdHlwZSBBcnJheVZhbGlkYXRpb25FcnJvcnMgPSB7XG4gIFtrZXk6IHN0cmluZ106IEFycmF5VmFsaWRhdGlvbkVycm9yVmFsdWU7XG59O1xuXG5leHBvcnQgdHlwZSBBcnJheVZhbGlkYXRpb25FcnJvclZhbHVlID0ge1xuICBpc0FycmF5RXJyb3I6IHRydWU7XG4gIG9yaWdpbmFsS2V5OiBzdHJpbmc7XG4gIGVudHJpZXM6IEFycmF5PHsgaW5kZXg6IG51bWJlcjsgZXJyb3JEYXRhOiB1bmtub3duIH0+O1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYW4gYWx0ZXIgaG93IHZhbGlkYXRvcnMgd29yay4gSXQgY2FuIGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgdGhlcmUgaXMgbmVlZCB0byB2YWxpZGF0ZSBGb3JtQ29udHJvbFxuICogdGhhdCBhcyB2YWx1ZSwgdGFrZXMgYXJyYXkgb2YgZWxlbWVudHMuIFRoaXMgYWxsb3dzIHRvIHJldXNlIHZhbGlkYXRvcnMsIHRoYXQgd29ya3MgZm9yIHN1Y2ggZWxlbWVudHMuXG4gKiBGb3IgZXhhbXBsZSBpZiAgVmFsaWRhdG9ycy5taW5MZW5ndGgoMykgaXMgdXNlZCBvbiBjb250cm9sIHRoYXQgdGFrZXMgc3RyaW5nIGFzIHZhbHVlLCB2YWxpZGF0b3Igd2lsbCByZXR1cm4gZXJyb3JcbiAqIGlmIHN0cmluZyBpcyBsZXNzIHRoYW4gMyBjaGFyYWN0ZXJzLiBJZiBzYW1lIGlzIGRvbmUgb24gYXJyYXkgb2Ygc3RyaW5ncywgdmFsaWRhdG9yIHdpbGwgcmV0dXJuIGVycm9yIGlmIGFycmF5XG4gKiBoYXMgbGVzcyB0aGFuIDMgZWxlbWVudHMuXG4gKlxuICogdmFsaWRhdGVBcnJheUVsZW1lbnRzKFZhbGlkYXRvcnMubWluTGVuZ3RoKDMpKSBtZXRob2QgbWFrZXMgaXQgcG9zc2libGUgdG8gY2hlY2sgZXZlcnkgbWVtYmVyIG9mIGFycmF5IGlmIGl0IGhhcyBtaW5pbXVtIDMgY2hhcmFjdGVycy5cbiAqIElmIHRoZXJlIGFyZSBlbGVtZW50cyB0aGF0IHJhaXNlIGVycm9yLCBpdCB3aWxsIGJlIHBvc3NpYmxlIHRvIGV4dHJhY3QgdGhlc2UgZXJyb3JzIHVzaW5nIGl0ZW0gaW5kZXguXG4gKlxuICogQXMgYSBleGFtcGxlLCB0aGlzIGNhbiBiZSB1c2VkIGZvciBjdXN0b20gZm9ybSBlbGVtZW50cywgd2hpY2ggbWFuaXB1bGF0ZXMgYXJyYXkgb2YgZWxlbWVudHMsXG4gKiBhbmQgdGhlcmUgaXMgbmVlZCB0byBkaXNwbGF5IGNvcnJlc3BvbmRpbmcgZXJyb3IgbWVzc2FnZXMgZm9yIGV2ZXJ5IGFycmF5IG1lbWJlciB0aGF0IGlzIGRpc3BsYXllZCwgd2hpbGUgc3RpbGwgdXNpbmdcbiAqIEFuZ3VsYXIncyBWYWxpZGF0aW9uIGFwcHJvYWNoLlxuICpcbiAqIEVycm9ycyB0aGF0IGFyZSBnZW5lcmF0ZWQgYnkgdGhpcyBoZWxwZXIgYXJlIHByZWZpeGVkIHdpdGggJ0lOTkVSX0FSUkFZX0VSUk9SXycuIFJlYXNvbiBmb3IgdGhpcyBpcyB0byBwcmV2ZW50IG92ZXJ3cml0aW5nIG5vcm1hbCB2YWxpZGF0aW9uXG4gKiBlcnJvcnMgdGhhdCBjb3VsZCBoYXZlIHNhbWUga2V5XG4gKlxuICogQEV4YW1wbGVcbiAqXG4gKiBsZXQgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbChbJzEyMzQnLCAnMTIzNDU2JywgJzEyMycsIFtWYWxpZGF0b3JzLm1pbkxlbmd0aCg1KSwgdmFsaWRhdGVBcnJheUVsZW1lbnRzKFZhbGlkYXRvcnMubWluTGVuZ3RoKDUpKV0gXSlcbiAqXG4gKiB0aGlzIEZvcm1Db250cm9sIGhhcyB2YWxpZGF0aW9uIGVycm9yczpcbiAqXG4gKiB7XG4gKiAgIFwiSU5ORVJfQVJSQVlfRVJST1JfbWlubGVuZ3RoXCI6IHtcbiAqICAgICAgaXNBcnJheUVycm9yOiB0cnVlLCBvcmlnaW5hbEtleTogbWlubGVuZ3RoLCBlbnRyaWVzOiBbXG4gKiAgICAgICAge2luZGV4OiAwLCBlcnJvckRhdGE6IHtyZXF1aXJlZExlbmd0aDogNSwgYWN0dWFsTGVuZ3RoOiA0fX0sXG4gKiAgICAgICAge2luZGV4OiAyLCBlcnJvckRhdGE6IHtyZXF1aXJlZExlbmd0aDogNSwgYWN0dWFsTGVuZ3RoOiAzfX0sXG4gKiAgICAgIF1cbiAqICAgIH0sXG4gKiAgICBcIm1pbmxlbmd0aFwiOyB7cmVxdWlyZWRMZW5ndGg6IDUsIGFjdHVhbExlbmd0aDogM31cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge1ZhbGlkYXRvckZufSB2YWxpZGF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlFbGVtZW50cyh2YWxpZGF0b3I6IFZhbGlkYXRvckZuKTogVmFsaWRhdG9yRm4ge1xuICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IHsgdmFsdWVOb3RBcnJheSB9IHwgQXJyYXlWYWxpZGF0aW9uRXJyb3JzID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb250cm9sLnZhbHVlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZU5vdEFycmF5OiB0cnVlIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvcnM6IFZhbGlkYXRpb25FcnJvcnNbXSA9IHZhbHVlcy5tYXAodmFsdWUgPT5cbiAgICAgIHZhbGlkYXRvcihuZXcgRm9ybUNvbnRyb2wodmFsdWUpKVxuICAgICk7XG4gICAgY29uc3QgY29udmVydGVkRXJyb3JzOiBBcnJheVZhbGlkYXRpb25FcnJvcnMgPSBnZW5lcmF0ZUFycmF5UmVsYXRlZEVycm9ycyh2YWxpZGF0aW9uRXJyb3JzKTtcbiAgICByZXR1cm4gY29udmVydGVkRXJyb3JzO1xuICB9O1xufVxuXG4vKipcbiAqIEFzeW5jIHZlcnNpb24gb2YgdmFsaWRhdGVBcnJheUVsZW1lbnRzLlxuICpcbiAqIE5vdGUgdGhhdCBBbmd1bGFyIGJ5IGRlc2lnbiBkb2Vzbid0IGV4ZWN1dGUgYXN5bmMgdmFsaWRhdG9ycyBpZiBzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHJldHVybnMgYW55IGVycm9yLlxuICogQHBhcmFtIHtBc3luY1ZhbGlkYXRvckZufSB2YWxpZGF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jVmFsaWRhdGVBcnJheUVsZW1lbnRzKHZhbGlkYXRvcjogQXN5bmNWYWxpZGF0b3JGbik6IEFzeW5jVmFsaWRhdG9yRm4ge1xuICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IE9ic2VydmFibGU8VmFsaWRhdGlvbkVycm9ycz4gPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbnRyb2wudmFsdWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIHJldHVybiBvZih7IHZhbHVlTm90QXJyYXk6IHRydWUgfSk7XG4gICAgfVxuICAgIGNvbnN0IG9ic2VydmFibGVzOiBBcnJheTxcbiAgICAgIFByb21pc2U8VmFsaWRhdGlvbkVycm9ycyB8IG51bGw+IHwgT2JzZXJ2YWJsZTxWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbD5cbiAgICA+ID0gdmFsdWVzLm1hcCh2YWx1ZSA9PiB2YWxpZGF0b3IobmV3IEZvcm1Db250cm9sKHZhbHVlKSkpO1xuXG4gICAgcmV0dXJuIGZvcmtKb2luKG9ic2VydmFibGVzKS5waXBlKG1hcChlcnJvcnMgPT4gZ2VuZXJhdGVBcnJheVJlbGF0ZWRFcnJvcnMoZXJyb3JzKSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUFycmF5UmVsYXRlZEVycm9ycyhlcnJvcnM6IEFycmF5PFZhbGlkYXRpb25FcnJvcnMgfCBudWxsPik6IEFycmF5VmFsaWRhdGlvbkVycm9ycyB7XG4gIGNvbnN0IGVycm9yT2JqZWN0OiBBcnJheVZhbGlkYXRpb25FcnJvcnMgPSB7fTtcblxuICBlcnJvcnMuZm9yRWFjaCgoZXJyb3IsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlcnJvcktleXMgPSBPYmplY3Qua2V5cyhlcnJvcik7XG4gICAgaWYgKGVycm9yS2V5cy5sZW5ndGgpIHtcbiAgICAgIGVycm9yS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHByZWZpeGVkS2V5ID0gQVJSQVlfVkFMSURBVElPTl9QUkVGSVggKyBrZXk7XG4gICAgICAgIGlmICghZXJyb3JPYmplY3RbcHJlZml4ZWRLZXldKSB7XG4gICAgICAgICAgZXJyb3JPYmplY3RbcHJlZml4ZWRLZXldID0geyBpc0FycmF5RXJyb3I6IHRydWUsIG9yaWdpbmFsS2V5OiBrZXksIGVudHJpZXM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JPYmplY3RbcHJlZml4ZWRLZXldLmVudHJpZXMucHVzaCh7IGluZGV4LCBlcnJvckRhdGE6IGVycm9yW2tleV0gfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmtleXMoZXJyb3JPYmplY3QpLmxlbmd0aCA/IGVycm9yT2JqZWN0IDogbnVsbDtcbn1cbiJdfQ==