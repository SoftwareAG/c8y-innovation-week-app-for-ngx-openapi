import { Pipe } from '@angular/core';
import { ValidationPattern } from './validation-pattern';
import * as i0 from "@angular/core";
/**
 * This pipe is responsible for transforming validation error key to actual translatable that
 * are defined in ValidationPattern class.
 *
 * @Example:
 *  let errorData = {requiredLength: 5, actualLength: 1}
 *
 * {{ 'minLength' | humanize-validation-message }}
 * Above code renders corresponding validation message for minLength:
 * "Should have at least {{ requiredLength }} characters"
 *
 * It is possible to chain translate pipe:
 * {{ 'minLength' | humanize-validation-message |translate:errorData  }}
 * should render: "Should have at least 5 characters"
 *
 * It is also possible to provide custom translation message. For example:
 * let customMessages = {minLength: gettext("File name should have at least {{ requiredLength }} characters")}
 * Html:
 * {{ 'minLength' | humanize-validation-message:customMessages |translate:errorData }}
 *
 * above code renders:
 * "File name should have at least 5 characters"
 */
export class HumanizeValidationMessagePipe {
    transform(errorName, customMessages = {}) {
        return customMessages[errorName] || ValidationPattern.messages[errorName] || errorName;
    }
}
HumanizeValidationMessagePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: HumanizeValidationMessagePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
HumanizeValidationMessagePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: HumanizeValidationMessagePipe, name: "humanizeValidationMessage" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: HumanizeValidationMessagePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'humanizeValidationMessage'
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHVtYW5pemUtdmFsaWRhdGlvbi1tZXNzYWdlLnBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2Zvcm1zL2h1bWFuaXplLXZhbGlkYXRpb24tbWVzc2FnZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDOztBQUV6RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUtILE1BQU0sT0FBTyw2QkFBNkI7SUFDeEMsU0FBUyxDQUFDLFNBQWlCLEVBQUUsaUJBQTRDLEVBQUU7UUFDekUsT0FBTyxjQUFjLENBQUMsU0FBUyxDQUFDLElBQUksaUJBQWlCLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLFNBQVMsQ0FBQztJQUN6RixDQUFDOzswSEFIVSw2QkFBNkI7d0hBQTdCLDZCQUE2QjsyRkFBN0IsNkJBQTZCO2tCQUh6QyxJQUFJO21CQUFDO29CQUNKLElBQUksRUFBRSwyQkFBMkI7aUJBQ2xDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmFsaWRhdGlvblBhdHRlcm4gfSBmcm9tICcuL3ZhbGlkYXRpb24tcGF0dGVybic7XG5cbi8qKlxuICogVGhpcyBwaXBlIGlzIHJlc3BvbnNpYmxlIGZvciB0cmFuc2Zvcm1pbmcgdmFsaWRhdGlvbiBlcnJvciBrZXkgdG8gYWN0dWFsIHRyYW5zbGF0YWJsZSB0aGF0XG4gKiBhcmUgZGVmaW5lZCBpbiBWYWxpZGF0aW9uUGF0dGVybiBjbGFzcy5cbiAqXG4gKiBARXhhbXBsZTpcbiAqICBsZXQgZXJyb3JEYXRhID0ge3JlcXVpcmVkTGVuZ3RoOiA1LCBhY3R1YWxMZW5ndGg6IDF9XG4gKlxuICoge3sgJ21pbkxlbmd0aCcgfCBodW1hbml6ZS12YWxpZGF0aW9uLW1lc3NhZ2UgfX1cbiAqIEFib3ZlIGNvZGUgcmVuZGVycyBjb3JyZXNwb25kaW5nIHZhbGlkYXRpb24gbWVzc2FnZSBmb3IgbWluTGVuZ3RoOlxuICogXCJTaG91bGQgaGF2ZSBhdCBsZWFzdCB7eyByZXF1aXJlZExlbmd0aCB9fSBjaGFyYWN0ZXJzXCJcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBjaGFpbiB0cmFuc2xhdGUgcGlwZTpcbiAqIHt7ICdtaW5MZW5ndGgnIHwgaHVtYW5pemUtdmFsaWRhdGlvbi1tZXNzYWdlIHx0cmFuc2xhdGU6ZXJyb3JEYXRhICB9fVxuICogc2hvdWxkIHJlbmRlcjogXCJTaG91bGQgaGF2ZSBhdCBsZWFzdCA1IGNoYXJhY3RlcnNcIlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcHJvdmlkZSBjdXN0b20gdHJhbnNsYXRpb24gbWVzc2FnZS4gRm9yIGV4YW1wbGU6XG4gKiBsZXQgY3VzdG9tTWVzc2FnZXMgPSB7bWluTGVuZ3RoOiBnZXR0ZXh0KFwiRmlsZSBuYW1lIHNob3VsZCBoYXZlIGF0IGxlYXN0IHt7IHJlcXVpcmVkTGVuZ3RoIH19IGNoYXJhY3RlcnNcIil9XG4gKiBIdG1sOlxuICoge3sgJ21pbkxlbmd0aCcgfCBodW1hbml6ZS12YWxpZGF0aW9uLW1lc3NhZ2U6Y3VzdG9tTWVzc2FnZXMgfHRyYW5zbGF0ZTplcnJvckRhdGEgfX1cbiAqXG4gKiBhYm92ZSBjb2RlIHJlbmRlcnM6XG4gKiBcIkZpbGUgbmFtZSBzaG91bGQgaGF2ZSBhdCBsZWFzdCA1IGNoYXJhY3RlcnNcIlxuICovXG5cbkBQaXBlKHtcbiAgbmFtZTogJ2h1bWFuaXplVmFsaWRhdGlvbk1lc3NhZ2UnXG59KVxuZXhwb3J0IGNsYXNzIEh1bWFuaXplVmFsaWRhdGlvbk1lc3NhZ2VQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gIHRyYW5zZm9ybShlcnJvck5hbWU6IHN0cmluZywgY3VzdG9tTWVzc2FnZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGN1c3RvbU1lc3NhZ2VzW2Vycm9yTmFtZV0gfHwgVmFsaWRhdGlvblBhdHRlcm4ubWVzc2FnZXNbZXJyb3JOYW1lXSB8fCBlcnJvck5hbWU7XG4gIH1cbn1cbiJdfQ==