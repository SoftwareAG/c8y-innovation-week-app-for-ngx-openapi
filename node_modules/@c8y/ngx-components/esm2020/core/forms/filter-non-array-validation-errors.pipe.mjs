import { Pipe } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * This pipe should be used in case when there might be generic Array validators, that could populate error object
 * with errors that are directly related to array elements. Such errors should be handled separately, but there still
 * might be errors that applies to whole array. This allows to filter out entry-specific messages from error object.
 *
 * @Example:
 *
 * TS:
 * errors = {
 *  "INNER_ARRAY_ERROR_minlength": {
 *      isArrayError: true, originalKey: 'minlength', entries: [
 *        {index: 0, errorData: {requiredLength: 5, actualLength: 4}},
 *        {index: 2, errorData: {requiredLength: 5, actualLength: 3}},
 *      ]
 *    },
 *  "minlength": {requiredLength: 5, actualLength: 3}}}
 * }
 *
 * HTML:
 * <small *ngFor="let error of errors | filterNonArrayValidationErrors | keyvalue">
 * {{error.key | humanizeValidationMessage | translate: errors.value}}
 * </small>
 *
 * Above code renders only these error messages that are not generated by Array entries
 *
 */
export class FilterNonArrayValidationErrorsPipe {
    transform(validationErrors) {
        if (!validationErrors) {
            return null;
        }
        const errorObject = { ...validationErrors };
        Object.keys(errorObject).forEach(errorKey => {
            if (errorObject[errorKey].isArrayError) {
                delete errorObject[errorKey];
            }
        });
        return Object.keys(errorObject).length ? errorObject : null;
    }
}
FilterNonArrayValidationErrorsPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilterNonArrayValidationErrorsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
FilterNonArrayValidationErrorsPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.7", ngImport: i0, type: FilterNonArrayValidationErrorsPipe, name: "filterNonArrayValidationErrors" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: FilterNonArrayValidationErrorsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'filterNonArrayValidationErrors'
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLW5vbi1hcnJheS12YWxpZGF0aW9uLWVycm9ycy5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9mb3Jtcy9maWx0ZXItbm9uLWFycmF5LXZhbGlkYXRpb24tZXJyb3JzLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7O0FBSXBEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUJHO0FBS0gsTUFBTSxPQUFPLGtDQUFrQztJQUM3QyxTQUFTLENBQUMsZ0JBQTBEO1FBQ2xFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUNyQixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxXQUFXLEdBQUcsRUFBRSxHQUFHLGdCQUFnQixFQUFFLENBQUM7UUFDNUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDMUMsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxFQUFFO2dCQUN0QyxPQUFPLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM5QjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDOUQsQ0FBQzs7K0hBZFUsa0NBQWtDOzZIQUFsQyxrQ0FBa0M7MkZBQWxDLGtDQUFrQztrQkFIOUMsSUFBSTttQkFBQztvQkFDSixJQUFJLEVBQUUsZ0NBQWdDO2lCQUN2QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBBcnJheVZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICcuL3ZhbGlkYXRlLWFycmF5LWVsZW1lbnRzJztcblxuLyoqXG4gKiBUaGlzIHBpcGUgc2hvdWxkIGJlIHVzZWQgaW4gY2FzZSB3aGVuIHRoZXJlIG1pZ2h0IGJlIGdlbmVyaWMgQXJyYXkgdmFsaWRhdG9ycywgdGhhdCBjb3VsZCBwb3B1bGF0ZSBlcnJvciBvYmplY3RcbiAqIHdpdGggZXJyb3JzIHRoYXQgYXJlIGRpcmVjdGx5IHJlbGF0ZWQgdG8gYXJyYXkgZWxlbWVudHMuIFN1Y2ggZXJyb3JzIHNob3VsZCBiZSBoYW5kbGVkIHNlcGFyYXRlbHksIGJ1dCB0aGVyZSBzdGlsbFxuICogbWlnaHQgYmUgZXJyb3JzIHRoYXQgYXBwbGllcyB0byB3aG9sZSBhcnJheS4gVGhpcyBhbGxvd3MgdG8gZmlsdGVyIG91dCBlbnRyeS1zcGVjaWZpYyBtZXNzYWdlcyBmcm9tIGVycm9yIG9iamVjdC5cbiAqXG4gKiBARXhhbXBsZTpcbiAqXG4gKiBUUzpcbiAqIGVycm9ycyA9IHtcbiAqICBcIklOTkVSX0FSUkFZX0VSUk9SX21pbmxlbmd0aFwiOiB7XG4gKiAgICAgIGlzQXJyYXlFcnJvcjogdHJ1ZSwgb3JpZ2luYWxLZXk6ICdtaW5sZW5ndGgnLCBlbnRyaWVzOiBbXG4gKiAgICAgICAge2luZGV4OiAwLCBlcnJvckRhdGE6IHtyZXF1aXJlZExlbmd0aDogNSwgYWN0dWFsTGVuZ3RoOiA0fX0sXG4gKiAgICAgICAge2luZGV4OiAyLCBlcnJvckRhdGE6IHtyZXF1aXJlZExlbmd0aDogNSwgYWN0dWFsTGVuZ3RoOiAzfX0sXG4gKiAgICAgIF1cbiAqICAgIH0sXG4gKiAgXCJtaW5sZW5ndGhcIjoge3JlcXVpcmVkTGVuZ3RoOiA1LCBhY3R1YWxMZW5ndGg6IDN9fX1cbiAqIH1cbiAqXG4gKiBIVE1MOlxuICogPHNtYWxsICpuZ0Zvcj1cImxldCBlcnJvciBvZiBlcnJvcnMgfCBmaWx0ZXJOb25BcnJheVZhbGlkYXRpb25FcnJvcnMgfCBrZXl2YWx1ZVwiPlxuICoge3tlcnJvci5rZXkgfCBodW1hbml6ZVZhbGlkYXRpb25NZXNzYWdlIHwgdHJhbnNsYXRlOiBlcnJvcnMudmFsdWV9fVxuICogPC9zbWFsbD5cbiAqXG4gKiBBYm92ZSBjb2RlIHJlbmRlcnMgb25seSB0aGVzZSBlcnJvciBtZXNzYWdlcyB0aGF0IGFyZSBub3QgZ2VuZXJhdGVkIGJ5IEFycmF5IGVudHJpZXNcbiAqXG4gKi9cblxuQFBpcGUoe1xuICBuYW1lOiAnZmlsdGVyTm9uQXJyYXlWYWxpZGF0aW9uRXJyb3JzJ1xufSlcbmV4cG9ydCBjbGFzcyBGaWx0ZXJOb25BcnJheVZhbGlkYXRpb25FcnJvcnNQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gIHRyYW5zZm9ybSh2YWxpZGF0aW9uRXJyb3JzOiBBcnJheVZhbGlkYXRpb25FcnJvcnMgfCBWYWxpZGF0aW9uRXJyb3JzKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIGlmICghdmFsaWRhdGlvbkVycm9ycykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JPYmplY3QgPSB7IC4uLnZhbGlkYXRpb25FcnJvcnMgfTtcbiAgICBPYmplY3Qua2V5cyhlcnJvck9iamVjdCkuZm9yRWFjaChlcnJvcktleSA9PiB7XG4gICAgICBpZiAoZXJyb3JPYmplY3RbZXJyb3JLZXldLmlzQXJyYXlFcnJvcikge1xuICAgICAgICBkZWxldGUgZXJyb3JPYmplY3RbZXJyb3JLZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGVycm9yT2JqZWN0KS5sZW5ndGggPyBlcnJvck9iamVjdCA6IG51bGw7XG4gIH1cbn1cbiJdfQ==