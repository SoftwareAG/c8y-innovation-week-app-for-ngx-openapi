import { Injectable, NgModuleRef, createNgModuleRef, EnvironmentInjector } from '@angular/core';
import { FetchClient } from '@c8y/client';
import { TranslateService } from '@ngx-translate/core';
import { reduce, forEach, get, union, camelCase } from 'lodash-es';
import { BehaviorSubject, Subject } from 'rxjs';
import { shareReplay } from 'rxjs/operators';
import { AppStateService } from '../common';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
import * as i2 from "@c8y/client";
import * as i3 from "../common";
export class PluginsResolveService {
    constructor(translateService, fetchClient, appState, injector) {
        this.translateService = translateService;
        this.fetchClient = fetchClient;
        this.appState = appState;
        this.injector = injector;
        this.urlRemotesCache = null;
        this.remoteScriptSet = new Set();
        this._injectors$ = new Subject();
        this._refresh$ = new Subject();
        this._pluginDetails$ = new Subject();
        this._allPluginsLoaded$ = new BehaviorSubject(false);
        this.injectors$ = this._injectors$.asObservable().pipe(
        // not specifying the bufferSize of shareReplay so all injectors are received on subscription
        shareReplay());
        this.refresh$ = this._refresh$.asObservable().pipe(shareReplay(1));
        this.pluginDetails$ = this._pluginDetails$.asObservable().pipe(
        // not specifying the bufferSize of shareReplay so all details are received on subscription
        shareReplay());
        this.allPluginsLoaded$ = this._allPluginsLoaded$.asObservable();
    }
    /**
     * Loads plugins by resolving the remote NgModules and injecting it. Also attaching
     * the hooks onto the root injector.
     * @param remoteModules The remote plugins to load as factory name mapping array.
     */
    resolveRemotePlugins(remoteModules) {
        this.loadModulesDynamically(remoteModules);
        this.refreshHooks();
        this.markPluginsAsLoaded();
    }
    /**
     * Loads modules and handles hooking correctly.
     * @param remoteNgModules The modules to load.
     */
    loadModulesDynamically(remoteModules) {
        for (const { factory, name } of remoteModules) {
            try {
                this.loadModule(factory[name]);
            }
            catch (ex) {
                console.error(`Failed to load ${name}`, ex);
            }
        }
    }
    loadModule(remoteNgModule) {
        let moduleRef;
        if (remoteNgModule instanceof NgModuleRef) {
            // AOT
            moduleRef = remoteNgModule;
        }
        else {
            // JIT
            moduleRef = createNgModuleRef(remoteNgModule, this.injector);
        }
        this._injectors$.next(moduleRef.injector);
        this._pluginDetails$.next({ moduleRef, remoteNgModule });
        return moduleRef;
    }
    /**
     * Will refresh all current registered hooks.
     */
    refreshHooks() {
        this._refresh$.next();
    }
    markPluginsAsLoaded() {
        this._allPluginsLoaded$.next(true);
    }
    /**
     * Loads a list of remotes so that a particular application can use them.
     * The request is made to the following address: /apps/<contextPath>/remoteEntry.js
     * @param remotes List of remotes to be loaded.
     * @returns Returns the list of loaded modules from remotes.
     */
    async loadRemotes(remotes) {
        if (!remotes) {
            return [];
        }
        const date = new Date();
        const remoteModules = [];
        for (const pluginId in remotes) {
            if (remotes.hasOwnProperty(pluginId)) {
                const moduleNames = remotes[pluginId];
                const url = `/apps/${pluginId}/remoteEntry.js?nocache=${date.getTime()}`;
                let atLeastOneModuleLoadedSuccessfully = false;
                for (const moduleName of moduleNames) {
                    try {
                        remoteModules.push(await this.loadRemoteModule(url, pluginId, moduleName));
                        atLeastOneModuleLoadedSuccessfully = true;
                    }
                    catch (ex) {
                        console.warn(`Could not load remote module '${moduleName}' from url:`, url);
                    }
                }
                // no need to load translations if we were unable to load a single module..
                if (atLeastOneModuleLoadedSuccessfully) {
                    await this.loadRemoteTranslations(pluginId);
                }
            }
        }
        return remoteModules;
    }
    /**
     * Takes a list of remotes and turns it into an object containing union of corresponding remotes.
     * @param mfRemotes List of the remotes.
     * @returns Returns object with merged remotes.
     *
     * **Example**
     * ```typescript
     * const remotesA:ApplicationRemotePlugins = { contextPathA: ['moduleA', 'moduleB'] };
     * const remotesB:ApplicationRemotePlugins = { contextPathA: ['moduleA'], contextPathB: ['moduleZ'] };
     * const mergedRemotes:ApplicationRemotePlugins = mergeMFRemotes([remotesA, remotesB]);
     * // Result
     * {
     *  contextPathA: ['moduleA', 'moduleB'],
     *  contextPathB: ['moduleZ']
     * }
     *
     * ```
     */
    mergeMFRemotes(mfRemotes) {
        return reduce(mfRemotes, (allRemotes, mfRemote) => {
            forEach(mfRemote, (remoteModules, remoteContextPath) => {
                const currentRemotes = get(allRemotes, remoteContextPath, []);
                allRemotes[remoteContextPath] = union(currentRemotes, remoteModules);
            });
            return allRemotes;
        }, {});
    }
    /**
     * Clears URL remotes cache.
     */
    clearURLRemotesCache() {
        this.urlRemotesCache = null;
    }
    /**
     * Retrieves the remotes list from the URL.
     * @returns Returns the list of remotes.
     */
    loadUrlRemotes() {
        if (!this.urlRemotesCache) {
            const params = new URLSearchParams(window.location.search);
            const remotes = params.get('remotes');
            if (remotes) {
                try {
                    this.urlRemotesCache = JSON.parse(decodeURIComponent(remotes));
                }
                catch (error) {
                    console.warn(`Failed to parse remotes: ${error}`);
                }
            }
        }
        return this.urlRemotesCache;
    }
    async loadRemoteTranslations(pluginId) {
        try {
            const { lang } = this.appState.state;
            const resp = await this.fetchClient.fetch(`/apps/${pluginId}/${lang}.json`);
            if (resp.status < 400) {
                const result = await resp.json();
                this.translateService.setTranslation(lang, result[lang], true);
            }
        }
        catch (ex) {
            console.warn(`Failed to load translations for ${pluginId}`);
        }
    }
    async loadRemoteModule(remoteEntryUrl, remoteContextPath, exposedModule) {
        if (!this.remoteScriptSet.has(remoteEntryUrl)) {
            this.remoteScriptSet.add(remoteEntryUrl);
            await this.loadRemoteEntry(remoteEntryUrl);
        }
        let contextPath = remoteContextPath;
        if (contextPath.includes('@')) {
            contextPath = remoteContextPath.split('@')[0];
        }
        return await this.lookupExposedModule(camelCase(contextPath), exposedModule);
    }
    loadRemoteEntry(remoteEntryUrl) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = remoteEntryUrl;
            script.onerror = reject;
            script.onload = () => {
                resolve(); // window is the global namespace
            };
            document.body.append(script);
        });
    }
    async lookupExposedModule(remoteName, exposedModule) {
        // Initializes the share scope. This fills it with known provided modules from this build and all remotes
        try {
            await __webpack_init_sharing__('default');
        }
        catch (ex) {
            console.error(`Module ${exposedModule} could not be loaded. Module Federation is not enabled in this application.`, ex);
        }
        const container = window[remoteName];
        // Initialize the container, it may provide shared modules
        let factory;
        try {
            await container.init(__webpack_share_scopes__.default);
            factory = (await container.get(exposedModule))();
        }
        catch (ex) {
            console.error(`Module ${exposedModule} could not be loaded.`, ex);
        }
        return { name: exposedModule, factory };
    }
}
PluginsResolveService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: PluginsResolveService, deps: [{ token: i1.TranslateService }, { token: i2.FetchClient }, { token: i3.AppStateService }, { token: i0.EnvironmentInjector }], target: i0.ɵɵFactoryTarget.Injectable });
PluginsResolveService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: PluginsResolveService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: PluginsResolveService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.TranslateService }, { type: i2.FetchClient }, { type: i3.AppStateService }, { type: i0.EnvironmentInjector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2lucy1yZXNvbHZlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3BsdWdpbnMvcGx1Z2lucy1yZXNvbHZlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFVBQVUsRUFDVixXQUFXLEVBQ1gsaUJBQWlCLEVBQ2pCLG1CQUFtQixFQUVwQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQTRCLFdBQVcsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNwRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNuRSxPQUFPLEVBQUUsZUFBZSxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM1RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7Ozs7QUFlNUMsTUFBTSxPQUFPLHFCQUFxQjtJQTJCaEMsWUFDVSxnQkFBa0MsRUFDbEMsV0FBd0IsRUFDeEIsUUFBeUIsRUFDekIsUUFBNkI7UUFIN0IscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUN6QixhQUFRLEdBQVIsUUFBUSxDQUFxQjtRQWQvQixvQkFBZSxHQUE2QixJQUFJLENBQUM7UUFDakQsb0JBQWUsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3BDLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQXVCLENBQUM7UUFDakQsY0FBUyxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFDaEMsb0JBQWUsR0FBRyxJQUFJLE9BQU8sRUFHakMs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QUFPLEVBQUUsRUFBRTtZQUNYLE9BQU8sQ0FBQyxLQUFLLENBQ1gsVUFBVSxhQUFhLDZFQUE2RSxFQUNwRyxFQUFFLENBQ0gsQ0FBQztTQUNIO1FBQ0QsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBYyxDQUFDO1FBRWxELDBEQUEwRDtRQUMxRCxJQUFJLE9BQWdCLENBQUM7UUFDckIsSUFBSTtZQUNGLE1BQU0sU0FBUyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN2RCxPQUFPLEdBQUcsQ0FBQyxNQUFNLFNBQVMsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDO1NBQ2xEO1FBQUMsT0FBTyxFQUFFLEVBQUU7WUFDWCxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsYUFBYSx1QkFBdUIsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNuRTtRQUNELE9BQU8sRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxDQUFDO0lBQzFDLENBQUM7O2tIQWpRVSxxQkFBcUI7c0hBQXJCLHFCQUFxQixjQUZwQixNQUFNOzJGQUVQLHFCQUFxQjtrQkFIakMsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBJbmplY3RhYmxlLFxuICBOZ01vZHVsZVJlZixcbiAgY3JlYXRlTmdNb2R1bGVSZWYsXG4gIEVudmlyb25tZW50SW5qZWN0b3IsXG4gIFR5cGVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvblJlbW90ZVBsdWdpbnMsIEZldGNoQ2xpZW50IH0gZnJvbSAnQGM4eS9jbGllbnQnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgcmVkdWNlLCBmb3JFYWNoLCBnZXQsIHVuaW9uLCBjYW1lbENhc2UgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFwcFN0YXRlU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbic7XG5cbnR5cGUgU2NvcGUgPSB1bmtub3duO1xudHlwZSBGYWN0b3J5ID0gKCkgPT4gYW55O1xuXG5kZWNsYXJlIGNvbnN0IF9fd2VicGFja19pbml0X3NoYXJpbmdfXzogKHNoYXJlU2NvcGU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbmRlY2xhcmUgY29uc3QgX193ZWJwYWNrX3NoYXJlX3Njb3Blc19fOiB7IGRlZmF1bHQ6IFNjb3BlIH07XG5cbmludGVyZmFjZSBDb250YWluZXIge1xuICBpbml0KHNoYXJlU2NvcGU6IFNjb3BlKTogdm9pZDtcbiAgZ2V0KG1vZHVsZTogc3RyaW5nKTogRmFjdG9yeTtcbn1cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFBsdWdpbnNSZXNvbHZlU2VydmljZSB7XG4gIC8qKlxuICAgKiBFbWl0cyBhbGwgaW5qZWN0b3JzIG9mIGFscmVhZHkgbG9hZGVkIHBsdWdpbnMgb24gc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgaW5qZWN0b3JzJDogT2JzZXJ2YWJsZTxFbnZpcm9ubWVudEluamVjdG9yPjtcbiAgLyoqXG4gICAqIEVtaXRzIG9uY2UgcmVtb3RlUGx1Z2lucyBoYXZlIGJlZW4gcmVzb2x2ZWQuXG4gICAqL1xuICByZWZyZXNoJDogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgLyoqXG4gICAqIEVtaXRzIGFsbCBwbHVnaW4gZGV0YWlscyBvZiBhbHJlYWR5IGxvYWRlZCBwbHVnaW5zIG9uIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIHBsdWdpbkRldGFpbHMkOiBPYnNlcnZhYmxlPHtcbiAgICByZW1vdGVOZ01vZHVsZTogTmdNb2R1bGVSZWY8dW5rbm93bj4gfCBUeXBlPHVua25vd24+O1xuICAgIG1vZHVsZVJlZjogTmdNb2R1bGVSZWY8dW5rbm93bj47XG4gIH0+O1xuICBhbGxQbHVnaW5zTG9hZGVkJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcbiAgcHJpdmF0ZSB1cmxSZW1vdGVzQ2FjaGU6IEFwcGxpY2F0aW9uUmVtb3RlUGx1Z2lucyA9IG51bGw7XG4gIHByaXZhdGUgcmVtb3RlU2NyaXB0U2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIHByaXZhdGUgX2luamVjdG9ycyQgPSBuZXcgU3ViamVjdDxFbnZpcm9ubWVudEluamVjdG9yPigpO1xuICBwcml2YXRlIF9yZWZyZXNoJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgX3BsdWdpbkRldGFpbHMkID0gbmV3IFN1YmplY3Q8e1xuICAgIHJlbW90ZU5nTW9kdWxlOiBOZ01vZHVsZVJlZjx1bmtub3duPiB8IFR5cGU8dW5rbm93bj47XG4gICAgbW9kdWxlUmVmOiBOZ01vZHVsZVJlZjx1bmtub3duPjtcbiAgfT4oKTtcbiAgcHJpdmF0ZSBfYWxsUGx1Z2luc0xvYWRlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBmZXRjaENsaWVudDogRmV0Y2hDbGllbnQsXG4gICAgcHJpdmF0ZSBhcHBTdGF0ZTogQXBwU3RhdGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEVudmlyb25tZW50SW5qZWN0b3JcbiAgKSB7XG4gICAgdGhpcy5pbmplY3RvcnMkID0gdGhpcy5faW5qZWN0b3JzJC5hc09ic2VydmFibGUoKS5waXBlKFxuICAgICAgLy8gbm90IHNwZWNpZnlpbmcgdGhlIGJ1ZmZlclNpemUgb2Ygc2hhcmVSZXBsYXkgc28gYWxsIGluamVjdG9ycyBhcmUgcmVjZWl2ZWQgb24gc3Vic2NyaXB0aW9uXG4gICAgICBzaGFyZVJlcGxheSgpXG4gICAgKTtcbiAgICB0aGlzLnJlZnJlc2gkID0gdGhpcy5fcmVmcmVzaCQuYXNPYnNlcnZhYmxlKCkucGlwZShzaGFyZVJlcGxheSgxKSk7XG4gICAgdGhpcy5wbHVnaW5EZXRhaWxzJCA9IHRoaXMuX3BsdWdpbkRldGFpbHMkLmFzT2JzZXJ2YWJsZSgpLnBpcGUoXG4gICAgICAvLyBub3Qgc3BlY2lmeWluZyB0aGUgYnVmZmVyU2l6ZSBvZiBzaGFyZVJlcGxheSBzbyBhbGwgZGV0YWlscyBhcmUgcmVjZWl2ZWQgb24gc3Vic2NyaXB0aW9uXG4gICAgICBzaGFyZVJlcGxheSgpXG4gICAgKTtcbiAgICB0aGlzLmFsbFBsdWdpbnNMb2FkZWQkID0gdGhpcy5fYWxsUGx1Z2luc0xvYWRlZCQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgcGx1Z2lucyBieSByZXNvbHZpbmcgdGhlIHJlbW90ZSBOZ01vZHVsZXMgYW5kIGluamVjdGluZyBpdC4gQWxzbyBhdHRhY2hpbmdcbiAgICogdGhlIGhvb2tzIG9udG8gdGhlIHJvb3QgaW5qZWN0b3IuXG4gICAqIEBwYXJhbSByZW1vdGVNb2R1bGVzIFRoZSByZW1vdGUgcGx1Z2lucyB0byBsb2FkIGFzIGZhY3RvcnkgbmFtZSBtYXBwaW5nIGFycmF5LlxuICAgKi9cbiAgcmVzb2x2ZVJlbW90ZVBsdWdpbnMocmVtb3RlTW9kdWxlczogQXJyYXk8eyBmYWN0b3J5OyBuYW1lIH0+KSB7XG4gICAgdGhpcy5sb2FkTW9kdWxlc0R5bmFtaWNhbGx5KHJlbW90ZU1vZHVsZXMpO1xuICAgIHRoaXMucmVmcmVzaEhvb2tzKCk7XG4gICAgdGhpcy5tYXJrUGx1Z2luc0FzTG9hZGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgbW9kdWxlcyBhbmQgaGFuZGxlcyBob29raW5nIGNvcnJlY3RseS5cbiAgICogQHBhcmFtIHJlbW90ZU5nTW9kdWxlcyBUaGUgbW9kdWxlcyB0byBsb2FkLlxuICAgKi9cbiAgbG9hZE1vZHVsZXNEeW5hbWljYWxseShyZW1vdGVNb2R1bGVzOiBBcnJheTx7IGZhY3Rvcnk7IG5hbWUgfT4pIHtcbiAgICBmb3IgKGNvbnN0IHsgZmFjdG9yeSwgbmFtZSB9IG9mIHJlbW90ZU1vZHVsZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9hZE1vZHVsZShmYWN0b3J5W25hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkICR7bmFtZX1gLCBleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZE1vZHVsZShyZW1vdGVOZ01vZHVsZTogTmdNb2R1bGVSZWY8dW5rbm93bj4gfCBUeXBlPHVua25vd24+KSB7XG4gICAgbGV0IG1vZHVsZVJlZjogTmdNb2R1bGVSZWY8dW5rbm93bj47XG4gICAgaWYgKHJlbW90ZU5nTW9kdWxlIGluc3RhbmNlb2YgTmdNb2R1bGVSZWYpIHtcbiAgICAgIC8vIEFPVFxuICAgICAgbW9kdWxlUmVmID0gcmVtb3RlTmdNb2R1bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEpJVFxuICAgICAgbW9kdWxlUmVmID0gY3JlYXRlTmdNb2R1bGVSZWYocmVtb3RlTmdNb2R1bGUsIHRoaXMuaW5qZWN0b3IpO1xuICAgIH1cbiAgICB0aGlzLl9pbmplY3RvcnMkLm5leHQobW9kdWxlUmVmLmluamVjdG9yKTtcbiAgICB0aGlzLl9wbHVnaW5EZXRhaWxzJC5uZXh0KHsgbW9kdWxlUmVmLCByZW1vdGVOZ01vZHVsZSB9KTtcbiAgICByZXR1cm4gbW9kdWxlUmVmO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgcmVmcmVzaCBhbGwgY3VycmVudCByZWdpc3RlcmVkIGhvb2tzLlxuICAgKi9cbiAgcmVmcmVzaEhvb2tzKCkge1xuICAgIHRoaXMuX3JlZnJlc2gkLm5leHQoKTtcbiAgfVxuXG4gIG1hcmtQbHVnaW5zQXNMb2FkZWQoKSB7XG4gICAgdGhpcy5fYWxsUGx1Z2luc0xvYWRlZCQubmV4dCh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGxpc3Qgb2YgcmVtb3RlcyBzbyB0aGF0IGEgcGFydGljdWxhciBhcHBsaWNhdGlvbiBjYW4gdXNlIHRoZW0uXG4gICAqIFRoZSByZXF1ZXN0IGlzIG1hZGUgdG8gdGhlIGZvbGxvd2luZyBhZGRyZXNzOiAvYXBwcy88Y29udGV4dFBhdGg+L3JlbW90ZUVudHJ5LmpzXG4gICAqIEBwYXJhbSByZW1vdGVzIExpc3Qgb2YgcmVtb3RlcyB0byBiZSBsb2FkZWQuXG4gICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGxpc3Qgb2YgbG9hZGVkIG1vZHVsZXMgZnJvbSByZW1vdGVzLlxuICAgKi9cbiAgYXN5bmMgbG9hZFJlbW90ZXMocmVtb3RlczogQXBwbGljYXRpb25SZW1vdGVQbHVnaW5zKSB7XG4gICAgaWYgKCFyZW1vdGVzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHJlbW90ZU1vZHVsZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbklkIGluIHJlbW90ZXMpIHtcbiAgICAgIGlmIChyZW1vdGVzLmhhc093blByb3BlcnR5KHBsdWdpbklkKSkge1xuICAgICAgICBjb25zdCBtb2R1bGVOYW1lcyA9IHJlbW90ZXNbcGx1Z2luSWRdO1xuICAgICAgICBjb25zdCB1cmwgPSBgL2FwcHMvJHtwbHVnaW5JZH0vcmVtb3RlRW50cnkuanM/bm9jYWNoZT0ke2RhdGUuZ2V0VGltZSgpfWA7XG4gICAgICAgIGxldCBhdExlYXN0T25lTW9kdWxlTG9hZGVkU3VjY2Vzc2Z1bGx5ID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlTmFtZSBvZiBtb2R1bGVOYW1lcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW1vdGVNb2R1bGVzLnB1c2goYXdhaXQgdGhpcy5sb2FkUmVtb3RlTW9kdWxlKHVybCwgcGx1Z2luSWQsIG1vZHVsZU5hbWUpKTtcbiAgICAgICAgICAgIGF0TGVhc3RPbmVNb2R1bGVMb2FkZWRTdWNjZXNzZnVsbHkgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBsb2FkIHJlbW90ZSBtb2R1bGUgJyR7bW9kdWxlTmFtZX0nIGZyb20gdXJsOmAsIHVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byBsb2FkIHRyYW5zbGF0aW9ucyBpZiB3ZSB3ZXJlIHVuYWJsZSB0byBsb2FkIGEgc2luZ2xlIG1vZHVsZS4uXG4gICAgICAgIGlmIChhdExlYXN0T25lTW9kdWxlTG9hZGVkU3VjY2Vzc2Z1bGx5KSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5sb2FkUmVtb3RlVHJhbnNsYXRpb25zKHBsdWdpbklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlTW9kdWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBhIGxpc3Qgb2YgcmVtb3RlcyBhbmQgdHVybnMgaXQgaW50byBhbiBvYmplY3QgY29udGFpbmluZyB1bmlvbiBvZiBjb3JyZXNwb25kaW5nIHJlbW90ZXMuXG4gICAqIEBwYXJhbSBtZlJlbW90ZXMgTGlzdCBvZiB0aGUgcmVtb3Rlcy5cbiAgICogQHJldHVybnMgUmV0dXJucyBvYmplY3Qgd2l0aCBtZXJnZWQgcmVtb3Rlcy5cbiAgICpcbiAgICogKipFeGFtcGxlKipcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZW1vdGVzQTpBcHBsaWNhdGlvblJlbW90ZVBsdWdpbnMgPSB7IGNvbnRleHRQYXRoQTogWydtb2R1bGVBJywgJ21vZHVsZUInXSB9O1xuICAgKiBjb25zdCByZW1vdGVzQjpBcHBsaWNhdGlvblJlbW90ZVBsdWdpbnMgPSB7IGNvbnRleHRQYXRoQTogWydtb2R1bGVBJ10sIGNvbnRleHRQYXRoQjogWydtb2R1bGVaJ10gfTtcbiAgICogY29uc3QgbWVyZ2VkUmVtb3RlczpBcHBsaWNhdGlvblJlbW90ZVBsdWdpbnMgPSBtZXJnZU1GUmVtb3RlcyhbcmVtb3Rlc0EsIHJlbW90ZXNCXSk7XG4gICAqIC8vIFJlc3VsdFxuICAgKiB7XG4gICAqICBjb250ZXh0UGF0aEE6IFsnbW9kdWxlQScsICdtb2R1bGVCJ10sXG4gICAqICBjb250ZXh0UGF0aEI6IFsnbW9kdWxlWiddXG4gICAqIH1cbiAgICpcbiAgICogYGBgXG4gICAqL1xuICBtZXJnZU1GUmVtb3RlcyhtZlJlbW90ZXM6IEFwcGxpY2F0aW9uUmVtb3RlUGx1Z2luc1tdKTogQXBwbGljYXRpb25SZW1vdGVQbHVnaW5zIHtcbiAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgbWZSZW1vdGVzLFxuICAgICAgKGFsbFJlbW90ZXM6IEFwcGxpY2F0aW9uUmVtb3RlUGx1Z2lucywgbWZSZW1vdGU6IEFwcGxpY2F0aW9uUmVtb3RlUGx1Z2lucykgPT4ge1xuICAgICAgICBmb3JFYWNoKG1mUmVtb3RlLCAocmVtb3RlTW9kdWxlczogc3RyaW5nW10sIHJlbW90ZUNvbnRleHRQYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50UmVtb3RlcyA9IGdldChhbGxSZW1vdGVzLCByZW1vdGVDb250ZXh0UGF0aCwgW10pO1xuICAgICAgICAgIGFsbFJlbW90ZXNbcmVtb3RlQ29udGV4dFBhdGhdID0gdW5pb24oY3VycmVudFJlbW90ZXMsIHJlbW90ZU1vZHVsZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYWxsUmVtb3RlcztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIFVSTCByZW1vdGVzIGNhY2hlLlxuICAgKi9cbiAgY2xlYXJVUkxSZW1vdGVzQ2FjaGUoKSB7XG4gICAgdGhpcy51cmxSZW1vdGVzQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgcmVtb3RlcyBsaXN0IGZyb20gdGhlIFVSTC5cbiAgICogQHJldHVybnMgUmV0dXJucyB0aGUgbGlzdCBvZiByZW1vdGVzLlxuICAgKi9cbiAgbG9hZFVybFJlbW90ZXMoKSB7XG4gICAgaWYgKCF0aGlzLnVybFJlbW90ZXNDYWNoZSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgIGNvbnN0IHJlbW90ZXMgPSBwYXJhbXMuZ2V0KCdyZW1vdGVzJyk7XG4gICAgICBpZiAocmVtb3Rlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMudXJsUmVtb3Rlc0NhY2hlID0gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQocmVtb3RlcykpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHBhcnNlIHJlbW90ZXM6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXJsUmVtb3Rlc0NhY2hlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkUmVtb3RlVHJhbnNsYXRpb25zKHBsdWdpbklkOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBsYW5nIH0gPSB0aGlzLmFwcFN0YXRlLnN0YXRlO1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZmV0Y2hDbGllbnQuZmV0Y2goYC9hcHBzLyR7cGx1Z2luSWR9LyR7bGFuZ30uanNvbmApO1xuICAgICAgaWYgKHJlc3Auc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVNlcnZpY2Uuc2V0VHJhbnNsYXRpb24obGFuZywgcmVzdWx0W2xhbmddLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9hZCB0cmFuc2xhdGlvbnMgZm9yICR7cGx1Z2luSWR9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkUmVtb3RlTW9kdWxlKFxuICAgIHJlbW90ZUVudHJ5VXJsOiBzdHJpbmcsXG4gICAgcmVtb3RlQ29udGV4dFBhdGg6IHN0cmluZyxcbiAgICBleHBvc2VkTW9kdWxlOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IG5hbWU6IHN0cmluZzsgZmFjdG9yeTogRmFjdG9yeSB9PiB7XG4gICAgaWYgKCF0aGlzLnJlbW90ZVNjcmlwdFNldC5oYXMocmVtb3RlRW50cnlVcmwpKSB7XG4gICAgICB0aGlzLnJlbW90ZVNjcmlwdFNldC5hZGQocmVtb3RlRW50cnlVcmwpO1xuICAgICAgYXdhaXQgdGhpcy5sb2FkUmVtb3RlRW50cnkocmVtb3RlRW50cnlVcmwpO1xuICAgIH1cbiAgICBsZXQgY29udGV4dFBhdGg6IHN0cmluZyA9IHJlbW90ZUNvbnRleHRQYXRoO1xuICAgIGlmIChjb250ZXh0UGF0aC5pbmNsdWRlcygnQCcpKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IHJlbW90ZUNvbnRleHRQYXRoLnNwbGl0KCdAJylbMF07XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmxvb2t1cEV4cG9zZWRNb2R1bGUoY2FtZWxDYXNlKGNvbnRleHRQYXRoKSwgZXhwb3NlZE1vZHVsZSk7XG4gIH1cblxuICBwcml2YXRlIGxvYWRSZW1vdGVFbnRyeShyZW1vdGVFbnRyeVVybDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0LnNyYyA9IHJlbW90ZUVudHJ5VXJsO1xuXG4gICAgICBzY3JpcHQub25lcnJvciA9IHJlamVjdDtcblxuICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpOyAvLyB3aW5kb3cgaXMgdGhlIGdsb2JhbCBuYW1lc3BhY2VcbiAgICAgIH07XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNjcmlwdCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvb2t1cEV4cG9zZWRNb2R1bGUoXG4gICAgcmVtb3RlTmFtZTogc3RyaW5nLFxuICAgIGV4cG9zZWRNb2R1bGU6IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbmFtZTogc3RyaW5nOyBmYWN0b3J5OiBGYWN0b3J5IH0+IHtcbiAgICAvLyBJbml0aWFsaXplcyB0aGUgc2hhcmUgc2NvcGUuIFRoaXMgZmlsbHMgaXQgd2l0aCBrbm93biBwcm92aWRlZCBtb2R1bGVzIGZyb20gdGhpcyBidWlsZCBhbmQgYWxsIHJlbW90ZXNcbiAgICB0cnkge1xuICAgICAgYXdhaXQgX193ZWJwYWNrX2luaXRfc2hhcmluZ19fKCdkZWZhdWx0Jyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBNb2R1bGUgJHtleHBvc2VkTW9kdWxlfSBjb3VsZCBub3QgYmUgbG9hZGVkLiBNb2R1bGUgRmVkZXJhdGlvbiBpcyBub3QgZW5hYmxlZCBpbiB0aGlzIGFwcGxpY2F0aW9uLmAsXG4gICAgICAgIGV4XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSB3aW5kb3dbcmVtb3RlTmFtZV0gYXMgQ29udGFpbmVyO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGFpbmVyLCBpdCBtYXkgcHJvdmlkZSBzaGFyZWQgbW9kdWxlc1xuICAgIGxldCBmYWN0b3J5OiBGYWN0b3J5O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb250YWluZXIuaW5pdChfX3dlYnBhY2tfc2hhcmVfc2NvcGVzX18uZGVmYXVsdCk7XG4gICAgICBmYWN0b3J5ID0gKGF3YWl0IGNvbnRhaW5lci5nZXQoZXhwb3NlZE1vZHVsZSkpKCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE1vZHVsZSAke2V4cG9zZWRNb2R1bGV9IGNvdWxkIG5vdCBiZSBsb2FkZWQuYCwgZXgpO1xuICAgIH1cbiAgICByZXR1cm4geyBuYW1lOiBleHBvc2VkTW9kdWxlLCBmYWN0b3J5IH07XG4gIH1cbn1cbiJdfQ==