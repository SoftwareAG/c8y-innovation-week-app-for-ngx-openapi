import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { distinctUntilChanged, shareReplay } from 'rxjs/operators';
import { fromTrigger, hookGeneric, getInjectedHooks, stateToFactory, ExtensionPointForPlugins } from '../common/extension-hooks';
import { PluginsResolveService } from '../plugins';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "../plugins";
/**
 * A hook to use for Multi Provider extension.
 * Consider using the `hookSearch` function instead.
 * @deprecated Please don't use the search factory. It will be refactored soon.
 */
export const HOOK_SEARCH = new InjectionToken('HOOK_SEARCH');
/**
 * You can either provide a single `Search` as parameter:
 * ```typescript
 *  hookSearch(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookSearch([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<Search>`
 * ```typescript
 *  export class MySearchFactory implements ExtensionFactory<Search> {...}
 *  ...
 *  hookSearch(MySearchFactory)
 * ```
 * A typed alternative to `HOOK_SEARCH`.
 * @param search The `Search`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 * @deprecated Please don't use the search factory. It will be refactored soon.
 */
export function hookSearch(search, options) {
    return hookGeneric(search, HOOK_SEARCH, options);
}
export var SearchFilters;
(function (SearchFilters) {
    SearchFilters["ONLY_DEVICES"] = "onlyDevices";
    SearchFilters["ONLY_GROUPS_AND_ASSETS"] = "onlyGroupsAndAssets";
    SearchFilters["ALL_FILTERS"] = "allFilters";
})(SearchFilters || (SearchFilters = {}));
/**
 * A service which defines the search function.
 */
export class SearchService extends ExtensionPointForPlugins {
    constructor(rootInjector, router, plugins) {
        super(rootInjector, plugins);
        this.router = router;
        this.items$ = this.setupItemsObservable();
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Adds a new item to the search in the header.
     * @param item The item to add.
     */
    add(item) {
        this.state.add(item);
        this.emitNewState();
    }
    /**
     * Removes an search from the header.
     * @param item The item to remove.
     */
    remove(item) {
        this.state.delete(item);
        this.emitNewState();
    }
    setupItemsObservable() {
        return fromTrigger(this.router, this.refresh$, [
            getInjectedHooks(HOOK_SEARCH, this.injectors),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(shareReplay(1), distinctUntilChanged());
    }
}
SearchService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SearchService, deps: [{ token: i0.Injector }, { token: i1.Router }, { token: i2.PluginsResolveService }], target: i0.ɵɵFactoryTarget.Injectable });
SearchService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SearchService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: SearchService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.Router }, { type: i2.PluginsResolveService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3NlYXJjaC9zZWFyY2guc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXpDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRSxPQUFPLEVBQ0wsV0FBVyxFQUVYLFdBQVcsRUFDWCxnQkFBZ0IsRUFDaEIsY0FBYyxFQUNkLHdCQUF3QixFQUV6QixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLFlBQVksQ0FBQzs7OztBQUduRDs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLElBQUksY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBRTdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkc7QUFDSCxNQUFNLFVBQVUsVUFBVSxDQUFDLE1BQStCLEVBQUUsT0FBOEI7SUFDeEYsT0FBTyxXQUFXLENBQVMsTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUMzRCxDQUFDO0FBRUQsTUFBTSxDQUFOLElBQVksYUFJWDtBQUpELFdBQVksYUFBYTtJQUN2Qiw2Q0FBNEIsQ0FBQTtJQUM1QiwrREFBOEMsQ0FBQTtJQUM5QywyQ0FBMEIsQ0FBQTtBQUM1QixDQUFDLEVBSlcsYUFBYSxLQUFiLGFBQWEsUUFJeEI7QUFFRDs7R0FFRztBQUlILE1BQU0sT0FBTyxhQUFjLFNBQVEsd0JBQWdDO0lBQ2pFLFlBQVksWUFBc0IsRUFBVSxNQUFjLEVBQUUsT0FBOEI7UUFDeEYsS0FBSyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztRQURhLFdBQU0sR0FBTixNQUFNLENBQVE7UUFFeEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILEdBQUcsQ0FBQyxJQUFZO1FBQ2QsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsSUFBWTtRQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVTLG9CQUFvQjtRQUM1QixPQUFPLFdBQVcsQ0FBUyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDckQsZ0JBQWdCLENBQVMsV0FBVyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDckQsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVM7WUFDcEIsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDNUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELENBQUM7OzBHQXZDVSxhQUFhOzhHQUFiLGFBQWEsY0FGWixNQUFNOzJGQUVQLGFBQWE7a0JBSHpCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIHNoYXJlUmVwbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgZnJvbVRyaWdnZXIsXG4gIEdlbmVyaWNIb29rVHlwZSxcbiAgaG9va0dlbmVyaWMsXG4gIGdldEluamVjdGVkSG9va3MsXG4gIHN0YXRlVG9GYWN0b3J5LFxuICBFeHRlbnNpb25Qb2ludEZvclBsdWdpbnMsXG4gIEhvb2tPcHRpb25zXG59IGZyb20gJy4uL2NvbW1vbi9leHRlbnNpb24taG9va3MnO1xuaW1wb3J0IHsgUGx1Z2luc1Jlc29sdmVTZXJ2aWNlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgeyBTZWFyY2ggfSBmcm9tICcuL3NlYXJjaC5tb2RlbCc7XG5cbi8qKlxuICogQSBob29rIHRvIHVzZSBmb3IgTXVsdGkgUHJvdmlkZXIgZXh0ZW5zaW9uLlxuICogQ29uc2lkZXIgdXNpbmcgdGhlIGBob29rU2VhcmNoYCBmdW5jdGlvbiBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIGRvbid0IHVzZSB0aGUgc2VhcmNoIGZhY3RvcnkuIEl0IHdpbGwgYmUgcmVmYWN0b3JlZCBzb29uLlxuICovXG5leHBvcnQgY29uc3QgSE9PS19TRUFSQ0ggPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0hPT0tfU0VBUkNIJyk7XG5cbi8qKlxuICogWW91IGNhbiBlaXRoZXIgcHJvdmlkZSBhIHNpbmdsZSBgU2VhcmNoYCBhcyBwYXJhbWV0ZXI6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgaG9va1NlYXJjaCguLi4pXG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBob29rU2VhcmNoKFsuLi5dKVxuICogYGBgXG4gKlxuICogT3IgeW91IHByb3ZpZGUgYW4gU2VydmljZSB0aGF0IGltcGxlbWVudHMgYEV4dGVuc2lvbkZhY3Rvcnk8U2VhcmNoPmBcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBleHBvcnQgY2xhc3MgTXlTZWFyY2hGYWN0b3J5IGltcGxlbWVudHMgRXh0ZW5zaW9uRmFjdG9yeTxTZWFyY2g+IHsuLi59XG4gKiAgLi4uXG4gKiAgaG9va1NlYXJjaChNeVNlYXJjaEZhY3RvcnkpXG4gKiBgYGBcbiAqIEEgdHlwZWQgYWx0ZXJuYXRpdmUgdG8gYEhPT0tfU0VBUkNIYC5cbiAqIEBwYXJhbSBzZWFyY2ggVGhlIGBTZWFyY2hgJ3Mgb3IgYEV4dGVuc2lvbkZhY3RvcnlgIHRvIGJlIHByb3ZpZGVkLlxuICogQHJldHVybnMgQW4gYFByb3ZpZGVyYCB0byBiZSBwcm92aWRlZCBpbiB5b3VyIG1vZHVsZS5cbiAqIEBkZXByZWNhdGVkIFBsZWFzZSBkb24ndCB1c2UgdGhlIHNlYXJjaCBmYWN0b3J5LiBJdCB3aWxsIGJlIHJlZmFjdG9yZWQgc29vbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhvb2tTZWFyY2goc2VhcmNoOiBHZW5lcmljSG9va1R5cGU8U2VhcmNoPiwgb3B0aW9ucz86IFBhcnRpYWw8SG9va09wdGlvbnM+KSB7XG4gIHJldHVybiBob29rR2VuZXJpYzxTZWFyY2g+KHNlYXJjaCwgSE9PS19TRUFSQ0gsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZW51bSBTZWFyY2hGaWx0ZXJzIHtcbiAgT05MWV9ERVZJQ0VTID0gJ29ubHlEZXZpY2VzJyxcbiAgT05MWV9HUk9VUFNfQU5EX0FTU0VUUyA9ICdvbmx5R3JvdXBzQW5kQXNzZXRzJyxcbiAgQUxMX0ZJTFRFUlMgPSAnYWxsRmlsdGVycydcbn1cblxuLyoqXG4gKiBBIHNlcnZpY2Ugd2hpY2ggZGVmaW5lcyB0aGUgc2VhcmNoIGZ1bmN0aW9uLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hTZXJ2aWNlIGV4dGVuZHMgRXh0ZW5zaW9uUG9pbnRGb3JQbHVnaW5zPFNlYXJjaD4ge1xuICBjb25zdHJ1Y3Rvcihyb290SW5qZWN0b3I6IEluamVjdG9yLCBwcml2YXRlIHJvdXRlcjogUm91dGVyLCBwbHVnaW5zOiBQbHVnaW5zUmVzb2x2ZVNlcnZpY2UpIHtcbiAgICBzdXBlcihyb290SW5qZWN0b3IsIHBsdWdpbnMpO1xuICAgIHRoaXMuaXRlbXMkID0gdGhpcy5zZXR1cEl0ZW1zT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXQgb2YgYWN0aW9ucy5cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBzZWFyY2ggaW4gdGhlIGhlYWRlci5cbiAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYWRkLlxuICAgKi9cbiAgYWRkKGl0ZW06IFNlYXJjaCkge1xuICAgIHRoaXMuc3RhdGUuYWRkKGl0ZW0pO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBzZWFyY2ggZnJvbSB0aGUgaGVhZGVyLlxuICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmUoaXRlbTogU2VhcmNoKSB7XG4gICAgdGhpcy5zdGF0ZS5kZWxldGUoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXR1cEl0ZW1zT2JzZXJ2YWJsZSgpOiBPYnNlcnZhYmxlPFNlYXJjaFtdPiB7XG4gICAgcmV0dXJuIGZyb21UcmlnZ2VyPFNlYXJjaD4odGhpcy5yb3V0ZXIsIHRoaXMucmVmcmVzaCQsIFtcbiAgICAgIGdldEluamVjdGVkSG9va3M8U2VhcmNoPihIT09LX1NFQVJDSCwgdGhpcy5pbmplY3RvcnMpLFxuICAgICAgKCkgPT4gdGhpcy5mYWN0b3JpZXMsXG4gICAgICBzdGF0ZVRvRmFjdG9yeSh0aGlzLnN0YXRlJClcbiAgICBdKS5waXBlKHNoYXJlUmVwbGF5KDEpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgfVxufVxuIl19