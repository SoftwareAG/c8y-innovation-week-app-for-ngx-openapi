import { Directionality } from '@angular/cdk/bidi';
import { CdkStepper, STEP_STATE } from '@angular/cdk/stepper';
import { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, forwardRef, Input, Output, QueryList } from '@angular/core';
import { Subject } from 'rxjs';
import { PRODUCT_EXPERIENCE_EVENT_SOURCE } from '../product-experience/product-experience.model';
import { C8yStepperIcon } from './stepper-icon.directive';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
import * as i2 from "@angular/common";
import * as i3 from "./stepper-progress.component";
import * as i4 from "../i18n/c8y-translate.pipe";
/**
 * C8yStepper extends the CdkStepper. You can use cdk based functionality and inputs.
 * Additional to that you are able to modify the behavior and also the look and feel when
 * using the C8yStepper.
 *
 * The C8yStepper is used to present any step-based process to the user.
 * A stepper, C8yStepper and/or CdkStepper is the parent of cdk-steps.
 * Each cdk-step represents one step in the whole process that you want to provide to the user.
 *
 * The C8yStepper will create, based on the given cdk-steps, a kind of stepper-progress which looks like this:
 * (1)---(2)---(3)---(n)
 * The stepper will handle the state of each step and provides styles for active steps, done-steps or in edit-mode.
 * You are able to override icons for each step in the stepper-progress with a template. You are also able to activate
 * default-icons for states like 'edit' and 'done'.
 *
 * To force users through every provided step, set the stepper to 'linear'.
 * This will disable the possibility to move for example from step one to step three.
 *
 * Whenever it comes to validation try to use formGroups. It is possible to
 * assign a formGroup to a cdk-step input called [stepControl], which automatically respects the
 * validation-rules that you created for this formGroup. If fields are required but not filled or
 * any other validation, like a pattern, is not matched the formGroup will be invalid. In this case
 * stepping in a linear stepper to the next step gets impossible.
 *
 * If there is the need to execute asynchronous code you have at least two possibilities.
 * First: As you learned, a cdk-step works with formGroups and Validators, so you are able to use
 * asyncValidators as well.
 * Second: The C8yStepper provides an event-emitter onStepChange which is called whenever a step-button (1)--(2)--(n)
 * in the stepper-progress is clicked. The event of this emitter holds the index of the step as number. You can
 * use this EventEmitter to call for example a custom navigate-method which performs first any async-call and then moves
 * on to the given step.
 *
 * @example
 * ```
 * <c8y-stepper
 * (onStepChange)="navigate($event)"
 * [disableDefaultIcons]="{ edit: true, done: false }"
 * [customClasses]="['m-l-40', 'm-r-40', 'm-t-32']"
 * linear
 * >
 * <!-- override icons -->
 * <ng-template c8yStepperIcon="final">
 *   <span [c8yIcon]="'hand-peace-o'"></span>
 * </ng-template>
 *
 * <cdk-step [stepControl]="formGroupStepOne" label="Name of the hero">
 *   <div class="m-l-40 m-r-40 m-t-32">
 *     <h4 class="p-b-8" translate>What is the name of your hero?</h4>
 *     <c8y-form-group>
 *      <div [formGroup]="formGroupStepOne">
 *       <input
 *         class="form-control"
 *         type="text"
 *         formControlName="name"
 *         placeholder="Mister X"
 *         #nameRef
 *         required
 *       />
 *       <c8y-messages>
 *         <c8y-message *ngIf="!formGroupStepOne.untouched && !nameRef.value" translate
 *           >Enter the name of the Superhero</c8y-message
 *         >
 *       </c8y-messages>
 *      </div>
 *     </c8y-form-group>
 *   </div>
 *   <c8y-stepper-buttons></c8y-stepper-buttons>
 * </cdk-step>
 * <cdk-step>
 *  ...
 * </cdk-step state="final">
 * </c8y-stepper>
 * ```
 */
export class C8yStepper extends CdkStepper {
    /**
     * @ignore
     */
    constructor(dir, changeDetectorRef, elementRef) {
        super(dir, changeDetectorRef, elementRef);
        this.dir = dir;
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        /**
         * Optional
         * Indicator if icons for edit and done state should be shown in step-header buttons
         */
        this.disableDefaultIcons = { edit: true, done: true };
        /**
         * Optional
         * Disable/enable navigation by stepper progress buttons
         * default: false
         */
        this.disableProgressButtons = false;
        /**
         * Optional
         * Possibility to hide the stepper progress completely.
         */
        this.hideStepProgress = false;
        /**
         * Optional
         * If `true`, the label defined on a cdk-step won't get rendered below each step-header button.
         * Instead, it will be used as a title only.
         */
        this.useStepLabelsAsTitlesOnly = false;
        /**
         * Will emit the step index number whenever a step-header button was clicked
         * It listens to the stepIndex Subject.
         */
        this.onStepChange = new EventEmitter();
        /** Consumer-specified template-refs to be used to override the header icons. */
        this._iconOverrides = {};
        this._stepIndex = new Subject();
    }
    /**
     * @ignore
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this._icons.forEach(({ name, templateRef }) => (this._iconOverrides[name] = templateRef));
        this._stepIndexSubscription = this._stepIndex.subscribe(index => this.onStepChange.emit(index));
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        if (this._stepIndexSubscription && !this._stepIndexSubscription.closed) {
            this._stepIndexSubscription.unsubscribe();
        }
    }
    /**
     * Manipulates the state based on the disabledDefaultIcons Input()
     * Changing edit or done to false will change the icons within step-header buttons
     * @param index step index
     * @param state step state, like 'done', 'edit', 'error'
     */
    getIndicatorType(index, state) {
        const stepState = this._getIndicatorType(index, state);
        let _state = state;
        switch (stepState) {
            case STEP_STATE.EDIT:
                if (!this.disableDefaultIcons.edit) {
                    _state = STEP_STATE.EDIT;
                }
                break;
            case STEP_STATE.DONE:
                if (!this.disableDefaultIcons.done) {
                    _state = STEP_STATE.DONE;
                }
                else {
                    _state = '_done';
                }
                break;
            case STEP_STATE.ERROR:
                _state = STEP_STATE.ERROR;
                break;
        }
        return _state;
    }
    /**
     * Pushes the step index to the subject
     * @param index step index
     */
    setIndex(index) {
        const steps = this.steps.toArray();
        if (!steps[this.selectedIndex]?.stepControl?.invalid || index < this.selectedIndex) {
            this.selectedIndex = index;
        }
    }
}
C8yStepper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: C8yStepper, deps: [{ token: i1.Directionality }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
C8yStepper.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: C8yStepper, selector: "c8y-stepper", inputs: { disableDefaultIcons: "disableDefaultIcons", disableProgressButtons: "disableProgressButtons", customClasses: "customClasses", hideStepProgress: "hideStepProgress", useStepLabelsAsTitlesOnly: "useStepLabelsAsTitlesOnly" }, outputs: { onStepChange: "onStepChange" }, providers: [
        { provide: CdkStepper, useExisting: C8yStepper },
        { provide: PRODUCT_EXPERIENCE_EVENT_SOURCE, useExisting: forwardRef(() => C8yStepper) }
    ], queries: [{ propertyName: "_icons", predicate: C8yStepperIcon, descendants: true }], usesInheritance: true, ngImport: i0, template: "<ul *ngIf=\"!hideStepProgress\" class=\"c8y-stepper\" [ngClass]=\"customClasses\">\n  <li *ngFor=\"let step of steps; let i = index\">\n    <c8y-stepper-progress\n      [iconOverrides]=\"_iconOverrides\"\n      [state]=\"getIndicatorType(i, step.state)\"\n      [index]=\"i\"\n      [selected]=\"selectedIndex === i\"\n      [disabled]=\"disableProgressButtons\"\n      (onStepClicked)=\"setIndex($event)\"\n      title=\"{{ step.label | translate }}\"\n      [ngClass]=\"{'active': selectedIndex === i}\"\n    >\n    </c8y-stepper-progress>\n    <div *ngIf=\"!useStepLabelsAsTitlesOnly\" class=\"c8y-step__label\"  title=\"{{ step.label | translate }}\">\n      {{ step.label | translate }}\n    </div>\n  </li>\n</ul>\n<ng-container [ngTemplateOutlet]=\"selected.content\"></ng-container>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i3.C8yStepperProgress, selector: "c8y-stepper-progress", inputs: ["iconOverrides", "index", "selected", "state", "disabled"], outputs: ["onStepClicked"] }, { kind: "pipe", type: i4.C8yTranslatePipe, name: "translate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: C8yStepper, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-stepper', providers: [
                        { provide: CdkStepper, useExisting: C8yStepper },
                        { provide: PRODUCT_EXPERIENCE_EVENT_SOURCE, useExisting: forwardRef(() => C8yStepper) }
                    ], template: "<ul *ngIf=\"!hideStepProgress\" class=\"c8y-stepper\" [ngClass]=\"customClasses\">\n  <li *ngFor=\"let step of steps; let i = index\">\n    <c8y-stepper-progress\n      [iconOverrides]=\"_iconOverrides\"\n      [state]=\"getIndicatorType(i, step.state)\"\n      [index]=\"i\"\n      [selected]=\"selectedIndex === i\"\n      [disabled]=\"disableProgressButtons\"\n      (onStepClicked)=\"setIndex($event)\"\n      title=\"{{ step.label | translate }}\"\n      [ngClass]=\"{'active': selectedIndex === i}\"\n    >\n    </c8y-stepper-progress>\n    <div *ngIf=\"!useStepLabelsAsTitlesOnly\" class=\"c8y-step__label\"  title=\"{{ step.label | translate }}\">\n      {{ step.label | translate }}\n    </div>\n  </li>\n</ul>\n<ng-container [ngTemplateOutlet]=\"selected.content\"></ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: i1.Directionality }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { disableDefaultIcons: [{
                type: Input
            }], disableProgressButtons: [{
                type: Input
            }], customClasses: [{
                type: Input
            }], hideStepProgress: [{
                type: Input
            }], useStepLabelsAsTitlesOnly: [{
                type: Input
            }], onStepChange: [{
                type: Output
            }], _icons: [{
                type: ContentChildren,
                args: [C8yStepperIcon, { descendants: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3N0ZXBwZXIvc3RlcHBlci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9jb3JlL3N0ZXBwZXIvc3RlcHBlci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbkQsT0FBTyxFQUFFLFVBQVUsRUFBYSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN6RSxPQUFPLEVBRUwsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixVQUFVLEVBQ1YsS0FBSyxFQUVMLE1BQU0sRUFDTixTQUFTLEVBRVYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUdMLCtCQUErQixFQUNoQyxNQUFNLGdEQUFnRCxDQUFDO0FBQ3hELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7O0FBRTFEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUVHO0FBU0gsTUFBTSxPQUFPLFVBQ1gsU0FBUSxVQUFVO0lBd0VsQjs7T0FFRztJQUNILFlBQ1UsR0FBbUIsRUFDbkIsaUJBQW9DLEVBQ3BDLFVBQW9DO1FBRTVDLEtBQUssQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFKbEMsUUFBRyxHQUFILEdBQUcsQ0FBZ0I7UUFDbkIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxlQUFVLEdBQVYsVUFBVSxDQUEwQjtRQTNFOUM7OztXQUdHO1FBQ00sd0JBQW1CLEdBQXNDLEVBQUUsSUFBSSxFQUFF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RmEsVUFBVTtrQkFSdEIsU0FBUzsrQkFDRSxhQUFhLGFBRVo7d0JBQ1QsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsWUFBWSxFQUFFO3dCQUNoRCxFQUFFLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsRUFBRTtxQkFDeEY7OEpBVVEsbUJBQW1CO3NCQUEzQixLQUFLO2dCQU1HLHNCQUFzQjtzQkFBOUIsS0FBSztnQkFLRyxhQUFhO3NCQUFyQixLQUFLO2dCQUtHLGdCQUFnQjtzQkFBeEIsS0FBSztnQkFNRyx5QkFBeUI7c0JBQWpDLEtBQUs7Z0JBS0ksWUFBWTtzQkFBckIsTUFBTTtnQkE0QmlELE1BQU07c0JBQTdELGVBQWU7dUJBQUMsY0FBYyxFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgQ2RrU3RlcHBlciwgU3RlcFN0YXRlLCBTVEVQX1NUQVRFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3N0ZXBwZXInO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIGZvcndhcmRSZWYsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgUHJvZHVjdEV4cGVyaWVuY2VFdmVudCxcbiAgUHJvZHVjdEV4cGVyaWVuY2VFdmVudFNvdXJjZSxcbiAgUFJPRFVDVF9FWFBFUklFTkNFX0VWRU5UX1NPVVJDRVxufSBmcm9tICcuLi9wcm9kdWN0LWV4cGVyaWVuY2UvcHJvZHVjdC1leHBlcmllbmNlLm1vZGVsJztcbmltcG9ydCB7IEM4eVN0ZXBwZXJJY29uIH0gZnJvbSAnLi9zdGVwcGVyLWljb24uZGlyZWN0aXZlJztcblxuLyoqXG4gKiBDOHlTdGVwcGVyIGV4dGVuZHMgdGhlIENka1N0ZXBwZXIuIFlvdSBjYW4gdXNlIGNkayBiYXNlZCBmdW5jdGlvbmFsaXR5IGFuZCBpbnB1dHMuXG4gKiBBZGRpdGlvbmFsIHRvIHRoYXQgeW91IGFyZSBhYmxlIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3IgYW5kIGFsc28gdGhlIGxvb2sgYW5kIGZlZWwgd2hlblxuICogdXNpbmcgdGhlIEM4eVN0ZXBwZXIuXG4gKlxuICogVGhlIEM4eVN0ZXBwZXIgaXMgdXNlZCB0byBwcmVzZW50IGFueSBzdGVwLWJhc2VkIHByb2Nlc3MgdG8gdGhlIHVzZXIuXG4gKiBBIHN0ZXBwZXIsIEM4eVN0ZXBwZXIgYW5kL29yIENka1N0ZXBwZXIgaXMgdGhlIHBhcmVudCBvZiBjZGstc3RlcHMuXG4gKiBFYWNoIGNkay1zdGVwIHJlcHJlc2VudHMgb25lIHN0ZXAgaW4gdGhlIHdob2xlIHByb2Nlc3MgdGhhdCB5b3Ugd2FudCB0byBwcm92aWRlIHRvIHRoZSB1c2VyLlxuICpcbiAqIFRoZSBDOHlTdGVwcGVyIHdpbGwgY3JlYXRlLCBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2RrLXN0ZXBzLCBhIGtpbmQgb2Ygc3RlcHBlci1wcm9ncmVzcyB3aGljaCBsb29rcyBsaWtlIHRoaXM6XG4gKiAoMSktLS0oMiktLS0oMyktLS0obilcbiAqIFRoZSBzdGVwcGVyIHdpbGwgaGFuZGxlIHRoZSBzdGF0ZSBvZiBlYWNoIHN0ZXAgYW5kIHByb3ZpZGVzIHN0eWxlcyBmb3IgYWN0aXZlIHN0ZXBzLCBkb25lLXN0ZXBzIG9yIGluIGVkaXQtbW9kZS5cbiAqIFlvdSBhcmUgYWJsZSB0byBvdmVycmlkZSBpY29ucyBmb3IgZWFjaCBzdGVwIGluIHRoZSBzdGVwcGVyLXByb2dyZXNzIHdpdGggYSB0ZW1wbGF0ZS4gWW91IGFyZSBhbHNvIGFibGUgdG8gYWN0aXZhdGVcbiAqIGRlZmF1bHQtaWNvbnMgZm9yIHN0YXRlcyBsaWtlICdlZGl0JyBhbmQgJ2RvbmUnLlxuICpcbiAqIFRvIGZvcmNlIHVzZXJzIHRocm91Z2ggZXZlcnkgcHJvdmlkZWQgc3RlcCwgc2V0IHRoZSBzdGVwcGVyIHRvICdsaW5lYXInLlxuICogVGhpcyB3aWxsIGRpc2FibGUgdGhlIHBvc3NpYmlsaXR5IHRvIG1vdmUgZm9yIGV4YW1wbGUgZnJvbSBzdGVwIG9uZSB0byBzdGVwIHRocmVlLlxuICpcbiAqIFdoZW5ldmVyIGl0IGNvbWVzIHRvIHZhbGlkYXRpb24gdHJ5IHRvIHVzZSBmb3JtR3JvdXBzLiBJdCBpcyBwb3NzaWJsZSB0b1xuICogYXNzaWduIGEgZm9ybUdyb3VwIHRvIGEgY2RrLXN0ZXAgaW5wdXQgY2FsbGVkIFtzdGVwQ29udHJvbF0sIHdoaWNoIGF1dG9tYXRpY2FsbHkgcmVzcGVjdHMgdGhlXG4gKiB2YWxpZGF0aW9uLXJ1bGVzIHRoYXQgeW91IGNyZWF0ZWQgZm9yIHRoaXMgZm9ybUdyb3VwLiBJZiBmaWVsZHMgYXJlIHJlcXVpcmVkIGJ1dCBub3QgZmlsbGVkIG9yXG4gKiBhbnkgb3RoZXIgdmFsaWRhdGlvbiwgbGlrZSBhIHBhdHRlcm4sIGlzIG5vdCBtYXRjaGVkIHRoZSBmb3JtR3JvdXAgd2lsbCBiZSBpbnZhbGlkLiBJbiB0aGlzIGNhc2VcbiAqIHN0ZXBwaW5nIGluIGEgbGluZWFyIHN0ZXBwZXIgdG8gdGhlIG5leHQgc3RlcCBnZXRzIGltcG9zc2libGUuXG4gKlxuICogSWYgdGhlcmUgaXMgdGhlIG5lZWQgdG8gZXhlY3V0ZSBhc3luY2hyb25vdXMgY29kZSB5b3UgaGF2ZSBhdCBsZWFzdCB0d28gcG9zc2liaWxpdGllcy5cbiAqIEZpcnN0OiBBcyB5b3UgbGVhcm5lZCwgYSBjZGstc3RlcCB3b3JrcyB3aXRoIGZvcm1Hcm91cHMgYW5kIFZhbGlkYXRvcnMsIHNvIHlvdSBhcmUgYWJsZSB0byB1c2VcbiAqIGFzeW5jVmFsaWRhdG9ycyBhcyB3ZWxsLlxuICogU2Vjb25kOiBUaGUgQzh5U3RlcHBlciBwcm92aWRlcyBhbiBldmVudC1lbWl0dGVyIG9uU3RlcENoYW5nZSB3aGljaCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBzdGVwLWJ1dHRvbiAoMSktLSgyKS0tKG4pXG4gKiBpbiB0aGUgc3RlcHBlci1wcm9ncmVzcyBpcyBjbGlja2VkLiBUaGUgZXZlbnQgb2YgdGhpcyBlbWl0dGVyIGhvbGRzIHRoZSBpbmRleCBvZiB0aGUgc3RlcCBhcyBudW1iZXIuIFlvdSBjYW5cbiAqIHVzZSB0aGlzIEV2ZW50RW1pdHRlciB0byBjYWxsIGZvciBleGFtcGxlIGEgY3VzdG9tIG5hdmlnYXRlLW1ldGhvZCB3aGljaCBwZXJmb3JtcyBmaXJzdCBhbnkgYXN5bmMtY2FsbCBhbmQgdGhlbiBtb3Zlc1xuICogb24gdG8gdGhlIGdpdmVuIHN0ZXAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogPGM4eS1zdGVwcGVyXG4gKiAob25TdGVwQ2hhbmdlKT1cIm5hdmlnYXRlKCRldmVudClcIlxuICogW2Rpc2FibGVEZWZhdWx0SWNvbnNdPVwieyBlZGl0OiB0cnVlLCBkb25lOiBmYWxzZSB9XCJcbiAqIFtjdXN0b21DbGFzc2VzXT1cIlsnbS1sLTQwJywgJ20tci00MCcsICdtLXQtMzInXVwiXG4gKiBsaW5lYXJcbiAqID5cbiAqIDwhLS0gb3ZlcnJpZGUgaWNvbnMgLS0+XG4gKiA8bmctdGVtcGxhdGUgYzh5U3RlcHBlckljb249XCJmaW5hbFwiPlxuICogICA8c3BhbiBbYzh5SWNvbl09XCInaGFuZC1wZWFjZS1vJ1wiPjwvc3Bhbj5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKlxuICogPGNkay1zdGVwIFtzdGVwQ29udHJvbF09XCJmb3JtR3JvdXBTdGVwT25lXCIgbGFiZWw9XCJOYW1lIG9mIHRoZSBoZXJvXCI+XG4gKiAgIDxkaXYgY2xhc3M9XCJtLWwtNDAgbS1yLTQwIG0tdC0zMlwiPlxuICogICAgIDxoNCBjbGFzcz1cInAtYi04XCIgdHJhbnNsYXRlPldoYXQgaXMgdGhlIG5hbWUgb2YgeW91ciBoZXJvPzwvaDQ+XG4gKiAgICAgPGM4eS1mb3JtLWdyb3VwPlxuICogICAgICA8ZGl2IFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwU3RlcE9uZVwiPlxuICogICAgICAgPGlucHV0XG4gKiAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAqICAgICAgICAgdHlwZT1cInRleHRcIlxuICogICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJuYW1lXCJcbiAqICAgICAgICAgcGxhY2Vob2xkZXI9XCJNaXN0ZXIgWFwiXG4gKiAgICAgICAgICNuYW1lUmVmXG4gKiAgICAgICAgIHJlcXVpcmVkXG4gKiAgICAgICAvPlxuICogICAgICAgPGM4eS1tZXNzYWdlcz5cbiAqICAgICAgICAgPGM4eS1tZXNzYWdlICpuZ0lmPVwiIWZvcm1Hcm91cFN0ZXBPbmUudW50b3VjaGVkICYmICFuYW1lUmVmLnZhbHVlXCIgdHJhbnNsYXRlXG4gKiAgICAgICAgICAgPkVudGVyIHRoZSBuYW1lIG9mIHRoZSBTdXBlcmhlcm88L2M4eS1tZXNzYWdlXG4gKiAgICAgICAgID5cbiAqICAgICAgIDwvYzh5LW1lc3NhZ2VzPlxuICogICAgICA8L2Rpdj5cbiAqICAgICA8L2M4eS1mb3JtLWdyb3VwPlxuICogICA8L2Rpdj5cbiAqICAgPGM4eS1zdGVwcGVyLWJ1dHRvbnM+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICogPC9jZGstc3RlcD5cbiAqIDxjZGstc3RlcD5cbiAqICAuLi5cbiAqIDwvY2RrLXN0ZXAgc3RhdGU9XCJmaW5hbFwiPlxuICogPC9jOHktc3RlcHBlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjOHktc3RlcHBlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9zdGVwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAgeyBwcm92aWRlOiBDZGtTdGVwcGVyLCB1c2VFeGlzdGluZzogQzh5U3RlcHBlciB9LFxuICAgIHsgcHJvdmlkZTogUFJPRFVDVF9FWFBFUklFTkNFX0VWRU5UX1NPVVJDRSwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQzh5U3RlcHBlcikgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIEM4eVN0ZXBwZXJcbiAgZXh0ZW5kcyBDZGtTdGVwcGVyXG4gIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBQcm9kdWN0RXhwZXJpZW5jZUV2ZW50U291cmNlXG57XG4gIC8qKlxuICAgKiBPcHRpb25hbFxuICAgKiBJbmRpY2F0b3IgaWYgaWNvbnMgZm9yIGVkaXQgYW5kIGRvbmUgc3RhdGUgc2hvdWxkIGJlIHNob3duIGluIHN0ZXAtaGVhZGVyIGJ1dHRvbnNcbiAgICovXG4gIEBJbnB1dCgpIGRpc2FibGVEZWZhdWx0SWNvbnM/OiB7IGVkaXQ6IGJvb2xlYW47IGRvbmU6IGJvb2xlYW4gfSA9IHsgZWRpdDogdHJ1ZSwgZG9uZTogdHJ1ZSB9O1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogRGlzYWJsZS9lbmFibGUgbmF2aWdhdGlvbiBieSBzdGVwcGVyIHByb2dyZXNzIGJ1dHRvbnNcbiAgICogZGVmYXVsdDogZmFsc2VcbiAgICovXG4gIEBJbnB1dCgpIGRpc2FibGVQcm9ncmVzc0J1dHRvbnM/OiBib29sZWFuID0gZmFsc2U7XG4gIC8qKlxuICAgKiBPcHRpb25hbFxuICAgKiBQb3NzaWJpbGl0eSB0byBhZGQgYW55IGtpbmQgb2YgY3VzdG9tIGNzcyBjbGFzc2VzIHRvIHRoZSBzdGVwLWhlYWRlclxuICAgKi9cbiAgQElucHV0KCkgY3VzdG9tQ2xhc3Nlcz86IHN0cmluZ1tdO1xuICAvKipcbiAgICogT3B0aW9uYWxcbiAgICogUG9zc2liaWxpdHkgdG8gaGlkZSB0aGUgc3RlcHBlciBwcm9ncmVzcyBjb21wbGV0ZWx5LlxuICAgKi9cbiAgQElucHV0KCkgaGlkZVN0ZXBQcm9ncmVzcz86IGJvb2xlYW4gPSBmYWxzZTtcbiAgLyoqXG4gICAqIE9wdGlvbmFsXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIGRlZmluZWQgb24gYSBjZGstc3RlcCB3b24ndCBnZXQgcmVuZGVyZWQgYmVsb3cgZWFjaCBzdGVwLWhlYWRlciBidXR0b24uXG4gICAqIEluc3RlYWQsIGl0IHdpbGwgYmUgdXNlZCBhcyBhIHRpdGxlIG9ubHkuXG4gICAqL1xuICBASW5wdXQoKSB1c2VTdGVwTGFiZWxzQXNUaXRsZXNPbmx5PzogYm9vbGVhbiA9IGZhbHNlO1xuICAvKipcbiAgICogV2lsbCBlbWl0IHRoZSBzdGVwIGluZGV4IG51bWJlciB3aGVuZXZlciBhIHN0ZXAtaGVhZGVyIGJ1dHRvbiB3YXMgY2xpY2tlZFxuICAgKiBJdCBsaXN0ZW5zIHRvIHRoZSBzdGVwSW5kZXggU3ViamVjdC5cbiAgICovXG4gIEBPdXRwdXQoKSBvblN0ZXBDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAvKipcbiAgICogSG9sZGluZyBhIFF1ZXJ5TGlzdCBvZiBDOHlTdGVwcGVySWNvbnNcbiAgICogVGhlc2UgYXJlIHRlbXBsYXRlUmVmcyB3aGljaCBvdmVycmlkZXMgYW55IHN0ZXAtaGVhZGVyIGJ1dHRvbiBpY29uIHdpdGggbWF0Y2hpbmcgc3RhdGUgb2YgY2RrLXN0ZXBcbiAgICpcbiAgICogQGV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiA8IS0tIG92ZXJyaWRlIGljb25zIC0tPlxuICAgKiAgPG5nLXRlbXBsYXRlIGM4eVN0ZXBwZXJJY29uPVwiZmluYWxcIj5cbiAgICogICA8c3BhbiBbYzh5SWNvbl09XCInaGFuZC1wZWFjZS1vJ1wiPjwvc3Bhbj5cbiAgICogIDwvbmctdGVtcGxhdGU+XG4gICAqXG4gICAqIDxjZGstc3RlcCBzdGF0ZT1cImZpbmFsXCIgbGFiZWw9XCJKb2IgZG9uZSFcIj5cbiAgICogIDxkaXYgY2xhc3M9XCJtLWwtNDAgbS1yLTQwIG0tdC0zMlwiPlxuICAgKiAgICA8aDQgY2xhc3M9XCJwLWItMzJcIiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjtcIiB0cmFuc2xhdGU+XG4gICAqICAgICBZb3VyIFN1cGVyaGVybyBpcyBub3cgcmVhZHkgdG8gc2F2ZSB0aGUgd29ybGQhXG4gICAqICAgPC9oND5cbiAgICogIDwvZGl2PlxuICAgKiAgPGM4eS1zdGVwcGVyLWJ1dHRvbnNcbiAgICogICAgW2hpZGRlbl09XCIhaXNNb2RhbFwiXG4gICAqICAgIChvbkJhY2spPVwiY2xvc2UoKVwiXG4gICAqICAgIFtsYWJlbHNdPVwieyBiYWNrOiAnR290IGl0IScgfVwiXG4gICAqICA+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICAgKiAgPGM4eS1zdGVwcGVyLWJ1dHRvbnMgW2hpZGRlbl09XCJpc01vZGFsXCI+PC9jOHktc3RlcHBlci1idXR0b25zPlxuICAgKiA8L2Nkay1zdGVwPlxuICAgKiBgYGBcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQzh5U3RlcHBlckljb24sIHsgZGVzY2VuZGFudHM6IHRydWUgfSkgX2ljb25zOiBRdWVyeUxpc3Q8Qzh5U3RlcHBlckljb24+O1xuXG4gIC8qKiBDb25zdW1lci1zcGVjaWZpZWQgdGVtcGxhdGUtcmVmcyB0byBiZSB1c2VkIHRvIG92ZXJyaWRlIHRoZSBoZWFkZXIgaWNvbnMuICovXG4gIF9pY29uT3ZlcnJpZGVzOiB7IFtrZXk6IHN0cmluZ106IFRlbXBsYXRlUmVmPGFueT4gfSA9IHt9O1xuXG4gIHByb2R1Y3RFeHBlcmllbmNlRXZlbnQ6IFByb2R1Y3RFeHBlcmllbmNlRXZlbnQ7XG5cbiAgcHJpdmF0ZSBfc3RlcEluZGV4OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIF9zdGVwSW5kZXhTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbmFsaXR5LFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZj86IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+XG4gICkge1xuICAgIHN1cGVyKGRpciwgY2hhbmdlRGV0ZWN0b3JSZWYsIGVsZW1lbnRSZWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh7IG5hbWUsIHRlbXBsYXRlUmVmIH0pID0+ICh0aGlzLl9pY29uT3ZlcnJpZGVzW25hbWVdID0gdGVtcGxhdGVSZWYpKTtcbiAgICB0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24gPSB0aGlzLl9zdGVwSW5kZXguc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMub25TdGVwQ2hhbmdlLmVtaXQoaW5kZXgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fc3RlcEluZGV4U3Vic2NyaXB0aW9uICYmICF0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICB0aGlzLl9zdGVwSW5kZXhTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFuaXB1bGF0ZXMgdGhlIHN0YXRlIGJhc2VkIG9uIHRoZSBkaXNhYmxlZERlZmF1bHRJY29ucyBJbnB1dCgpXG4gICAqIENoYW5naW5nIGVkaXQgb3IgZG9uZSB0byBmYWxzZSB3aWxsIGNoYW5nZSB0aGUgaWNvbnMgd2l0aGluIHN0ZXAtaGVhZGVyIGJ1dHRvbnNcbiAgICogQHBhcmFtIGluZGV4IHN0ZXAgaW5kZXhcbiAgICogQHBhcmFtIHN0YXRlIHN0ZXAgc3RhdGUsIGxpa2UgJ2RvbmUnLCAnZWRpdCcsICdlcnJvcidcbiAgICovXG4gIGdldEluZGljYXRvclR5cGUoaW5kZXg6IG51bWJlciwgc3RhdGU6IFN0ZXBTdGF0ZSkge1xuICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IHRoaXMuX2dldEluZGljYXRvclR5cGUoaW5kZXgsIHN0YXRlKTtcbiAgICBsZXQgX3N0YXRlID0gc3RhdGU7XG4gICAgc3dpdGNoIChzdGVwU3RhdGUpIHtcbiAgICAgIGNhc2UgU1RFUF9TVEFURS5FRElUOlxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZURlZmF1bHRJY29ucy5lZGl0KSB7XG4gICAgICAgICAgX3N0YXRlID0gU1RFUF9TVEFURS5FRElUO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNURVBfU1RBVEUuRE9ORTpcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVEZWZhdWx0SWNvbnMuZG9uZSkge1xuICAgICAgICAgIF9zdGF0ZSA9IFNURVBfU1RBVEUuRE9ORTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3RhdGUgPSAnX2RvbmUnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNURVBfU1RBVEUuRVJST1I6XG4gICAgICAgIF9zdGF0ZSA9IFNURVBfU1RBVEUuRVJST1I7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hlcyB0aGUgc3RlcCBpbmRleCB0byB0aGUgc3ViamVjdFxuICAgKiBAcGFyYW0gaW5kZXggc3RlcCBpbmRleFxuICAgKi9cbiAgc2V0SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHN0ZXBzID0gdGhpcy5zdGVwcy50b0FycmF5KCk7XG4gICAgaWYgKCFzdGVwc1t0aGlzLnNlbGVjdGVkSW5kZXhdPy5zdGVwQ29udHJvbD8uaW52YWxpZCB8fCBpbmRleCA8IHRoaXMuc2VsZWN0ZWRJbmRleCkge1xuICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9XG59XG4iLCI8dWwgKm5nSWY9XCIhaGlkZVN0ZXBQcm9ncmVzc1wiIGNsYXNzPVwiYzh5LXN0ZXBwZXJcIiBbbmdDbGFzc109XCJjdXN0b21DbGFzc2VzXCI+XG4gIDxsaSAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGkgPSBpbmRleFwiPlxuICAgIDxjOHktc3RlcHBlci1wcm9ncmVzc1xuICAgICAgW2ljb25PdmVycmlkZXNdPVwiX2ljb25PdmVycmlkZXNcIlxuICAgICAgW3N0YXRlXT1cImdldEluZGljYXRvclR5cGUoaSwgc3RlcC5zdGF0ZSlcIlxuICAgICAgW2luZGV4XT1cImlcIlxuICAgICAgW3NlbGVjdGVkXT1cInNlbGVjdGVkSW5kZXggPT09IGlcIlxuICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVQcm9ncmVzc0J1dHRvbnNcIlxuICAgICAgKG9uU3RlcENsaWNrZWQpPVwic2V0SW5kZXgoJGV2ZW50KVwiXG4gICAgICB0aXRsZT1cInt7IHN0ZXAubGFiZWwgfCB0cmFuc2xhdGUgfX1cIlxuICAgICAgW25nQ2xhc3NdPVwieydhY3RpdmUnOiBzZWxlY3RlZEluZGV4ID09PSBpfVwiXG4gICAgPlxuICAgIDwvYzh5LXN0ZXBwZXItcHJvZ3Jlc3M+XG4gICAgPGRpdiAqbmdJZj1cIiF1c2VTdGVwTGFiZWxzQXNUaXRsZXNPbmx5XCIgY2xhc3M9XCJjOHktc3RlcF9fbGFiZWxcIiAgdGl0bGU9XCJ7eyBzdGVwLmxhYmVsIHwgdHJhbnNsYXRlIH19XCI+XG4gICAgICB7eyBzdGVwLmxhYmVsIHwgdHJhbnNsYXRlIH19XG4gICAgPC9kaXY+XG4gIDwvbGk+XG48L3VsPlxuPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJzZWxlY3RlZC5jb250ZW50XCI+PC9uZy1jb250YWluZXI+XG4iXX0=