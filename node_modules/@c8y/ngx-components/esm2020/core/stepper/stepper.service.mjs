import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { TranslateService } from '@ngx-translate/core';
import { distinctUntilChanged, filter, map, shareReplay, take } from 'rxjs/operators';
import { fromTrigger, hookGeneric, getInjectedHooks, stateToFactory, ExtensionPointForPlugins } from '../common/extension-hooks';
import { PluginsResolveService } from '../plugins';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@ngx-translate/core";
import * as i3 from "../plugins";
/**
 * A hook to use for Multi Provider extension.
 * @deprecated Consider using the `hookStepper` function instead.
 */
export const HOOK_STEPPER = new InjectionToken('HOOK_STEPPER');
/**
 * You can either provide a single `Step` as parameter:
 * ```typescript
 *  hookStepper(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookStepper([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<Step>`
 * ```typescript
 *  export class MyStepFactory implements ExtensionFactory<Step> {...}
 *  ...
 *  hookStepper(MyStepFactory)
 * ```
 * A typed alternative to `HOOK_STEPPER`.
 * @param step The `Step`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookStepper(step, options) {
    return hookGeneric(step, HOOK_STEPPER, options);
}
/**
 * A service which defines the steps in a stepper component.
 * A stepper hook needs an certain outlet which has an matching id
 * to display the steps.
 */
export class StepperService extends ExtensionPointForPlugins {
    constructor(rootInjector, router, translateService, plugins) {
        super(rootInjector, plugins);
        this.router = router;
        this.translateService = translateService;
        this.items$ = this.setupItemsObservable();
    }
    sortSteps(steps) {
        return steps.sort((a, b) => {
            const priorityOrder = (b.priority || 0) - (a.priority || 0);
            const aTranslatedLabel = this.translateService.instant(a.label);
            const bTranslatedLabel = this.translateService.instant(b.label);
            const translatedLabelOrder = aTranslatedLabel.localeCompare(bTranslatedLabel);
            return priorityOrder || translatedLabelOrder;
        });
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Adds a new item to tabs and emits state change
     * @param item The item to add.
     */
    add(item) {
        this.state.add(item);
        this.emitNewState();
    }
    /**
     * Removes a step and emits a state change.
     * @param item The item to remove.
     */
    remove(item) {
        this.state.delete(item);
        this.emitNewState();
    }
    /**
     * Returns the component by it's asssigned stepper id as an observable.
     * @param id The id of the stepper to hook into.
     */
    getById$(id) {
        return this.items$.pipe(filter(steps => steps.length > 0), map(steps => steps.filter(cmp => cmp.stepperId === id)), take(1));
    }
    setupItemsObservable() {
        return fromTrigger(this.router, this.refresh$, [
            getInjectedHooks(HOOK_STEPPER, this.injectors),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(distinctUntilChanged(), shareReplay(1));
    }
}
StepperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StepperService, deps: [{ token: i0.Injector }, { token: i1.Router }, { token: i2.TranslateService }, { token: i3.PluginsResolveService }], target: i0.ɵɵFactoryTarget.Injectable });
StepperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StepperService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: StepperService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.Router }, { type: i2.TranslateService }, { type: i3.PluginsResolveService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9zdGVwcGVyL3N0ZXBwZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXZELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0RixPQUFPLEVBRUwsV0FBVyxFQUVYLFdBQVcsRUFDWCxnQkFBZ0IsRUFDaEIsY0FBYyxFQUNkLHdCQUF3QixFQUV6QixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLFlBQVksQ0FBQzs7Ozs7QUF1Qm5EOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBcUIsY0FBYyxDQUFDLENBQUM7QUFFbkY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxJQUEyQixFQUFFLE9BQThCO0lBQ3JGLE9BQU8sV0FBVyxDQUFPLElBQUksRUFBRSxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUVEOzs7O0dBSUc7QUFJSCxNQUFNLE9BQU8sY0FBZSxTQUFRLHdCQUE4QjtJQUNoRSxZQUNFLFlBQXNCLEVBQ2QsTUFBYyxFQUNkLGdCQUFrQyxFQUMxQyxPQUE4QjtRQUU5QixLQUFLLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBSnJCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBSTFDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFDNUMsQ0FBQztJQUVELFNBQVMsQ0FBQyxLQUFhO1FBQ3JCLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN6QixNQUFNLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRTVELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDaEUsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoRSxNQUFNLG9CQUFvQixHQUFHLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBRTlFLE9BQU8sYUFBYSxJQUFJLG9CQUFvQixDQUFDO1FBQy9DLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxHQUFHLENBQUMsSUFBVTtRQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLElBQVU7UUFDZixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDckIsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFDakMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEtBQUssRUFBRSxDQUFDLENBQUMsRUFDdkQsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNSLENBQUM7SUFDSixDQUFDO0lBRVMsb0JBQW9CO1FBQzVCLE9BQU8sV0FBVyxDQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNuRCxnQkFBZ0IsQ0FBTyxZQUFZLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUNwRCxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUztZQUNwQixjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUM1QixDQUFDLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQzs7MkdBcEVVLGNBQWM7K0dBQWQsY0FBYyxjQUZiLE1BQU07MkZBRVAsY0FBYztrQkFIMUIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAsIHNoYXJlUmVwbGF5LCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRXh0ZW5zaW9uRmFjdG9yeSxcbiAgZnJvbVRyaWdnZXIsXG4gIEdlbmVyaWNIb29rVHlwZSxcbiAgaG9va0dlbmVyaWMsXG4gIGdldEluamVjdGVkSG9va3MsXG4gIHN0YXRlVG9GYWN0b3J5LFxuICBFeHRlbnNpb25Qb2ludEZvclBsdWdpbnMsXG4gIEhvb2tPcHRpb25zXG59IGZyb20gJy4uL2NvbW1vbi9leHRlbnNpb24taG9va3MnO1xuaW1wb3J0IHsgUGx1Z2luc1Jlc29sdmVTZXJ2aWNlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgeyBTdGVwIH0gZnJvbSAnLi9zdGVwcGVyLm1vZGVsJztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gSE9PSyBjYW4gdXNlIGVpdGhlciBhIHB1cmUgdmFsdWU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiB7IC4uLmhvb2tWYWx1ZSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IFt7IC4uLmhvb2tWYWx1ZXMgfV0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIEV4dGVuc2lvbkZhY3Rvcnkgd2hpY2ggYWxsb3dzIHRvIGRlZmluZSBhIGdldCgpIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBnZXRzIGNhbGxlZCBvbiBlYWNoIG5hdmlnYXRpb24gd2l0aCB0aGUgY3VycmVudCByb3V0ZSBhbmQgY2FuIHJldHVybiB2YWx1ZXNcbiAqIGFzeW5jIChvYnNlcnZhYmxlIG9yIHByb21pc2UpLlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VGYWN0b3J5OiB7IGdldDogKHJvdXRlKSA9PiBkb1NvbWV0aGluZ0FzeW5jKHJvdXRlKSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgU3RlcHBlckV4dGVuc2lvbiA9IFN0ZXAgfCBTdGVwW10gfCBFeHRlbnNpb25GYWN0b3J5PFN0ZXA+O1xuXG4vKipcbiAqIEEgaG9vayB0byB1c2UgZm9yIE11bHRpIFByb3ZpZGVyIGV4dGVuc2lvbi5cbiAqIEBkZXByZWNhdGVkIENvbnNpZGVyIHVzaW5nIHRoZSBgaG9va1N0ZXBwZXJgIGZ1bmN0aW9uIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBIT09LX1NURVBQRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW48U3RlcHBlckV4dGVuc2lvbltdPignSE9PS19TVEVQUEVSJyk7XG5cbi8qKlxuICogWW91IGNhbiBlaXRoZXIgcHJvdmlkZSBhIHNpbmdsZSBgU3RlcGAgYXMgcGFyYW1ldGVyOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tTdGVwcGVyKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tTdGVwcGVyKFsuLi5dKVxuICogYGBgXG4gKlxuICogT3IgeW91IHByb3ZpZGUgYW4gU2VydmljZSB0aGF0IGltcGxlbWVudHMgYEV4dGVuc2lvbkZhY3Rvcnk8U3RlcD5gXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgZXhwb3J0IGNsYXNzIE15U3RlcEZhY3RvcnkgaW1wbGVtZW50cyBFeHRlbnNpb25GYWN0b3J5PFN0ZXA+IHsuLi59XG4gKiAgLi4uXG4gKiAgaG9va1N0ZXBwZXIoTXlTdGVwRmFjdG9yeSlcbiAqIGBgYFxuICogQSB0eXBlZCBhbHRlcm5hdGl2ZSB0byBgSE9PS19TVEVQUEVSYC5cbiAqIEBwYXJhbSBzdGVwIFRoZSBgU3RlcGAncyBvciBgRXh0ZW5zaW9uRmFjdG9yeWAgdG8gYmUgcHJvdmlkZWQuXG4gKiBAcmV0dXJucyBBbiBgUHJvdmlkZXJgIHRvIGJlIHByb3ZpZGVkIGluIHlvdXIgbW9kdWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaG9va1N0ZXBwZXIoc3RlcDogR2VuZXJpY0hvb2tUeXBlPFN0ZXA+LCBvcHRpb25zPzogUGFydGlhbDxIb29rT3B0aW9ucz4pIHtcbiAgcmV0dXJuIGhvb2tHZW5lcmljPFN0ZXA+KHN0ZXAsIEhPT0tfU1RFUFBFUiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgdGhlIHN0ZXBzIGluIGEgc3RlcHBlciBjb21wb25lbnQuXG4gKiBBIHN0ZXBwZXIgaG9vayBuZWVkcyBhbiBjZXJ0YWluIG91dGxldCB3aGljaCBoYXMgYW4gbWF0Y2hpbmcgaWRcbiAqIHRvIGRpc3BsYXkgdGhlIHN0ZXBzLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBTdGVwcGVyU2VydmljZSBleHRlbmRzIEV4dGVuc2lvblBvaW50Rm9yUGx1Z2luczxTdGVwPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHJvb3RJbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UsXG4gICAgcGx1Z2luczogUGx1Z2luc1Jlc29sdmVTZXJ2aWNlXG4gICkge1xuICAgIHN1cGVyKHJvb3RJbmplY3RvciwgcGx1Z2lucyk7XG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLnNldHVwSXRlbXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBzb3J0U3RlcHMoc3RlcHM6IFN0ZXBbXSkge1xuICAgIHJldHVybiBzdGVwcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBwcmlvcml0eU9yZGVyID0gKGIucHJpb3JpdHkgfHwgMCkgLSAoYS5wcmlvcml0eSB8fCAwKTtcblxuICAgICAgY29uc3QgYVRyYW5zbGF0ZWRMYWJlbCA9IHRoaXMudHJhbnNsYXRlU2VydmljZS5pbnN0YW50KGEubGFiZWwpO1xuICAgICAgY29uc3QgYlRyYW5zbGF0ZWRMYWJlbCA9IHRoaXMudHJhbnNsYXRlU2VydmljZS5pbnN0YW50KGIubGFiZWwpO1xuICAgICAgY29uc3QgdHJhbnNsYXRlZExhYmVsT3JkZXIgPSBhVHJhbnNsYXRlZExhYmVsLmxvY2FsZUNvbXBhcmUoYlRyYW5zbGF0ZWRMYWJlbCk7XG5cbiAgICAgIHJldHVybiBwcmlvcml0eU9yZGVyIHx8IHRyYW5zbGF0ZWRMYWJlbE9yZGVyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXQgb2YgYWN0aW9ucy5cbiAgICovXG4gIGdldCBzdGF0ZSgpOiBTZXQ8U3RlcD4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlJC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gdG8gdGFicyBhbmQgZW1pdHMgc3RhdGUgY2hhbmdlXG4gICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGFkZC5cbiAgICovXG4gIGFkZChpdGVtOiBTdGVwKSB7XG4gICAgdGhpcy5zdGF0ZS5hZGQoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc3RlcCBhbmQgZW1pdHMgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShpdGVtOiBTdGVwKSB7XG4gICAgdGhpcy5zdGF0ZS5kZWxldGUoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgYnkgaXQncyBhc3NzaWduZWQgc3RlcHBlciBpZCBhcyBhbiBvYnNlcnZhYmxlLlxuICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBzdGVwcGVyIHRvIGhvb2sgaW50by5cbiAgICovXG4gIGdldEJ5SWQkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMkLnBpcGUoXG4gICAgICBmaWx0ZXIoc3RlcHMgPT4gc3RlcHMubGVuZ3RoID4gMCksXG4gICAgICBtYXAoc3RlcHMgPT4gc3RlcHMuZmlsdGVyKGNtcCA9PiBjbXAuc3RlcHBlcklkID09PSBpZCkpLFxuICAgICAgdGFrZSgxKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0dXBJdGVtc09ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxTdGVwW10+IHtcbiAgICByZXR1cm4gZnJvbVRyaWdnZXI8U3RlcD4odGhpcy5yb3V0ZXIsIHRoaXMucmVmcmVzaCQsIFtcbiAgICAgIGdldEluamVjdGVkSG9va3M8U3RlcD4oSE9PS19TVEVQUEVSLCB0aGlzLmluamVjdG9ycyksXG4gICAgICAoKSA9PiB0aGlzLmZhY3RvcmllcyxcbiAgICAgIHN0YXRlVG9GYWN0b3J5KHRoaXMuc3RhdGUkKVxuICAgIF0pLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgc2hhcmVSZXBsYXkoMSkpO1xuICB9XG59XG4iXX0=