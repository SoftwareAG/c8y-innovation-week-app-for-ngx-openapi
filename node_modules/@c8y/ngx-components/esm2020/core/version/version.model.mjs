import { InjectionToken } from '@angular/core';
import { hookGeneric } from '../common';
/**
 * An extension HOOK can use either a pure value:
 * ```typescript
 *  { provide: HOOK_X, useValue: { ...hookValue }, multi: true }
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  { provide: HOOK_X, useValue: [{ ...hookValues }], multi: true }
 * ```
 *
 * Or an ExtensionFactory which allows to define a get() function. This function
 * gets called on each navigation with the current route and can return values
 * async (observable or promise).
 * ```typescript
 *  { provide: HOOK_X, useFactory: { get: (route) => doSomethingAsync(route) }, multi: true }
 * ```
 * @deprecated Consider using the `hookVersion` function instead.
 */
export const HOOK_VERSION = new InjectionToken('HOOK_VERSION');
export const VERSION_MODULE_CONFIG = new InjectionToken('VERSION_MODULE_CONFIG');
/**
 * You can either provide a single `Version` as parameter:
 * ```typescript
 *  hookVersion(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookVersion([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<Version>`
 * ```typescript
 *  export class MyVersionFactory implements ExtensionFactory<Version> {...}
 *  ...
 *  hookVersion(MyVersionFactory)
 * ```
 * A typed alternative to `HOOK_VERSION`.
 * @param versions The `Version`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookVersion(versions, options) {
    return hookGeneric(versions, HOOK_VERSION, options);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi5tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvdmVyc2lvbi92ZXJzaW9uLm1vZGVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFL0MsT0FBTyxFQUFtQixXQUFXLEVBQWUsTUFBTSxXQUFXLENBQUM7QUFFdEU7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBWSxjQUFjLENBQUMsQ0FBQztBQUUxRSxNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLGNBQWMsQ0FDckQsdUJBQXVCLENBQ3hCLENBQUM7QUFFRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkc7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUFDLFFBQWtDLEVBQUUsT0FBOEI7SUFDNUYsT0FBTyxXQUFXLENBQVUsUUFBUSxFQUFFLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztBQUMvRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uVHlwZSB9IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IEdlbmVyaWNIb29rVHlwZSwgaG9va0dlbmVyaWMsIEhvb2tPcHRpb25zIH0gZnJvbSAnLi4vY29tbW9uJztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gSE9PSyBjYW4gdXNlIGVpdGhlciBhIHB1cmUgdmFsdWU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiB7IC4uLmhvb2tWYWx1ZSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IFt7IC4uLmhvb2tWYWx1ZXMgfV0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIEV4dGVuc2lvbkZhY3Rvcnkgd2hpY2ggYWxsb3dzIHRvIGRlZmluZSBhIGdldCgpIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBnZXRzIGNhbGxlZCBvbiBlYWNoIG5hdmlnYXRpb24gd2l0aCB0aGUgY3VycmVudCByb3V0ZSBhbmQgY2FuIHJldHVybiB2YWx1ZXNcbiAqIGFzeW5jIChvYnNlcnZhYmxlIG9yIHByb21pc2UpLlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VGYWN0b3J5OiB7IGdldDogKHJvdXRlKSA9PiBkb1NvbWV0aGluZ0FzeW5jKHJvdXRlKSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqIEBkZXByZWNhdGVkIENvbnNpZGVyIHVzaW5nIHRoZSBgaG9va1ZlcnNpb25gIGZ1bmN0aW9uIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBIT09LX1ZFUlNJT04gPSBuZXcgSW5qZWN0aW9uVG9rZW48VmVyc2lvbltdPignSE9PS19WRVJTSU9OJyk7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OX01PRFVMRV9DT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW48VmVyc2lvbk1vZHVsZUNvbmZpZz4oXG4gICdWRVJTSU9OX01PRFVMRV9DT05GSUcnXG4pO1xuXG4vKipcbiAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgYSBzaW5nbGUgYFZlcnNpb25gIGFzIHBhcmFtZXRlcjpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBob29rVmVyc2lvbiguLi4pXG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBob29rVmVyc2lvbihbLi4uXSlcbiAqIGBgYFxuICpcbiAqIE9yIHlvdSBwcm92aWRlIGFuIFNlcnZpY2UgdGhhdCBpbXBsZW1lbnRzIGBFeHRlbnNpb25GYWN0b3J5PFZlcnNpb24+YFxuICogYGBgdHlwZXNjcmlwdFxuICogIGV4cG9ydCBjbGFzcyBNeVZlcnNpb25GYWN0b3J5IGltcGxlbWVudHMgRXh0ZW5zaW9uRmFjdG9yeTxWZXJzaW9uPiB7Li4ufVxuICogIC4uLlxuICogIGhvb2tWZXJzaW9uKE15VmVyc2lvbkZhY3RvcnkpXG4gKiBgYGBcbiAqIEEgdHlwZWQgYWx0ZXJuYXRpdmUgdG8gYEhPT0tfVkVSU0lPTmAuXG4gKiBAcGFyYW0gdmVyc2lvbnMgVGhlIGBWZXJzaW9uYCdzIG9yIGBFeHRlbnNpb25GYWN0b3J5YCB0byBiZSBwcm92aWRlZC5cbiAqIEByZXR1cm5zIEFuIGBQcm92aWRlcmAgdG8gYmUgcHJvdmlkZWQgaW4geW91ciBtb2R1bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBob29rVmVyc2lvbih2ZXJzaW9uczogR2VuZXJpY0hvb2tUeXBlPFZlcnNpb24+LCBvcHRpb25zPzogUGFydGlhbDxIb29rT3B0aW9ucz4pIHtcbiAgcmV0dXJuIGhvb2tHZW5lcmljPFZlcnNpb24+KHZlcnNpb25zLCBIT09LX1ZFUlNJT04sIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb24gZXh0ZW5kcyBDbGVhbmVkVmVyc2lvbiB7XG4gIC8qKiBJbmZsdWVuY2VzIHRoZSBvcmRlciBvZiB0aGUgdmVyc2lvbiB3aXRoaW4gdGhlIGxpc3Qgb2YgdmVyc2lvbnMgKi9cbiAgcHJpb3JpdHk/OiBudW1iZXI7XG4gIC8qKiBXaWxsIGhpZGUgdGhlIHZlcnNpb24gaW4gdGhlIHdob2xlIFVJICovXG4gIGhpZGRlbj86IGJvb2xlYW47XG4gIC8qKiBXaWxsIGhpZGUgdGhlIHZlcnNpb24gaW4gdGhlIHJpZ2h0IGRyYXdlciwgYnV0IGRpc3BsYXkgaXQgaW4gdGhlIG1vZGFsIGRpYWxvZyAqL1xuICBoaWRlSW5SaWdodERyYXdlcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xlYW5lZFZlcnNpb24ge1xuICAvKiogTGFiZWwgb2YgdGhlIHZlcnNpb24gKi9cbiAgbGFiZWw6IHN0cmluZztcbiAgLyoqIFRoZSB2ZXJzaW9uICovXG4gIHZlcnNpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIHZlcnNpb24uXG4gICAqIFRoZSBKU09OIHRoYXQgY2FuIGJlIGNvcGllZCB0byB0aGUgY2xpcGJvYXJkIHdpbGwgZ3JvdXAgdGhlIHZlcnNpb25zIGJ5IHR5cGUuXG4gICAqIFR5cGVzIGNvdWxkIGUuZy4gYmUgYE1JQ1JPU0VSVklDRWAgYW5kIGBIT1NURURgIGZvciBhcHBzXG4gICAqL1xuICB0eXBlOiBBcHBsaWNhdGlvblR5cGUgfCBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gcHJvdmlkZSBhbnkgY3VzdG9tIHByb3BlcnRpZXMuXG4gICAqIFRoZXNlIHdpbGwgYmUgcGFydCBvZiB0aGUgSlNPTiBzdHJ1Y3R1cmUgdGhhdCB3aWxsIGJlIGNvcGllZCB0byBjbGlwYm9hcmQuXG4gICAqL1xuICBjdXN0b20/OiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25Nb2R1bGVDb25maWcge1xuICAvKiogV2lsbCBkaXNhYmxlIHRoZSBgV2ViU0RLVmVyc2lvbkZhY3RvcnlgIGluIGNhc2UgaXQgaXMgc2V0IHRvIHRydWUgKi9cbiAgZGlzYWJsZVdlYlNES1ZlcnNpb25GYWN0b3J5PzogYm9vbGVhbjtcbiAgLyoqIFdpbGwgZGlzYWJsZSB0aGUgYFdlYlNES1BsdWdpblZlcnNpb25GYWN0b3J5YCBpbiBjYXNlIGl0IGlzIHNldCB0byB0cnVlICovXG4gIGRpc2FibGVXZWJTREtQbHVnaW5WZXJzaW9uRmFjdG9yeT86IGJvb2xlYW47XG4gIC8qKiBXaWxsIGRpc2FibGUgdGhlIGBCYWNrZW5kVmVyc2lvbkZhY3RvcnlgIGluIGNhc2UgaXQgaXMgc2V0IHRvIHRydWUgKi9cbiAgZGlzYWJsZUJhY2tlbmRWZXJzaW9uRmFjdG9yeT86IGJvb2xlYW47XG59XG4iXX0=