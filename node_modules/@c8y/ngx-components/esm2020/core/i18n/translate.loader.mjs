import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs';
import { map, catchError, tap } from 'rxjs/operators';
import { Inject, Injectable } from '@angular/core';
import { LOCALE_PATH } from './locale.path';
import { LANGUAGES } from './languages';
import { OptionsService } from '../common/options.service';
import { mapKeys } from 'lodash-es';
import { CachedLocaleDictionaryService } from './cached-locale-dictionary.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "../common/options.service";
import * as i3 from "./cached-locale-dictionary.service";
export class TranslateCustomLoader {
    constructor(http, optionsService, cachedLocaleDictionaryService, path = null, languages = null) {
        this.http = http;
        this.optionsService = optionsService;
        this.cachedLocaleDictionaryService = cachedLocaleDictionaryService;
        this.path = path;
        this.languages = languages;
    }
    getTranslation(lang) {
        const path = this.path || '';
        let url = `${path}${lang}.json`;
        if (this.languages && this.languages[lang] && this.languages[lang].url) {
            url = this.languages[lang].url;
        }
        return this.http.get(url).pipe(map(d => {
            if (this.optionsService.langsDetails && this.optionsService.langsDetails[lang]) {
                return { ...d[lang], ...this.optionsService.langsDetails[lang] };
            }
            return d[lang];
        }), tap(dictionary => {
            this.cachedLocaleDictionaryService.cachedDictionary[lang] = dictionary;
        }), map(dictionary => this.getDictionaryWithTrimmedKeys(dictionary)), catchError(() => of({})));
    }
    /**
     * We want to have translation keys unified, so they don't contain unnecessary spaces and line breaks.
     * This way we can dynamically build keys from HTML, and match them to extracted string, that might be HTML as well.
     */
    getDictionaryWithTrimmedKeys(dictionary) {
        return mapKeys(dictionary, (value, key) => trimTranslationKey(key));
    }
}
TranslateCustomLoader.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TranslateCustomLoader, deps: [{ token: i1.HttpClient }, { token: i2.OptionsService }, { token: i3.CachedLocaleDictionaryService }, { token: LOCALE_PATH }, { token: LANGUAGES }], target: i0.ɵɵFactoryTarget.Injectable });
TranslateCustomLoader.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TranslateCustomLoader });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TranslateCustomLoader, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.OptionsService }, { type: i3.CachedLocaleDictionaryService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_PATH]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LANGUAGES]
                }] }]; } });
/**
 * Returns a trimmed translation key.
 * If the key contains HTML, it also removes all whitespaces.
 * The reason behind it is that by default Angular compiler removes
 * whitespaces from adjacent inline elements,
 * which prevents ngx-translate from finding a matching entry in the dictionary.
 */
export function trimTranslationKey(key) {
    key = key
        .replace(/(\r\n|\n|\r)/gm, '')
        .replace(/\s{2,}/g, ' ')
        .trim();
    const containsHTML = /(<([^>]+)>)/i.test(key);
    return containsHTML ? key.replace(/\s/g, '') : key;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmxvYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvaTE4bi90cmFuc2xhdGUubG9hZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVsRCxPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN4QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDM0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNwQyxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQzs7Ozs7QUFHbkYsTUFBTSxPQUFPLHFCQUFxQjtJQUNoQyxZQUNVLElBQWdCLEVBQ2hCLGNBQThCLEVBQzlCLDZCQUE0RCxFQUN2QyxPQUFlLElBQUksRUFDckIsWUFBaUIsSUFBSTtRQUp4QyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixrQ0FBNkIsR0FBN0IsNkJBQTZCLENBQStCO1FBQ3ZDLFNBQUksR0FBSixJQUFJLENBQWU7UUFDckIsY0FBUyxHQUFULFNBQVMsQ0FBWTtJQUMvQyxDQUFDO0lBRUosY0FBYyxDQUFDLElBQVk7UUFDekIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7UUFDN0IsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUM7UUFDaEMsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7WUFDdEUsR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDO1NBQ2hDO1FBRUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQzVCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNOLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzlFLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7YUFDbEU7WUFDRCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQixDQUFDLENBQUMsRUFDRixHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDZixJQUFJLENBQUMsNkJBQTZCLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQ3pFLENBQUMsQ0FBQyxFQUNGLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUNoRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQ3pCLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsNEJBQTRCLENBQUMsVUFBa0I7UUFDN0MsT0FBTyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN0RSxDQUFDOztrSEFyQ1UscUJBQXFCLHVIQUt0QixXQUFXLGFBQ1gsU0FBUztzSEFOUixxQkFBcUI7MkZBQXJCLHFCQUFxQjtrQkFEakMsVUFBVTs7MEJBTU4sTUFBTTsyQkFBQyxXQUFXOzswQkFDbEIsTUFBTTsyQkFBQyxTQUFTOztBQWtDckI7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFDLEdBQUc7SUFDcEMsR0FBRyxHQUFHLEdBQUc7U0FDTixPQUFPLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDO1NBQzdCLE9BQU8sQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDO1NBQ3ZCLElBQUksRUFBRSxDQUFDO0lBQ1YsTUFBTSxZQUFZLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QyxPQUFPLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNyRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IFRyYW5zbGF0ZUxvYWRlciB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMT0NBTEVfUEFUSCB9IGZyb20gJy4vbG9jYWxlLnBhdGgnO1xuaW1wb3J0IHsgTEFOR1VBR0VTIH0gZnJvbSAnLi9sYW5ndWFnZXMnO1xuaW1wb3J0IHsgT3B0aW9uc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vb3B0aW9ucy5zZXJ2aWNlJztcbmltcG9ydCB7IG1hcEtleXMgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgQ2FjaGVkTG9jYWxlRGljdGlvbmFyeVNlcnZpY2UgfSBmcm9tICcuL2NhY2hlZC1sb2NhbGUtZGljdGlvbmFyeS5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRyYW5zbGF0ZUN1c3RvbUxvYWRlciBpbXBsZW1lbnRzIFRyYW5zbGF0ZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaHR0cDogSHR0cENsaWVudCxcbiAgICBwcml2YXRlIG9wdGlvbnNTZXJ2aWNlOiBPcHRpb25zU2VydmljZSxcbiAgICBwcml2YXRlIGNhY2hlZExvY2FsZURpY3Rpb25hcnlTZXJ2aWNlOiBDYWNoZWRMb2NhbGVEaWN0aW9uYXJ5U2VydmljZSxcbiAgICBASW5qZWN0KExPQ0FMRV9QQVRIKSBwcml2YXRlIHBhdGg6IHN0cmluZyA9IG51bGwsXG4gICAgQEluamVjdChMQU5HVUFHRVMpIHByaXZhdGUgbGFuZ3VhZ2VzOiBhbnkgPSBudWxsXG4gICkge31cblxuICBnZXRUcmFuc2xhdGlvbihsYW5nOiBzdHJpbmcpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGggfHwgJyc7XG4gICAgbGV0IHVybCA9IGAke3BhdGh9JHtsYW5nfS5qc29uYDtcbiAgICBpZiAodGhpcy5sYW5ndWFnZXMgJiYgdGhpcy5sYW5ndWFnZXNbbGFuZ10gJiYgdGhpcy5sYW5ndWFnZXNbbGFuZ10udXJsKSB7XG4gICAgICB1cmwgPSB0aGlzLmxhbmd1YWdlc1tsYW5nXS51cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaHR0cC5nZXQodXJsKS5waXBlKFxuICAgICAgbWFwKGQgPT4ge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zU2VydmljZS5sYW5nc0RldGFpbHMgJiYgdGhpcy5vcHRpb25zU2VydmljZS5sYW5nc0RldGFpbHNbbGFuZ10pIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5kW2xhbmddLCAuLi50aGlzLm9wdGlvbnNTZXJ2aWNlLmxhbmdzRGV0YWlsc1tsYW5nXSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkW2xhbmddO1xuICAgICAgfSksXG4gICAgICB0YXAoZGljdGlvbmFyeSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGVkTG9jYWxlRGljdGlvbmFyeVNlcnZpY2UuY2FjaGVkRGljdGlvbmFyeVtsYW5nXSA9IGRpY3Rpb25hcnk7XG4gICAgICB9KSxcbiAgICAgIG1hcChkaWN0aW9uYXJ5ID0+IHRoaXMuZ2V0RGljdGlvbmFyeVdpdGhUcmltbWVkS2V5cyhkaWN0aW9uYXJ5KSksXG4gICAgICBjYXRjaEVycm9yKCgpID0+IG9mKHt9KSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIHdhbnQgdG8gaGF2ZSB0cmFuc2xhdGlvbiBrZXlzIHVuaWZpZWQsIHNvIHRoZXkgZG9uJ3QgY29udGFpbiB1bm5lY2Vzc2FyeSBzcGFjZXMgYW5kIGxpbmUgYnJlYWtzLlxuICAgKiBUaGlzIHdheSB3ZSBjYW4gZHluYW1pY2FsbHkgYnVpbGQga2V5cyBmcm9tIEhUTUwsIGFuZCBtYXRjaCB0aGVtIHRvIGV4dHJhY3RlZCBzdHJpbmcsIHRoYXQgbWlnaHQgYmUgSFRNTCBhcyB3ZWxsLlxuICAgKi9cbiAgZ2V0RGljdGlvbmFyeVdpdGhUcmltbWVkS2V5cyhkaWN0aW9uYXJ5OiBvYmplY3QpIHtcbiAgICByZXR1cm4gbWFwS2V5cyhkaWN0aW9uYXJ5LCAodmFsdWUsIGtleSkgPT4gdHJpbVRyYW5zbGF0aW9uS2V5KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHRyaW1tZWQgdHJhbnNsYXRpb24ga2V5LlxuICogSWYgdGhlIGtleSBjb250YWlucyBIVE1MLCBpdCBhbHNvIHJlbW92ZXMgYWxsIHdoaXRlc3BhY2VzLlxuICogVGhlIHJlYXNvbiBiZWhpbmQgaXQgaXMgdGhhdCBieSBkZWZhdWx0IEFuZ3VsYXIgY29tcGlsZXIgcmVtb3Zlc1xuICogd2hpdGVzcGFjZXMgZnJvbSBhZGphY2VudCBpbmxpbmUgZWxlbWVudHMsXG4gKiB3aGljaCBwcmV2ZW50cyBuZ3gtdHJhbnNsYXRlIGZyb20gZmluZGluZyBhIG1hdGNoaW5nIGVudHJ5IGluIHRoZSBkaWN0aW9uYXJ5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVRyYW5zbGF0aW9uS2V5KGtleSkge1xuICBrZXkgPSBrZXlcbiAgICAucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSwgJycpXG4gICAgLnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKVxuICAgIC50cmltKCk7XG4gIGNvbnN0IGNvbnRhaW5zSFRNTCA9IC8oPChbXj5dKyk+KS9pLnRlc3Qoa2V5KTtcbiAgcmV0dXJuIGNvbnRhaW5zSFRNTCA/IGtleS5yZXBsYWNlKC9cXHMvZywgJycpIDoga2V5O1xufVxuIl19