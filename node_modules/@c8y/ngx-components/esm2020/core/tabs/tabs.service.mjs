import { Injectable, InjectionToken, Injector, ViewContainerRef } from '@angular/core';
import { Router } from '@angular/router';
import { TranslateService } from '@ngx-translate/core';
import { distinctUntilChanged, filter, first, map, shareReplay } from 'rxjs/operators';
import { fromTrigger, hookGeneric, getInjectedHooks, stateToFactory, ExtensionPointForPlugins } from '../common/extension-hooks';
import { OptionsService } from '../common/options.service';
import { PluginsResolveService } from '../plugins/plugins-resolve.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@ngx-translate/core";
import * as i3 from "../common/options.service";
import * as i4 from "../plugins/plugins-resolve.service";
/**
 * A hook to use for Multi Provider extension.
 * @deprecated Consider using the `hookTab` function instead.
 */
export const HOOK_TABS = new InjectionToken('HOOK_TABS');
/**
 * You can either provide a single `Tab` as parameter:
 * ```typescript
 *  hookTab(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookTab([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<Tab>`
 * ```typescript
 *  export class MyTabFactory implements ExtensionFactory<Tab> {...}
 *  ...
 *  hookTab(MyTabFactory)
 * ```
 * A typed alternative to `HOOK_TABS`.
 * @param tabs The `Tab`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookTab(tabs, options) {
    return hookGeneric(tabs, HOOK_TABS, options);
}
/**
 * A service which defines the used tabs.
 */
export class TabsService extends ExtensionPointForPlugins {
    constructor(rootInjector, router, translateService, options, plugins) {
        super(rootInjector, plugins);
        this.router = router;
        this.translateService = translateService;
        this.options = options;
        this.items$ = this.setupItemsObservable();
        this.orientation$ = this.items$.pipe(map((tabs) => {
            const firstTabWithDefinedOrientation = tabs.find(tab => tab.orientation);
            if (firstTabWithDefinedOrientation) {
                return firstTabWithDefinedOrientation.orientation;
            }
            return this.options.tabsHorizontal ? 'horizontal' : 'vertical';
        }), distinctUntilChanged());
    }
    prepareTabs(tabs) {
        return this.sortTabs(tabs
            .map(tab => ({
            ...tab,
            template: tab.template instanceof ViewContainerRef ? tab.template : undefined
        }))
            .filter((tab, index, self) => tab.component || index === self.findIndex(t => t.path === tab.path)));
    }
    sortTabs(tabs) {
        return tabs.sort((a, b) => {
            const priorityOrder = (b.priority || 0) - (a.priority || 0);
            if (!!priorityOrder) {
                return priorityOrder;
            }
            if (!a.label) {
                return 1;
            }
            if (!b.label) {
                return -1;
            }
            const aTranslatedLabel = this.translateService.instant(a.label);
            const bTranslatedLabel = this.translateService.instant(b.label);
            const translatedLabelOrder = aTranslatedLabel.localeCompare(bTranslatedLabel);
            return translatedLabelOrder;
        });
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Adds a new item to tabs and emits state change
     * @param item The item to add.
     */
    add(item) {
        this.state.add(item);
        this.emitNewState();
    }
    /**
     * Removes a tab and emits a state change.
     * @param item The item to remove.
     */
    remove(item) {
        this.state.delete(item);
        this.emitNewState();
    }
    get firstTab$() {
        return this.items$.pipe(map(tabs => tabs[0]), filter(Boolean), first());
    }
    /**
     * Checks if at least one of the tabs is available.
     * @param tabLabels The array of tab labels to check.
     * @returns Returns true if at least one of the tabs is available.
     */
    areAvailable(tabLabels) {
        const currentTabsSetArray = Array.from(this.state);
        return tabLabels.some(tabLabel => currentTabsSetArray.some(tab => tab.label === tabLabel));
    }
    setupItemsObservable() {
        return fromTrigger(this.router, this.refresh$, [
            getInjectedHooks(HOOK_TABS, this.injectors),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(distinctUntilChanged(), map(tabs => this.prepareTabs(tabs)), shareReplay(1));
    }
}
TabsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TabsService, deps: [{ token: i0.Injector }, { token: i1.Router }, { token: i2.TranslateService }, { token: i3.OptionsService }, { token: i4.PluginsResolveService }], target: i0.ɵɵFactoryTarget.Injectable });
TabsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TabsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: TabsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.Router }, { type: i2.TranslateService }, { type: i3.OptionsService }, { type: i4.PluginsResolveService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS90YWJzL3RhYnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkYsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXZELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2RixPQUFPLEVBRUwsV0FBVyxFQUVYLFdBQVcsRUFDWCxnQkFBZ0IsRUFDaEIsY0FBYyxFQUNkLHdCQUF3QixFQUV6QixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQzs7Ozs7O0FBdUIzRTs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxjQUFjLENBQWlCLFdBQVcsQ0FBQyxDQUFDO0FBRXpFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUNILE1BQU0sVUFBVSxPQUFPLENBQUMsSUFBMEIsRUFBRSxPQUE4QjtJQUNoRixPQUFPLFdBQVcsQ0FBTSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3BELENBQUM7QUFFRDs7R0FFRztBQUlILE1BQU0sT0FBTyxXQUFZLFNBQVEsd0JBQTZCO0lBSTVELFlBQ0UsWUFBc0IsRUFDZCxNQUFjLEVBQ2QsZ0JBQWtDLEVBQ2xDLE9BQXVCLEVBQy9CLE9BQThCO1FBRTlCLEtBQUssQ0FBQyxZQUFZLEVB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LGNBRlYsTUFBTTsyRkFFUCxXQUFXO2tCQUh2QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIGZpcnN0LCBtYXAsIHNoYXJlUmVwbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRXh0ZW5zaW9uRmFjdG9yeSxcbiAgZnJvbVRyaWdnZXIsXG4gIEdlbmVyaWNIb29rVHlwZSxcbiAgaG9va0dlbmVyaWMsXG4gIGdldEluamVjdGVkSG9va3MsXG4gIHN0YXRlVG9GYWN0b3J5LFxuICBFeHRlbnNpb25Qb2ludEZvclBsdWdpbnMsXG4gIEhvb2tPcHRpb25zXG59IGZyb20gJy4uL2NvbW1vbi9leHRlbnNpb24taG9va3MnO1xuaW1wb3J0IHsgT3B0aW9uc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vb3B0aW9ucy5zZXJ2aWNlJztcbmltcG9ydCB7IFBsdWdpbnNSZXNvbHZlU2VydmljZSB9IGZyb20gJy4uL3BsdWdpbnMvcGx1Z2lucy1yZXNvbHZlLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFiIH0gZnJvbSAnLi90YWIubW9kZWwnO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBIT09LIGNhbiB1c2UgZWl0aGVyIGEgcHVyZSB2YWx1ZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IHsgLi4uaG9va1ZhbHVlIH0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VWYWx1ZTogW3sgLi4uaG9va1ZhbHVlcyB9XSwgbXVsdGk6IHRydWUgfVxuICogYGBgXG4gKlxuICogT3IgYW4gRXh0ZW5zaW9uRmFjdG9yeSB3aGljaCBhbGxvd3MgdG8gZGVmaW5lIGEgZ2V0KCkgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb25cbiAqIGdldHMgY2FsbGVkIG9uIGVhY2ggbmF2aWdhdGlvbiB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGFuZCBjYW4gcmV0dXJuIHZhbHVlc1xuICogYXN5bmMgKG9ic2VydmFibGUgb3IgcHJvbWlzZSkuXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZUZhY3Rvcnk6IHsgZ2V0OiAocm91dGUpID0+IGRvU29tZXRoaW5nQXN5bmMocm91dGUpIH0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBUYWJFeHRlbnNpb24gPSBUYWIgfCBUYWJbXSB8IEV4dGVuc2lvbkZhY3Rvcnk8VGFiPjtcblxuLyoqXG4gKiBBIGhvb2sgdG8gdXNlIGZvciBNdWx0aSBQcm92aWRlciBleHRlbnNpb24uXG4gKiBAZGVwcmVjYXRlZCBDb25zaWRlciB1c2luZyB0aGUgYGhvb2tUYWJgIGZ1bmN0aW9uIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBIT09LX1RBQlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48VGFiRXh0ZW5zaW9uW10+KCdIT09LX1RBQlMnKTtcblxuLyoqXG4gKiBZb3UgY2FuIGVpdGhlciBwcm92aWRlIGEgc2luZ2xlIGBUYWJgIGFzIHBhcmFtZXRlcjpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBob29rVGFiKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tUYWIoWy4uLl0pXG4gKiBgYGBcbiAqXG4gKiBPciB5b3UgcHJvdmlkZSBhbiBTZXJ2aWNlIHRoYXQgaW1wbGVtZW50cyBgRXh0ZW5zaW9uRmFjdG9yeTxUYWI+YFxuICogYGBgdHlwZXNjcmlwdFxuICogIGV4cG9ydCBjbGFzcyBNeVRhYkZhY3RvcnkgaW1wbGVtZW50cyBFeHRlbnNpb25GYWN0b3J5PFRhYj4gey4uLn1cbiAqICAuLi5cbiAqICBob29rVGFiKE15VGFiRmFjdG9yeSlcbiAqIGBgYFxuICogQSB0eXBlZCBhbHRlcm5hdGl2ZSB0byBgSE9PS19UQUJTYC5cbiAqIEBwYXJhbSB0YWJzIFRoZSBgVGFiYCdzIG9yIGBFeHRlbnNpb25GYWN0b3J5YCB0byBiZSBwcm92aWRlZC5cbiAqIEByZXR1cm5zIEFuIGBQcm92aWRlcmAgdG8gYmUgcHJvdmlkZWQgaW4geW91ciBtb2R1bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBob29rVGFiKHRhYnM6IEdlbmVyaWNIb29rVHlwZTxUYWI+LCBvcHRpb25zPzogUGFydGlhbDxIb29rT3B0aW9ucz4pIHtcbiAgcmV0dXJuIGhvb2tHZW5lcmljPFRhYj4odGFicywgSE9PS19UQUJTLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBIHNlcnZpY2Ugd2hpY2ggZGVmaW5lcyB0aGUgdXNlZCB0YWJzLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBUYWJzU2VydmljZSBleHRlbmRzIEV4dGVuc2lvblBvaW50Rm9yUGx1Z2luczxUYWI+IHtcbiAgaXRlbXMkOiBPYnNlcnZhYmxlPFRhYltdPjtcbiAgb3JpZW50YXRpb24kOiBPYnNlcnZhYmxlPCd2ZXJ0aWNhbCcgfCAnaG9yaXpvbnRhbCc+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJvb3RJbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICBwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IFRyYW5zbGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBPcHRpb25zU2VydmljZSxcbiAgICBwbHVnaW5zOiBQbHVnaW5zUmVzb2x2ZVNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIocm9vdEluamVjdG9yLCBwbHVnaW5zKTtcbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuc2V0dXBJdGVtc09ic2VydmFibGUoKTtcblxuICAgIHRoaXMub3JpZW50YXRpb24kID0gdGhpcy5pdGVtcyQucGlwZShcbiAgICAgIG1hcCgodGFiczogVGFiW10pID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3RUYWJXaXRoRGVmaW5lZE9yaWVudGF0aW9uID0gdGFicy5maW5kKHRhYiA9PiB0YWIub3JpZW50YXRpb24pO1xuICAgICAgICBpZiAoZmlyc3RUYWJXaXRoRGVmaW5lZE9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0VGFiV2l0aERlZmluZWRPcmllbnRhdGlvbi5vcmllbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhYnNIb3Jpem9udGFsID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICAgIH0pLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICk7XG4gIH1cblxuICBwcmVwYXJlVGFicyh0YWJzKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydFRhYnMoXG4gICAgICB0YWJzXG4gICAgICAgIC5tYXAodGFiID0+ICh7XG4gICAgICAgICAgLi4udGFiLFxuICAgICAgICAgIHRlbXBsYXRlOiB0YWIudGVtcGxhdGUgaW5zdGFuY2VvZiBWaWV3Q29udGFpbmVyUmVmID8gdGFiLnRlbXBsYXRlIDogdW5kZWZpbmVkXG4gICAgICAgIH0pKVxuICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICh0YWIsIGluZGV4LCBzZWxmKSA9PiB0YWIuY29tcG9uZW50IHx8IGluZGV4ID09PSBzZWxmLmZpbmRJbmRleCh0ID0+IHQucGF0aCA9PT0gdGFiLnBhdGgpXG4gICAgICAgIClcbiAgICApO1xuICB9XG5cbiAgc29ydFRhYnModGFicykge1xuICAgIHJldHVybiB0YWJzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHByaW9yaXR5T3JkZXIgPSAoYi5wcmlvcml0eSB8fCAwKSAtIChhLnByaW9yaXR5IHx8IDApO1xuXG4gICAgICBpZiAoISFwcmlvcml0eU9yZGVyKSB7XG4gICAgICAgIHJldHVybiBwcmlvcml0eU9yZGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWEubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICghYi5sYWJlbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFUcmFuc2xhdGVkTGFiZWwgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuaW5zdGFudChhLmxhYmVsKTtcbiAgICAgIGNvbnN0IGJUcmFuc2xhdGVkTGFiZWwgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuaW5zdGFudChiLmxhYmVsKTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZWRMYWJlbE9yZGVyID0gYVRyYW5zbGF0ZWRMYWJlbC5sb2NhbGVDb21wYXJlKGJUcmFuc2xhdGVkTGFiZWwpO1xuXG4gICAgICByZXR1cm4gdHJhbnNsYXRlZExhYmVsT3JkZXI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldCBvZiBhY3Rpb25zLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFNldDxUYWI+IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRhYnMgYW5kIGVtaXRzIHN0YXRlIGNoYW5nZVxuICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQuXG4gICAqL1xuICBhZGQoaXRlbTogVGFiKSB7XG4gICAgdGhpcy5zdGF0ZS5hZGQoaXRlbSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdGFiIGFuZCBlbWl0cyBhIHN0YXRlIGNoYW5nZS5cbiAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlKGl0ZW06IFRhYikge1xuICAgIHRoaXMuc3RhdGUuZGVsZXRlKGl0ZW0pO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICBnZXQgZmlyc3RUYWIkKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zJC5waXBlKFxuICAgICAgbWFwKHRhYnMgPT4gdGFic1swXSksXG4gICAgICBmaWx0ZXIoQm9vbGVhbiksXG4gICAgICBmaXJzdCgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB0YWJzIGlzIGF2YWlsYWJsZS5cbiAgICogQHBhcmFtIHRhYkxhYmVscyBUaGUgYXJyYXkgb2YgdGFiIGxhYmVscyB0byBjaGVjay5cbiAgICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFicyBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBhcmVBdmFpbGFibGUodGFiTGFiZWxzOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGN1cnJlbnRUYWJzU2V0QXJyYXkgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGUpO1xuICAgIHJldHVybiB0YWJMYWJlbHMuc29tZSh0YWJMYWJlbCA9PiBjdXJyZW50VGFic1NldEFycmF5LnNvbWUodGFiID0+IHRhYi5sYWJlbCA9PT0gdGFiTGFiZWwpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXR1cEl0ZW1zT2JzZXJ2YWJsZSgpOiBPYnNlcnZhYmxlPFRhYltdPiB7XG4gICAgcmV0dXJuIGZyb21UcmlnZ2VyPFRhYj4odGhpcy5yb3V0ZXIsIHRoaXMucmVmcmVzaCQsIFtcbiAgICAgIGdldEluamVjdGVkSG9va3M8VGFiPihIT09LX1RBQlMsIHRoaXMuaW5qZWN0b3JzKSxcbiAgICAgICgpID0+IHRoaXMuZmFjdG9yaWVzLFxuICAgICAgc3RhdGVUb0ZhY3RvcnkodGhpcy5zdGF0ZSQpXG4gICAgXSkucGlwZShcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBtYXAodGFicyA9PiB0aGlzLnByZXBhcmVUYWJzKHRhYnMpKSxcbiAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgKTtcbiAgfVxufVxuIl19