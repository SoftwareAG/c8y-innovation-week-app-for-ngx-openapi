import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { TabsService } from './tabs.service';
import * as i0 from "@angular/core";
import * as i1 from "./tabs.service";
import * as i2 from "@angular/router";
/**
 * Register this component on the parent route of a view with multiple tabs where the first tab
 * is displayed only conditionally.
 *
 * Given the following routes leading to a single view with multiple tabs:<br>
 * /yourpath/tab-a -> Tab A<br>
 * /yourpath/tab-b -> Tab B<br>
 * /yourpath/tab-c -> Tab C
 *
 * Your components will be registered like
 * ```typescript
 * export const routes: Route[] = [
 *   {
 *     path: 'yourpath/tab-a',
 *     component: TabAComponent
 *   },
 *   {
 *     path: 'yourpath/tab-b',
 *     component: TabBComponent
 *   },
 *   {
 *     path: 'yourpath/tab-c',
 *     component: TabCComponent
 *   }
 * ];
 * ```
 *
 * In the simple case where Tab A is the first tab on the view and it is always displayed, you can register
 * your view in the navigation with a similar navigator node:
 *
 * ```typescript
 * new NavigatorNode({
 *   label: gettext('My tabs'),
 *   path: 'yourpath/tab-a',
 *   icon: 'gears',
 *   parent: gettext('Some parent node'),
 *   priority: 100
 * })
 * ```
 *
 * This will navigate to the first tab's component and activate the first tab in the view.
 *
 * In case Tab A is displayed conditionally you cannot link it from a navigator node since it may not be available in some cases.
 * In this situation `ConditionalTabsOutletComponent` comes handy as it will forward users to the first available tab on your view:
 *
 * ```typescript
 * new NavigatorNode({
 *   label: gettext('My tabs'),
 *   path: 'yourpath', // note that here we use only the parent route
 *   icon: 'gears',
 *   parent: gettext('Some parent node'),
 *   priority: 100
 * })
 *
 * [...]
 *
 * export const routes: Route[] = [
 *   {
 *     path: 'yourpath',
 *     component: ConditionalTabsOutletComponent // we register ConditionalTabsOutletComponent for the parent path
 *   },
 *   {
 *     path: 'yourpath/tab-a',
 *     component: TabAComponent
 *   },
 *   {
 *     path: 'yourpath/tab-b',
 *     component: TabBComponent
 *   },
 *   {
 *     path: 'yourpath/tab-c',
 *     component: TabCComponent
 *   }
 * ];
 * ```
 */
export class ConditionalTabsOutletComponent {
    constructor(tabsService, router) {
        this.tabsService = tabsService;
        this.router = router;
        this.endSubscriptions$ = new Subject();
    }
    ngOnInit() {
        this.tabsService.firstTab$.pipe(takeUntil(this.endSubscriptions$)).subscribe((tab) => {
            if (tab) {
                this.router.navigateByUrl(tab.path, { replaceUrl: true });
            }
        });
    }
    ngOnDestroy() {
        this.endSubscriptions$.next();
        this.endSubscriptions$.complete();
    }
}
ConditionalTabsOutletComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ConditionalTabsOutletComponent, deps: [{ token: i1.TabsService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Component });
ConditionalTabsOutletComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.7", type: ConditionalTabsOutletComponent, selector: "c8y-conditional-tabs-outlet", ngImport: i0, template: ` <router-outlet></router-outlet> `, isInline: true, dependencies: [{ kind: "directive", type: i2.RouterOutlet, selector: "router-outlet", inputs: ["name"], outputs: ["activate", "deactivate", "attach", "detach"], exportAs: ["outlet"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: ConditionalTabsOutletComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c8y-conditional-tabs-outlet',
                    template: ` <router-outlet></router-outlet> `
                }]
        }], ctorParameters: function () { return [{ type: i1.TabsService }, { type: i2.Router }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZGl0aW9uYWwtdGFicy1vdXRsZXQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS90YWJzL2NvbmRpdGlvbmFsLXRhYnMtb3V0bGV0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFxQixNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBRTdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyRUc7QUFLSCxNQUFNLE9BQU8sOEJBQThCO0lBR3pDLFlBQW9CLFdBQXdCLEVBQVUsTUFBYztRQUFoRCxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUFVLFdBQU0sR0FBTixNQUFNLENBQVE7UUFGNUQsc0JBQWlCLEdBQWtCLElBQUksT0FBTyxFQUFFLENBQUM7SUFFYyxDQUFDO0lBRXhFLFFBQVE7UUFDTixJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBUSxFQUFFLEVBQUU7WUFDeEYsSUFBSSxHQUFHLEVBQUU7Z0JBQ1AsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO2FBQzNEO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUM5QixJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDcEMsQ0FBQzs7MkhBaEJVLDhCQUE4QjsrR0FBOUIsOEJBQThCLG1FQUYvQixtQ0FBbUM7MkZBRWxDLDhCQUE4QjtrQkFKMUMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsNkJBQTZCO29CQUN2QyxRQUFRLEVBQUUsbUNBQW1DO2lCQUM5QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBUYWIgfSBmcm9tICcuL3RhYi5tb2RlbCc7XG5pbXBvcnQgeyBUYWJzU2VydmljZSB9IGZyb20gJy4vdGFicy5zZXJ2aWNlJztcblxuLyoqXG4gKiBSZWdpc3RlciB0aGlzIGNvbXBvbmVudCBvbiB0aGUgcGFyZW50IHJvdXRlIG9mIGEgdmlldyB3aXRoIG11bHRpcGxlIHRhYnMgd2hlcmUgdGhlIGZpcnN0IHRhYlxuICogaXMgZGlzcGxheWVkIG9ubHkgY29uZGl0aW9uYWxseS5cbiAqXG4gKiBHaXZlbiB0aGUgZm9sbG93aW5nIHJvdXRlcyBsZWFkaW5nIHRvIGEgc2luZ2xlIHZpZXcgd2l0aCBtdWx0aXBsZSB0YWJzOjxicj5cbiAqIC95b3VycGF0aC90YWItYSAtPiBUYWIgQTxicj5cbiAqIC95b3VycGF0aC90YWItYiAtPiBUYWIgQjxicj5cbiAqIC95b3VycGF0aC90YWItYyAtPiBUYWIgQ1xuICpcbiAqIFlvdXIgY29tcG9uZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgbGlrZVxuICogYGBgdHlwZXNjcmlwdFxuICogZXhwb3J0IGNvbnN0IHJvdXRlczogUm91dGVbXSA9IFtcbiAqICAge1xuICogICAgIHBhdGg6ICd5b3VycGF0aC90YWItYScsXG4gKiAgICAgY29tcG9uZW50OiBUYWJBQ29tcG9uZW50XG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBwYXRoOiAneW91cnBhdGgvdGFiLWInLFxuICogICAgIGNvbXBvbmVudDogVGFiQkNvbXBvbmVudFxuICogICB9LFxuICogICB7XG4gKiAgICAgcGF0aDogJ3lvdXJwYXRoL3RhYi1jJyxcbiAqICAgICBjb21wb25lbnQ6IFRhYkNDb21wb25lbnRcbiAqICAgfVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEluIHRoZSBzaW1wbGUgY2FzZSB3aGVyZSBUYWIgQSBpcyB0aGUgZmlyc3QgdGFiIG9uIHRoZSB2aWV3IGFuZCBpdCBpcyBhbHdheXMgZGlzcGxheWVkLCB5b3UgY2FuIHJlZ2lzdGVyXG4gKiB5b3VyIHZpZXcgaW4gdGhlIG5hdmlnYXRpb24gd2l0aCBhIHNpbWlsYXIgbmF2aWdhdG9yIG5vZGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogbmV3IE5hdmlnYXRvck5vZGUoe1xuICogICBsYWJlbDogZ2V0dGV4dCgnTXkgdGFicycpLFxuICogICBwYXRoOiAneW91cnBhdGgvdGFiLWEnLFxuICogICBpY29uOiAnZ2VhcnMnLFxuICogICBwYXJlbnQ6IGdldHRleHQoJ1NvbWUgcGFyZW50IG5vZGUnKSxcbiAqICAgcHJpb3JpdHk6IDEwMFxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoaXMgd2lsbCBuYXZpZ2F0ZSB0byB0aGUgZmlyc3QgdGFiJ3MgY29tcG9uZW50IGFuZCBhY3RpdmF0ZSB0aGUgZmlyc3QgdGFiIGluIHRoZSB2aWV3LlxuICpcbiAqIEluIGNhc2UgVGFiIEEgaXMgZGlzcGxheWVkIGNvbmRpdGlvbmFsbHkgeW91IGNhbm5vdCBsaW5rIGl0IGZyb20gYSBuYXZpZ2F0b3Igbm9kZSBzaW5jZSBpdCBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBzb21lIGNhc2VzLlxuICogSW4gdGhpcyBzaXR1YXRpb24gYENvbmRpdGlvbmFsVGFic091dGxldENvbXBvbmVudGAgY29tZXMgaGFuZHkgYXMgaXQgd2lsbCBmb3J3YXJkIHVzZXJzIHRvIHRoZSBmaXJzdCBhdmFpbGFibGUgdGFiIG9uIHlvdXIgdmlldzpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBuZXcgTmF2aWdhdG9yTm9kZSh7XG4gKiAgIGxhYmVsOiBnZXR0ZXh0KCdNeSB0YWJzJyksXG4gKiAgIHBhdGg6ICd5b3VycGF0aCcsIC8vIG5vdGUgdGhhdCBoZXJlIHdlIHVzZSBvbmx5IHRoZSBwYXJlbnQgcm91dGVcbiAqICAgaWNvbjogJ2dlYXJzJyxcbiAqICAgcGFyZW50OiBnZXR0ZXh0KCdTb21lIHBhcmVudCBub2RlJyksXG4gKiAgIHByaW9yaXR5OiAxMDBcbiAqIH0pXG4gKlxuICogWy4uLl1cbiAqXG4gKiBleHBvcnQgY29uc3Qgcm91dGVzOiBSb3V0ZVtdID0gW1xuICogICB7XG4gKiAgICAgcGF0aDogJ3lvdXJwYXRoJyxcbiAqICAgICBjb21wb25lbnQ6IENvbmRpdGlvbmFsVGFic091dGxldENvbXBvbmVudCAvLyB3ZSByZWdpc3RlciBDb25kaXRpb25hbFRhYnNPdXRsZXRDb21wb25lbnQgZm9yIHRoZSBwYXJlbnQgcGF0aFxuICogICB9LFxuICogICB7XG4gKiAgICAgcGF0aDogJ3lvdXJwYXRoL3RhYi1hJyxcbiAqICAgICBjb21wb25lbnQ6IFRhYkFDb21wb25lbnRcbiAqICAgfSxcbiAqICAge1xuICogICAgIHBhdGg6ICd5b3VycGF0aC90YWItYicsXG4gKiAgICAgY29tcG9uZW50OiBUYWJCQ29tcG9uZW50XG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICBwYXRoOiAneW91cnBhdGgvdGFiLWMnLFxuICogICAgIGNvbXBvbmVudDogVGFiQ0NvbXBvbmVudFxuICogICB9XG4gKiBdO1xuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1jb25kaXRpb25hbC10YWJzLW91dGxldCcsXG4gIHRlbXBsYXRlOiBgIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD4gYFxufSlcbmV4cG9ydCBjbGFzcyBDb25kaXRpb25hbFRhYnNPdXRsZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgZW5kU3Vic2NyaXB0aW9ucyQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGFic1NlcnZpY2U6IFRhYnNTZXJ2aWNlLCBwcml2YXRlIHJvdXRlcjogUm91dGVyKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMudGFic1NlcnZpY2UuZmlyc3RUYWIkLnBpcGUodGFrZVVudGlsKHRoaXMuZW5kU3Vic2NyaXB0aW9ucyQpKS5zdWJzY3JpYmUoKHRhYjogVGFiKSA9PiB7XG4gICAgICBpZiAodGFiKSB7XG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodGFiLnBhdGgsIHsgcmVwbGFjZVVybDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZW5kU3Vic2NyaXB0aW9ucyQubmV4dCgpO1xuICAgIHRoaXMuZW5kU3Vic2NyaXB0aW9ucyQuY29tcGxldGUoKTtcbiAgfVxufVxuIl19