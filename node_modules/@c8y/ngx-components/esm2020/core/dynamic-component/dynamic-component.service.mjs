import { Inject, Injectable, Injector, Optional } from '@angular/core';
import { Router } from '@angular/router';
import { combineLatest, timer } from 'rxjs';
import { distinctUntilChanged, filter, mergeMap, shareReplay, take, takeUntil } from 'rxjs/operators';
import { ExtensionPointForPlugins, fromTriggerOnce, getInjectedHooks, stateToFactory } from '../common/extension-hooks';
import { PluginsResolveService } from '../plugins';
import { HOOK_COMPONENTS, RESOLVING_COMPONENT_WAIT_TIME } from './dynamic-component.model';
import { DynamicResolverService } from './dynamic-resolver.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "./dynamic-resolver.service";
import * as i3 from "../plugins";
export class DynamicComponentService extends ExtensionPointForPlugins {
    constructor(rootInjector, router, waitTimeout, dynamicResolver, plugins) {
        super(rootInjector, plugins);
        this.router = router;
        this.waitTimeout = waitTimeout;
        this.dynamicResolver = dynamicResolver;
        this.plugins = plugins;
        this.DEFAULT_WAIT_TIMEOUT = 5000;
        this.items$ = this.setupItemsObservable();
    }
    get state() {
        return this.state$.value;
    }
    /**
     * Returns a component by it's id as an observable.
     * @param id The id of the component.
     */
    getById(id) {
        if (!id) {
            return Promise.resolve(undefined);
        }
        return this.items$
            .pipe(mergeMap((cmps) => cmps), filter((cmp) => cmp.id === id), take(1))
            .toPromise();
    }
    add(component) {
        this.state.add(component);
        this.emitNewState();
    }
    remove(component) {
        this.state.delete(component);
        this.emitNewState();
    }
    async executeResolvers(componentIdAndConfig) {
        const dynamicDef = await Promise.all(componentIdAndConfig.map(({ componentId }) => this.getById(componentId)));
        const result = await this.dynamicResolver.executeResolvers(componentIdAndConfig, dynamicDef);
        return result;
    }
    async serializeConfigs(componentIdAndConfig) {
        const dynamicDef = await Promise.all(componentIdAndConfig.map(({ componentId }) => this.getById(componentId)));
        return this.dynamicResolver.serialize(componentIdAndConfig, dynamicDef);
    }
    setupItemsObservable() {
        const remotesLoaded$ = this.plugins.allPluginsLoaded$.pipe(filter(loaded => !!loaded), take(1));
        return fromTriggerOnce(this.router, this.refresh$, [
            getInjectedHooks(HOOK_COMPONENTS, this.injectors),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(distinctUntilChanged(), takeUntil(combineLatest([timer(this.waitTimeout || this.DEFAULT_WAIT_TIMEOUT), remotesLoaded$])), shareReplay(1));
    }
}
DynamicComponentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DynamicComponentService, deps: [{ token: i0.Injector }, { token: i1.Router }, { token: RESOLVING_COMPONENT_WAIT_TIME, optional: true }, { token: i2.DynamicResolverService }, { token: i3.PluginsResolveService }], target: i0.ɵɵFactoryTarget.Injectable });
DynamicComponentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DynamicComponentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DynamicComponentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.Router }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [RESOLVING_COMPONENT_WAIT_TIME]
                }] }, { type: i2.DynamicResolverService }, { type: i3.PluginsResolveService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1jb21wb25lbnQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvZHluYW1pYy1jb21wb25lbnQvZHluYW1pYy1jb21wb25lbnQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QyxPQUFPLEVBQUUsYUFBYSxFQUFjLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN4RCxPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLE1BQU0sRUFDTixRQUFRLEVBQ1IsV0FBVyxFQUNYLElBQUksRUFDSixTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQ0wsd0JBQXdCLEVBQ3hCLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsY0FBYyxFQUNmLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ25ELE9BQU8sRUFFTCxlQUFlLEVBQ2YsNkJBQTZCLEVBQzlCLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7Ozs7O0FBS3BFLE1BQU0sT0FBTyx1QkFBd0IsU0FBUSx3QkFBb0Q7SUFHL0YsWUFDRSxZQUFzQixFQUNkLE1BQWMsRUFDcUMsV0FBbUIsRUFDdEUsZUFBdUMsRUFDdkMsT0FBOEI7UUFFdEMsS0FBSyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUxyQixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ3FDLGdCQUFXLEdBQVgsV0FBVyxDQUFRO1FBQ3RFLG9CQUFlLEdBQWYsZUFBZSxDQUF3QjtRQUN2QyxZQUFPLEdBQVAsT0FBTyxDQUF1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QUFDO0lBQ0osQ0FBQzs7b0hBN0VVLHVCQUF1QixnRUFNWiw2QkFBNkI7d0hBTnhDLHVCQUF1QixjQUZ0QixNQUFNOzJGQUVQLHVCQUF1QjtrQkFIbkMsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7OzBCQU9JLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsNkJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3RvciwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlLCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXG4gIGZpbHRlcixcbiAgbWVyZ2VNYXAsXG4gIHNoYXJlUmVwbGF5LFxuICB0YWtlLFxuICB0YWtlVW50aWxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRXh0ZW5zaW9uUG9pbnRGb3JQbHVnaW5zLFxuICBmcm9tVHJpZ2dlck9uY2UsXG4gIGdldEluamVjdGVkSG9va3MsXG4gIHN0YXRlVG9GYWN0b3J5XG59IGZyb20gJy4uL2NvbW1vbi9leHRlbnNpb24taG9va3MnO1xuaW1wb3J0IHsgUGx1Z2luc1Jlc29sdmVTZXJ2aWNlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQge1xuICBEeW5hbWljQ29tcG9uZW50RGVmaW5pdGlvbixcbiAgSE9PS19DT01QT05FTlRTLFxuICBSRVNPTFZJTkdfQ09NUE9ORU5UX1dBSVRfVElNRVxufSBmcm9tICcuL2R5bmFtaWMtY29tcG9uZW50Lm1vZGVsJztcbmltcG9ydCB7IER5bmFtaWNSZXNvbHZlclNlcnZpY2UgfSBmcm9tICcuL2R5bmFtaWMtcmVzb2x2ZXIuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIER5bmFtaWNDb21wb25lbnRTZXJ2aWNlIGV4dGVuZHMgRXh0ZW5zaW9uUG9pbnRGb3JQbHVnaW5zPER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uPiB7XG4gIHByaXZhdGUgREVGQVVMVF9XQUlUX1RJTUVPVVQgPSA1MDAwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJvb3RJbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFJFU09MVklOR19DT01QT05FTlRfV0FJVF9USU1FKSBwcml2YXRlIHdhaXRUaW1lb3V0OiBudW1iZXIsXG4gICAgcHJpdmF0ZSBkeW5hbWljUmVzb2x2ZXI6IER5bmFtaWNSZXNvbHZlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBwbHVnaW5zOiBQbHVnaW5zUmVzb2x2ZVNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIocm9vdEluamVjdG9yLCBwbHVnaW5zKTtcbiAgICB0aGlzLml0ZW1zJCA9IHRoaXMuc2V0dXBJdGVtc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvbXBvbmVudCBieSBpdCdzIGlkIGFzIGFuIG9ic2VydmFibGUuXG4gICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGdldEJ5SWQoaWQpOiBQcm9taXNlPER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uPiB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pdGVtcyRcbiAgICAgIC5waXBlKFxuICAgICAgICBtZXJnZU1hcCgoY21wczogRHluYW1pY0NvbXBvbmVudERlZmluaXRpb25bXSkgPT4gY21wcyksXG4gICAgICAgIGZpbHRlcigoY21wOiBEeW5hbWljQ29tcG9uZW50RGVmaW5pdGlvbikgPT4gY21wLmlkID09PSBpZCksXG4gICAgICAgIHRha2UoMSlcbiAgICAgIClcbiAgICAgIC50b1Byb21pc2UoKTtcbiAgfVxuXG4gIGFkZChjb21wb25lbnQ6IER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uKSB7XG4gICAgdGhpcy5zdGF0ZS5hZGQoY29tcG9uZW50KTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgcmVtb3ZlKGNvbXBvbmVudDogRHluYW1pY0NvbXBvbmVudERlZmluaXRpb24pIHtcbiAgICB0aGlzLnN0YXRlLmRlbGV0ZShjb21wb25lbnQpO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cblxuICBhc3luYyBleGVjdXRlUmVzb2x2ZXJzKGNvbXBvbmVudElkQW5kQ29uZmlnOiBBcnJheTx7IGNvbXBvbmVudElkOiBzdHJpbmc7IGNvbmZpZzogYW55IH0+KSB7XG4gICAgY29uc3QgZHluYW1pY0RlZiA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgY29tcG9uZW50SWRBbmRDb25maWcubWFwKCh7IGNvbXBvbmVudElkIH0pID0+IHRoaXMuZ2V0QnlJZChjb21wb25lbnRJZCkpXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmR5bmFtaWNSZXNvbHZlci5leGVjdXRlUmVzb2x2ZXJzKGNvbXBvbmVudElkQW5kQ29uZmlnLCBkeW5hbWljRGVmKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgc2VyaWFsaXplQ29uZmlncyhjb21wb25lbnRJZEFuZENvbmZpZzogQXJyYXk8eyBjb21wb25lbnRJZDogc3RyaW5nOyBjb25maWc6IGFueSB9Pikge1xuICAgIGNvbnN0IGR5bmFtaWNEZWYgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGNvbXBvbmVudElkQW5kQ29uZmlnLm1hcCgoeyBjb21wb25lbnRJZCB9KSA9PiB0aGlzLmdldEJ5SWQoY29tcG9uZW50SWQpKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZHluYW1pY1Jlc29sdmVyLnNlcmlhbGl6ZShjb21wb25lbnRJZEFuZENvbmZpZywgZHluYW1pY0RlZik7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0dXBJdGVtc09ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxEeW5hbWljQ29tcG9uZW50RGVmaW5pdGlvbltdPiB7XG4gICAgY29uc3QgcmVtb3Rlc0xvYWRlZCQgPSB0aGlzLnBsdWdpbnMuYWxsUGx1Z2luc0xvYWRlZCQucGlwZShcbiAgICAgIGZpbHRlcihsb2FkZWQgPT4gISFsb2FkZWQpLFxuICAgICAgdGFrZSgxKVxuICAgICk7XG5cbiAgICByZXR1cm4gZnJvbVRyaWdnZXJPbmNlPER5bmFtaWNDb21wb25lbnREZWZpbml0aW9uPih0aGlzLnJvdXRlciwgdGhpcy5yZWZyZXNoJCwgW1xuICAgICAgZ2V0SW5qZWN0ZWRIb29rczxEeW5hbWljQ29tcG9uZW50RGVmaW5pdGlvbj4oSE9PS19DT01QT05FTlRTLCB0aGlzLmluamVjdG9ycyksXG4gICAgICAoKSA9PiB0aGlzLmZhY3RvcmllcyxcbiAgICAgIHN0YXRlVG9GYWN0b3J5KHRoaXMuc3RhdGUkKVxuICAgIF0pLnBpcGUoXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgdGFrZVVudGlsKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KFt0aW1lcih0aGlzLndhaXRUaW1lb3V0IHx8IHRoaXMuREVGQVVMVF9XQUlUX1RJTUVPVVQpLCByZW1vdGVzTG9hZGVkJF0pXG4gICAgICApLFxuICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICApO1xuICB9XG59XG4iXX0=