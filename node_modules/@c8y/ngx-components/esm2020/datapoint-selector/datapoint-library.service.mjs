import { Injectable } from '@angular/core';
import { InventoryService, MeasurementService } from '@c8y/client';
import { AppStateService, ColorService, MAX_PAGE_SIZE } from '@c8y/ngx-components';
import { get, sortBy, uniq } from 'lodash-es';
import { filter } from 'rxjs/operators';
import { DATAPOINT_LIBRARY_FRAGMENT } from './datapoint-selection.model';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/client";
import * as i2 from "@c8y/ngx-components";
export class DatapointLibraryService {
    constructor(inventory, appState, measurements, color) {
        this.inventory = inventory;
        this.appState = appState;
        this.measurements = measurements;
        this.color = color;
        this.appState.currentUser.pipe(filter(user => !user)).subscribe(() => {
            this.cache = undefined;
        });
    }
    async getAllDatapointLibraryEntriesCached(forceCacheRenew = false) {
        if (forceCacheRenew) {
            this.cache = undefined;
        }
        if (!this.cache) {
            this.cache = this.getAllDatapointLibraryEntries();
        }
        return this.cache;
    }
    async getFirstDatapointLibraryPage() {
        const filterObj = {
            currentPage: 1,
            pageSize: 50,
            fragmentType: DATAPOINT_LIBRARY_FRAGMENT,
            withTotalPages: true
        };
        return (await this.inventory.list(filterObj));
    }
    async getAllDatapointLibraryItemsCached() {
        if (!this.cache) {
            this.cache = this.getAllDatapointLibraryEntries();
        }
        const res = await this.cache;
        return res.map(tmp => tmp[DATAPOINT_LIBRARY_FRAGMENT]);
    }
    async updateDatapoints(datapoints, skipUpdatingTarget = false) {
        if (!Array.isArray(datapoints)) {
            return datapoints;
        }
        const currentTargetsPromise = !skipUpdatingTarget
            ? this.getCurrentVersionOfTargetsFromDatapoints(datapoints)
            : Promise.resolve([]);
        const [currentTemplates, currentTargets] = await Promise.all([
            this.getCurrentTemplatesFromDatapoints(datapoints),
            currentTargetsPromise
        ]);
        const currentTemplateVersions = currentTemplates
            .map(tmp => this.mapDatapointLibraryEntry(tmp))
            .filter(tmp => !!tmp);
        for (const datapoint of datapoints) {
            const { fragment, series, __active, __target, color, label, __template } = datapoint;
            const foundCurrentTemplateVersion = currentTemplateVersions.find(tmp => tmp.__template === datapoint.__template);
            if (foundCurrentTemplateVersion) {
                Object.assign(datapoint, foundCurrentTemplateVersion);
                Object.assign(datapoint, {
                    fragment,
                    series,
                    __active,
                    __target,
                    color,
                    label,
                    __template
                });
            }
            const foundCurrentTarget = currentTargets.find(target => target.id === __target?.id);
            if (foundCurrentTarget) {
                const { id, name } = foundCurrentTarget;
                datapoint.__target = { id, name };
            }
        }
        return datapoints;
    }
    async getDatapointsOfAsset(parentReference, ignoreDatapointTemplates) {
        const [kpiResponse, details] = await Promise.all([
            (ignoreDatapointTemplates
                ? Promise.resolve(null)
                : this.inventory.assetKPIsList(parentReference, { pageSize: MAX_PAGE_SIZE })),
            this.inventory.getMeasurementsAndSeries(parentReference)
        ]);
        const kpis = kpiResponse && kpiResponse.data ? kpiResponse.data : [];
        const sortedDetails = sortBy(details, ['fragment', 'series']);
        return await this.combineFragmentSeriesTuplesWithDetails(sortedDetails, parentReference, kpis);
    }
    /**
     * Requests the last measurement with the given fragment and series to extract it's unit.
     * If the source attribute is provided, it will check the last measurement for this specific source.
     * @returns found unit or an empty string instead
     */
    async guessUnitOfDatapoint(fragment, series, source) {
        const measurementfilter = {
            valueFragmentSeries: series,
            valueFragmentType: fragment,
            pageSize: 1,
            revert: true,
            dateFrom: '1970-01-01'
        };
        if (source?.id) {
            measurementfilter.source = source?.id;
        }
        try {
            const { data: lastMeasurements } = await this.measurements.list(measurementfilter);
            const measurement = lastMeasurements[0];
            if (measurement) {
                const pathToUnit = `${fragment}.${series}.unit`;
                const unit = get(measurement, pathToUnit);
                if (unit?.length && typeof unit === 'string') {
                    return unit;
                }
            }
        }
        catch {
            // nothing to do
        }
        return '';
    }
    async combineFragmentSeriesTuplesWithDetails(tuples, target, kpis) {
        const datapoints = tuples.map(tuple => {
            const foundDatapointLibraryEntry = kpis.find(kpi => kpi[DATAPOINT_LIBRARY_FRAGMENT] &&
                kpi[DATAPOINT_LIBRARY_FRAGMENT].fragment === tuple.fragment &&
                kpi[DATAPOINT_LIBRARY_FRAGMENT].series === tuple.series);
            const datapoint = this.mapDatapointLibraryEntry(foundDatapointLibraryEntry) || tuple;
            if (!datapoint.label) {
                datapoint.label = `${datapoint.fragment} → ${datapoint.series}`;
            }
            if (!datapoint.unit?.length) {
                datapoint.unit = '';
            }
            datapoint.__target = target;
            return datapoint;
        });
        await this.assignColorToDatapoints(datapoints);
        return datapoints;
    }
    async assignColorToDatapoints(datapoints) {
        const datapointsWithoutColor = datapoints.filter(datapoint => !datapoint.color);
        await Promise.all(datapointsWithoutColor.map(datapoint => this.color
            .generateColorForDatapoint(datapoint.fragment, datapoint.series)
            .then(color => (datapoint.color = color))));
    }
    async getAllDatapointLibraryEntries() {
        const entries = new Array();
        const filterObj = {
            currentPage: 1,
            pageSize: MAX_PAGE_SIZE,
            fragmentType: DATAPOINT_LIBRARY_FRAGMENT
        };
        let res = await this.inventory.list(filterObj);
        while (res.data.length) {
            entries.push(...res.data);
            if (res.data.length < res.paging.pageSize) {
                break;
            }
            if (!res.paging.nextPage) {
                break;
            }
            res = await res.paging.next();
        }
        return entries;
    }
    mapDatapointLibraryEntry(entry) {
        if (!entry || !entry[DATAPOINT_LIBRARY_FRAGMENT]) {
            return null;
        }
        const datapoint = entry[DATAPOINT_LIBRARY_FRAGMENT];
        datapoint.__template = entry.id;
        return datapoint;
    }
    async getCurrentTemplatesFromDatapoints(datapoints) {
        const datapointsWithTemplateId = datapoints.filter(dp => !!dp.__template);
        const usedTemplateIds = datapointsWithTemplateId.map(dp => dp.__template);
        return await this.getMOsByIds(usedTemplateIds);
    }
    async getCurrentVersionOfTargetsFromDatapoints(datapoints) {
        const datapointsWithTarget = datapoints.filter(dp => !!dp.__target?.id);
        const usedTargetIds = datapointsWithTarget.map(dp => dp.__target.id);
        return await this.getMOsByIds(usedTargetIds);
    }
    async getMOsByIds(ids) {
        const uniqManagedObjectIds = uniq(ids);
        if (!uniqManagedObjectIds.length) {
            return [];
        }
        try {
            const { data: managedObjects } = await this.inventory.list({
                ids: uniqManagedObjectIds.join(),
                pageSize: MAX_PAGE_SIZE
            });
            return managedObjects;
        }
        catch {
            // Fail silently in case we are not able to talk to the inventory API.
            // Should only be reached in case of an server side error.
            // instead of failing, pretend like we didn't receive any items.
            console.warn(`Failed to get the current version of the following managedObjects: ${uniqManagedObjectIds.join()}.`);
            return [];
        }
    }
}
DatapointLibraryService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DatapointLibraryService, deps: [{ token: i1.InventoryService }, { token: i2.AppStateService }, { token: i1.MeasurementService }, { token: i2.ColorService }], target: i0.ɵɵFactoryTarget.Injectable });
DatapointLibraryService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DatapointLibraryService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: DatapointLibraryService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.InventoryService }, { type: i2.AppStateService }, { type: i1.MeasurementService }, { type: i2.ColorService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXBvaW50LWxpYnJhcnkuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2RhdGFwb2ludC1zZWxlY3Rvci9kYXRhcG9pbnQtbGlicmFyeS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUdMLGdCQUFnQixFQUVoQixrQkFBa0IsRUFDbkIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLGVBQWUsRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDbkYsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQzlDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QyxPQUFPLEVBQ0wsMEJBQTBCLEVBRzNCLE1BQU0sNkJBQTZCLENBQUM7Ozs7QUFHckMsTUFBTSxPQUFPLHVCQUF1QjtJQUVsQyxZQUNVLFNBQTJCLEVBQzNCLFFBQXlCLEVBQ3pCLFlBQWdDLEVBQ2hDLEtBQW1CO1FBSG5CLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBQzNCLGFBQVEsR0FBUixRQUFRLENBQWlCO1FBQ3pCLGlCQUFZLEdBQVosWUFBWSxDQUFvQjtRQUNoQyxVQUFLLEdBQUwsS0FBSyxDQUFjO1FBRTNCLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUNuRSxJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztRQUN6QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxLQUFLLENBQUMsbUNBQW1DLENBQUMsZUFBZSxHQUFHLEtBQUs7UUFDL0QsSUFBSSxl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b0hBclBVLHVCQUF1Qjt3SEFBdkIsdUJBQXVCLGNBRFYsTUFBTTsyRkFDbkIsdUJBQXVCO2tCQURuQyxVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIElJZGVudGlmaWVkLFxuICBJTWFuYWdlZE9iamVjdCxcbiAgSW52ZW50b3J5U2VydmljZSxcbiAgSVJlc3VsdExpc3QsXG4gIE1lYXN1cmVtZW50U2VydmljZVxufSBmcm9tICdAYzh5L2NsaWVudCc7XG5pbXBvcnQgeyBBcHBTdGF0ZVNlcnZpY2UsIENvbG9yU2VydmljZSwgTUFYX1BBR0VfU0laRSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgZ2V0LCBzb3J0QnksIHVuaXEgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgREFUQVBPSU5UX0xJQlJBUllfRlJBR01FTlQsXG4gIEtQSURldGFpbHMsXG4gIE1hbmFnZWRPYmplY3RLUElcbn0gZnJvbSAnLi9kYXRhcG9pbnQtc2VsZWN0aW9uLm1vZGVsJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBEYXRhcG9pbnRMaWJyYXJ5U2VydmljZSB7XG4gIHByb3RlY3RlZCBjYWNoZTogUHJvbWlzZTxNYW5hZ2VkT2JqZWN0S1BJW10+O1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGludmVudG9yeTogSW52ZW50b3J5U2VydmljZSxcbiAgICBwcml2YXRlIGFwcFN0YXRlOiBBcHBTdGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBtZWFzdXJlbWVudHM6IE1lYXN1cmVtZW50U2VydmljZSxcbiAgICBwcml2YXRlIGNvbG9yOiBDb2xvclNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5hcHBTdGF0ZS5jdXJyZW50VXNlci5waXBlKGZpbHRlcih1c2VyID0+ICF1c2VyKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxEYXRhcG9pbnRMaWJyYXJ5RW50cmllc0NhY2hlZChmb3JjZUNhY2hlUmVuZXcgPSBmYWxzZSk6IFByb21pc2U8TWFuYWdlZE9iamVjdEtQSVtdPiB7XG4gICAgaWYgKGZvcmNlQ2FjaGVSZW5ldykge1xuICAgICAgdGhpcy5jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5nZXRBbGxEYXRhcG9pbnRMaWJyYXJ5RW50cmllcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgfVxuXG4gIGFzeW5jIGdldEZpcnN0RGF0YXBvaW50TGlicmFyeVBhZ2UoKTogUHJvbWlzZTxJUmVzdWx0TGlzdDxNYW5hZ2VkT2JqZWN0S1BJPj4ge1xuICAgIGNvbnN0IGZpbHRlck9iaiA9IHtcbiAgICAgIGN1cnJlbnRQYWdlOiAxLFxuICAgICAgcGFnZVNpemU6IDUwLFxuICAgICAgZnJhZ21lbnRUeXBlOiBEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVCxcbiAgICAgIHdpdGhUb3RhbFBhZ2VzOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuaW52ZW50b3J5Lmxpc3QoZmlsdGVyT2JqKSkgYXMgSVJlc3VsdExpc3Q8TWFuYWdlZE9iamVjdEtQST47XG4gIH1cblxuICBhc3luYyBnZXRBbGxEYXRhcG9pbnRMaWJyYXJ5SXRlbXNDYWNoZWQoKTogUHJvbWlzZTxLUElEZXRhaWxzW10+IHtcbiAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmdldEFsbERhdGFwb2ludExpYnJhcnlFbnRyaWVzKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2FjaGU7XG4gICAgcmV0dXJuIHJlcy5tYXAodG1wID0+IHRtcFtEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVF0pO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlRGF0YXBvaW50cyhcbiAgICBkYXRhcG9pbnRzOiBLUElEZXRhaWxzW10sXG4gICAgc2tpcFVwZGF0aW5nVGFyZ2V0ID0gZmFsc2VcbiAgKTogUHJvbWlzZTxLUElEZXRhaWxzW10+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YXBvaW50cykpIHtcbiAgICAgIHJldHVybiBkYXRhcG9pbnRzO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGFyZ2V0c1Byb21pc2U6IFByb21pc2U8SU1hbmFnZWRPYmplY3RbXT4gPSAhc2tpcFVwZGF0aW5nVGFyZ2V0XG4gICAgICA/IHRoaXMuZ2V0Q3VycmVudFZlcnNpb25PZlRhcmdldHNGcm9tRGF0YXBvaW50cyhkYXRhcG9pbnRzKVxuICAgICAgOiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIGNvbnN0IFtjdXJyZW50VGVtcGxhdGVzLCBjdXJyZW50VGFyZ2V0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLmdldEN1cnJlbnRUZW1wbGF0ZXNGcm9tRGF0YXBvaW50cyhkYXRhcG9pbnRzKSxcbiAgICAgIGN1cnJlbnRUYXJnZXRzUHJvbWlzZVxuICAgIF0pO1xuICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZVZlcnNpb25zID0gY3VycmVudFRlbXBsYXRlc1xuICAgICAgLm1hcCh0bXAgPT4gdGhpcy5tYXBEYXRhcG9pbnRMaWJyYXJ5RW50cnkodG1wIGFzIE1hbmFnZWRPYmplY3RLUEkpKVxuICAgICAgLmZpbHRlcih0bXAgPT4gISF0bXApO1xuICAgIGZvciAoY29uc3QgZGF0YXBvaW50IG9mIGRhdGFwb2ludHMpIHtcbiAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHNlcmllcywgX19hY3RpdmUsIF9fdGFyZ2V0LCBjb2xvciwgbGFiZWwsIF9fdGVtcGxhdGUgfSA9IGRhdGFwb2ludDtcbiAgICAgIGNvbnN0IGZvdW5kQ3VycmVudFRlbXBsYXRlVmVyc2lvbiA9IGN1cnJlbnRUZW1wbGF0ZVZlcnNpb25zLmZpbmQoXG4gICAgICAgIHRtcCA9PiB0bXAuX190ZW1wbGF0ZSA9PT0gZGF0YXBvaW50Ll9fdGVtcGxhdGVcbiAgICAgICk7XG4gICAgICBpZiAoZm91bmRDdXJyZW50VGVtcGxhdGVWZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YXBvaW50LCBmb3VuZEN1cnJlbnRUZW1wbGF0ZVZlcnNpb24pO1xuICAgICAgICBPYmplY3QuYXNzaWduKGRhdGFwb2ludCwge1xuICAgICAgICAgIGZyYWdtZW50LFxuICAgICAgICAgIHNlcmllcyxcbiAgICAgICAgICBfX2FjdGl2ZSxcbiAgICAgICAgICBfX3RhcmdldCxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICBfX3RlbXBsYXRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3VuZEN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0cy5maW5kKHRhcmdldCA9PiB0YXJnZXQuaWQgPT09IF9fdGFyZ2V0Py5pZCk7XG4gICAgICBpZiAoZm91bmRDdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHsgaWQsIG5hbWUgfSA9IGZvdW5kQ3VycmVudFRhcmdldDtcbiAgICAgICAgZGF0YXBvaW50Ll9fdGFyZ2V0ID0geyBpZCwgbmFtZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YXBvaW50cztcbiAgfVxuXG4gIGFzeW5jIGdldERhdGFwb2ludHNPZkFzc2V0KFxuICAgIHBhcmVudFJlZmVyZW5jZTogSUlkZW50aWZpZWQsXG4gICAgaWdub3JlRGF0YXBvaW50VGVtcGxhdGVzPzogYm9vbGVhblxuICApOiBQcm9taXNlPEtQSURldGFpbHNbXT4ge1xuICAgIGNvbnN0IFtrcGlSZXNwb25zZSwgZGV0YWlsc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAoaWdub3JlRGF0YXBvaW50VGVtcGxhdGVzXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKG51bGwpXG4gICAgICAgIDogdGhpcy5pbnZlbnRvcnkuYXNzZXRLUElzTGlzdChwYXJlbnRSZWZlcmVuY2UsIHsgcGFnZVNpemU6IE1BWF9QQUdFX1NJWkUgfSkpIGFzIFByb21pc2U8XG4gICAgICAgIElSZXN1bHRMaXN0PE1hbmFnZWRPYmplY3RLUEk+XG4gICAgICA+LFxuICAgICAgdGhpcy5pbnZlbnRvcnkuZ2V0TWVhc3VyZW1lbnRzQW5kU2VyaWVzKHBhcmVudFJlZmVyZW5jZSlcbiAgICBdKTtcbiAgICBjb25zdCBrcGlzID0ga3BpUmVzcG9uc2UgJiYga3BpUmVzcG9uc2UuZGF0YSA/IGtwaVJlc3BvbnNlLmRhdGEgOiBbXTtcbiAgICBjb25zdCBzb3J0ZWREZXRhaWxzID0gc29ydEJ5KGRldGFpbHMsIFsnZnJhZ21lbnQnLCAnc2VyaWVzJ10pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29tYmluZUZyYWdtZW50U2VyaWVzVHVwbGVzV2l0aERldGFpbHMoc29ydGVkRGV0YWlscywgcGFyZW50UmVmZXJlbmNlLCBrcGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgbGFzdCBtZWFzdXJlbWVudCB3aXRoIHRoZSBnaXZlbiBmcmFnbWVudCBhbmQgc2VyaWVzIHRvIGV4dHJhY3QgaXQncyB1bml0LlxuICAgKiBJZiB0aGUgc291cmNlIGF0dHJpYnV0ZSBpcyBwcm92aWRlZCwgaXQgd2lsbCBjaGVjayB0aGUgbGFzdCBtZWFzdXJlbWVudCBmb3IgdGhpcyBzcGVjaWZpYyBzb3VyY2UuXG4gICAqIEByZXR1cm5zIGZvdW5kIHVuaXQgb3IgYW4gZW1wdHkgc3RyaW5nIGluc3RlYWRcbiAgICovXG4gIGFzeW5jIGd1ZXNzVW5pdE9mRGF0YXBvaW50KFxuICAgIGZyYWdtZW50OiBzdHJpbmcsXG4gICAgc2VyaWVzOiBzdHJpbmcsXG4gICAgc291cmNlPzogSUlkZW50aWZpZWRcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBtZWFzdXJlbWVudGZpbHRlcjogYW55ID0ge1xuICAgICAgdmFsdWVGcmFnbWVudFNlcmllczogc2VyaWVzLFxuICAgICAgdmFsdWVGcmFnbWVudFR5cGU6IGZyYWdtZW50LFxuICAgICAgcGFnZVNpemU6IDEsXG4gICAgICByZXZlcnQ6IHRydWUsXG4gICAgICBkYXRlRnJvbTogJzE5NzAtMDEtMDEnXG4gICAgfTtcbiAgICBpZiAoc291cmNlPy5pZCkge1xuICAgICAgbWVhc3VyZW1lbnRmaWx0ZXIuc291cmNlID0gc291cmNlPy5pZDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogbGFzdE1lYXN1cmVtZW50cyB9ID0gYXdhaXQgdGhpcy5tZWFzdXJlbWVudHMubGlzdChtZWFzdXJlbWVudGZpbHRlcik7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudCA9IGxhc3RNZWFzdXJlbWVudHNbMF07XG4gICAgICBpZiAobWVhc3VyZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcGF0aFRvVW5pdCA9IGAke2ZyYWdtZW50fS4ke3Nlcmllc30udW5pdGA7XG4gICAgICAgIGNvbnN0IHVuaXQgPSBnZXQobWVhc3VyZW1lbnQsIHBhdGhUb1VuaXQpO1xuICAgICAgICBpZiAodW5pdD8ubGVuZ3RoICYmIHR5cGVvZiB1bml0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB1bml0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBjb21iaW5lRnJhZ21lbnRTZXJpZXNUdXBsZXNXaXRoRGV0YWlscyhcbiAgICB0dXBsZXM6IEFycmF5PHsgZnJhZ21lbnQ6IHN0cmluZzsgc2VyaWVzOiBzdHJpbmcgfT4sXG4gICAgdGFyZ2V0OiBJSWRlbnRpZmllZCxcbiAgICBrcGlzOiBNYW5hZ2VkT2JqZWN0S1BJW11cbiAgKSB7XG4gICAgY29uc3QgZGF0YXBvaW50cyA9IHR1cGxlcy5tYXAodHVwbGUgPT4ge1xuICAgICAgY29uc3QgZm91bmREYXRhcG9pbnRMaWJyYXJ5RW50cnkgPSBrcGlzLmZpbmQoXG4gICAgICAgIGtwaSA9PlxuICAgICAgICAgIGtwaVtEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVF0gJiZcbiAgICAgICAgICBrcGlbREFUQVBPSU5UX0xJQlJBUllfRlJBR01FTlRdLmZyYWdtZW50ID09PSB0dXBsZS5mcmFnbWVudCAmJlxuICAgICAgICAgIGtwaVtEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVF0uc2VyaWVzID09PSB0dXBsZS5zZXJpZXNcbiAgICAgICk7XG4gICAgICBjb25zdCBkYXRhcG9pbnQ6IEtQSURldGFpbHMgPVxuICAgICAgICB0aGlzLm1hcERhdGFwb2ludExpYnJhcnlFbnRyeShmb3VuZERhdGFwb2ludExpYnJhcnlFbnRyeSkgfHwgdHVwbGU7XG4gICAgICBpZiAoIWRhdGFwb2ludC5sYWJlbCkge1xuICAgICAgICBkYXRhcG9pbnQubGFiZWwgPSBgJHtkYXRhcG9pbnQuZnJhZ21lbnR9IOKGkiAke2RhdGFwb2ludC5zZXJpZXN9YDtcbiAgICAgIH1cbiAgICAgIGlmICghZGF0YXBvaW50LnVuaXQ/Lmxlbmd0aCkge1xuICAgICAgICBkYXRhcG9pbnQudW5pdCA9ICcnO1xuICAgICAgfVxuICAgICAgZGF0YXBvaW50Ll9fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgcmV0dXJuIGRhdGFwb2ludDtcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmFzc2lnbkNvbG9yVG9EYXRhcG9pbnRzKGRhdGFwb2ludHMpO1xuICAgIHJldHVybiBkYXRhcG9pbnRzO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGFzc2lnbkNvbG9yVG9EYXRhcG9pbnRzKGRhdGFwb2ludHM6IEtQSURldGFpbHNbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRhdGFwb2ludHNXaXRob3V0Q29sb3IgPSBkYXRhcG9pbnRzLmZpbHRlcihkYXRhcG9pbnQgPT4gIWRhdGFwb2ludC5jb2xvcik7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBkYXRhcG9pbnRzV2l0aG91dENvbG9yLm1hcChkYXRhcG9pbnQgPT5cbiAgICAgICAgdGhpcy5jb2xvclxuICAgICAgICAgIC5nZW5lcmF0ZUNvbG9yRm9yRGF0YXBvaW50KGRhdGFwb2ludC5mcmFnbWVudCwgZGF0YXBvaW50LnNlcmllcylcbiAgICAgICAgICAudGhlbihjb2xvciA9PiAoZGF0YXBvaW50LmNvbG9yID0gY29sb3IpKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWxsRGF0YXBvaW50TGlicmFyeUVudHJpZXMoKTogUHJvbWlzZTxNYW5hZ2VkT2JqZWN0S1BJW10+IHtcbiAgICBjb25zdCBlbnRyaWVzID0gbmV3IEFycmF5PE1hbmFnZWRPYmplY3RLUEk+KCk7XG4gICAgY29uc3QgZmlsdGVyT2JqID0ge1xuICAgICAgY3VycmVudFBhZ2U6IDEsXG4gICAgICBwYWdlU2l6ZTogTUFYX1BBR0VfU0laRSxcbiAgICAgIGZyYWdtZW50VHlwZTogREFUQVBPSU5UX0xJQlJBUllfRlJBR01FTlRcbiAgICB9O1xuICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLmludmVudG9yeS5saXN0KGZpbHRlck9iaik7XG4gICAgd2hpbGUgKHJlcy5kYXRhLmxlbmd0aCkge1xuICAgICAgZW50cmllcy5wdXNoKC4uLihyZXMuZGF0YSBhcyBNYW5hZ2VkT2JqZWN0S1BJW10pKTtcbiAgICAgIGlmIChyZXMuZGF0YS5sZW5ndGggPCByZXMucGFnaW5nLnBhZ2VTaXplKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXMucGFnaW5nLm5leHRQYWdlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXMgPSBhd2FpdCByZXMucGFnaW5nLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWFwRGF0YXBvaW50TGlicmFyeUVudHJ5KGVudHJ5OiBNYW5hZ2VkT2JqZWN0S1BJKTogS1BJRGV0YWlscyB7XG4gICAgaWYgKCFlbnRyeSB8fCAhZW50cnlbREFUQVBPSU5UX0xJQlJBUllfRlJBR01FTlRdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhcG9pbnQgPSBlbnRyeVtEQVRBUE9JTlRfTElCUkFSWV9GUkFHTUVOVF07XG4gICAgZGF0YXBvaW50Ll9fdGVtcGxhdGUgPSBlbnRyeS5pZDtcbiAgICByZXR1cm4gZGF0YXBvaW50O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEN1cnJlbnRUZW1wbGF0ZXNGcm9tRGF0YXBvaW50cyhcbiAgICBkYXRhcG9pbnRzOiBLUElEZXRhaWxzW11cbiAgKTogUHJvbWlzZTxJTWFuYWdlZE9iamVjdFtdPiB7XG4gICAgY29uc3QgZGF0YXBvaW50c1dpdGhUZW1wbGF0ZUlkID0gZGF0YXBvaW50cy5maWx0ZXIoZHAgPT4gISFkcC5fX3RlbXBsYXRlKTtcbiAgICBjb25zdCB1c2VkVGVtcGxhdGVJZHMgPSBkYXRhcG9pbnRzV2l0aFRlbXBsYXRlSWQubWFwKGRwID0+IGRwLl9fdGVtcGxhdGUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE1Pc0J5SWRzKHVzZWRUZW1wbGF0ZUlkcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0Q3VycmVudFZlcnNpb25PZlRhcmdldHNGcm9tRGF0YXBvaW50cyhcbiAgICBkYXRhcG9pbnRzOiBLUElEZXRhaWxzW11cbiAgKTogUHJvbWlzZTxJTWFuYWdlZE9iamVjdFtdPiB7XG4gICAgY29uc3QgZGF0YXBvaW50c1dpdGhUYXJnZXQgPSBkYXRhcG9pbnRzLmZpbHRlcihkcCA9PiAhIWRwLl9fdGFyZ2V0Py5pZCk7XG4gICAgY29uc3QgdXNlZFRhcmdldElkcyA9IGRhdGFwb2ludHNXaXRoVGFyZ2V0Lm1hcChkcCA9PiBkcC5fX3RhcmdldC5pZCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TU9zQnlJZHModXNlZFRhcmdldElkcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0TU9zQnlJZHMoaWRzOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KTogUHJvbWlzZTxJTWFuYWdlZE9iamVjdFtdPiB7XG4gICAgY29uc3QgdW5pcU1hbmFnZWRPYmplY3RJZHMgPSB1bmlxKGlkcyk7XG4gICAgaWYgKCF1bmlxTWFuYWdlZE9iamVjdElkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogbWFuYWdlZE9iamVjdHMgfSA9IGF3YWl0IHRoaXMuaW52ZW50b3J5Lmxpc3Qoe1xuICAgICAgICBpZHM6IHVuaXFNYW5hZ2VkT2JqZWN0SWRzLmpvaW4oKSxcbiAgICAgICAgcGFnZVNpemU6IE1BWF9QQUdFX1NJWkVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hbmFnZWRPYmplY3RzO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gRmFpbCBzaWxlbnRseSBpbiBjYXNlIHdlIGFyZSBub3QgYWJsZSB0byB0YWxrIHRvIHRoZSBpbnZlbnRvcnkgQVBJLlxuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgcmVhY2hlZCBpbiBjYXNlIG9mIGFuIHNlcnZlciBzaWRlIGVycm9yLlxuICAgICAgLy8gaW5zdGVhZCBvZiBmYWlsaW5nLCBwcmV0ZW5kIGxpa2Ugd2UgZGlkbid0IHJlY2VpdmUgYW55IGl0ZW1zLlxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIGdldCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBmb2xsb3dpbmcgbWFuYWdlZE9iamVjdHM6ICR7dW5pcU1hbmFnZWRPYmplY3RJZHMuam9pbigpfS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuIl19