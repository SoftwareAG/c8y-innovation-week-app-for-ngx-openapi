import { Injectable } from '@angular/core';
import { Router, NavigationEnd, ActivatedRoute } from '@angular/router';
import { filter, map } from 'rxjs/operators';
import { InventoryBinaryService, InventoryService } from '@c8y/client';
import { AlertService, gettext, ModalService, Status } from '@c8y/ngx-components';
import { saveAs } from 'file-saver';
import { isUndefined } from 'lodash-es';
import { TranslateService } from '@ngx-translate/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "@c8y/client";
import * as i3 from "@c8y/ngx-components";
import * as i4 from "@ngx-translate/core";
export class BinaryFileDownloadService {
    constructor(router, route, inventoryService, alertService, modalService, translate, inventoryBinary) {
        this.router = router;
        this.route = route;
        this.inventoryService = inventoryService;
        this.alertService = alertService;
        this.modalService = modalService;
        this.translate = translate;
        this.inventoryBinary = inventoryBinary;
    }
    run() {
        this.router.events
            .pipe(filter(event => {
            return event instanceof NavigationEnd && this.route.snapshot.queryParams.download;
        }), map(() => this.route.snapshot.queryParams.download))
            .subscribe(async (downloadId) => {
            try {
                const { data } = await this.inventoryService.detail(downloadId);
                if (!isUndefined(data.c8y_IsBinary)) {
                    this.showDownloadModal(data);
                }
                else {
                    const alertMessage = this.translate.instant(gettext('Could not download the file: object with ID "{{ id }}" is not a valid binary.'), { id: data.id });
                    this.alertService.danger(alertMessage);
                }
            }
            catch (ex) {
                this.alertService.addServerFailure(ex);
            }
        });
    }
    async showDownloadModal(binaryMo) {
        try {
            const modalBody = this.translate.instant(gettext('You are about to download file "{{ fileName }}". Do you want to proceed?'), { fileName: binaryMo.name });
            await this.modalService.confirm(gettext('File download'), modalBody, Status.INFO, {
                ok: gettext('Download')
            });
            const arrayBuffer = await this.getArrayBuffer(binaryMo.id);
            const fileBinary = new File([arrayBuffer], binaryMo.name, { type: binaryMo.contentType });
            saveAs(fileBinary);
        }
        catch (e) {
            // empty body :(
            console.log({ e });
        }
    }
    async getArrayBuffer(binaryId) {
        let arrayBuffer;
        try {
            const res = await this.inventoryBinary.download(binaryId);
            arrayBuffer = await res.arrayBuffer();
        }
        catch (ex) {
            const msg = gettext('Could not get the binary.');
            this.alertService.danger(msg);
        }
        return arrayBuffer;
    }
}
BinaryFileDownloadService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: BinaryFileDownloadService, deps: [{ token: i1.Router }, { token: i1.ActivatedRoute }, { token: i2.InventoryService }, { token: i3.AlertService }, { token: i3.ModalService }, { token: i4.TranslateService }, { token: i2.InventoryBinaryService }], target: i0.ɵɵFactoryTarget.Injectable });
BinaryFileDownloadService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: BinaryFileDownloadService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.7", ngImport: i0, type: BinaryFileDownloadService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Router }, { type: i1.ActivatedRoute }, { type: i2.InventoryService }, { type: i3.AlertService }, { type: i3.ModalService }, { type: i4.TranslateService }, { type: i2.InventoryBinaryService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmluYXJ5LWZpbGUtZG93bmxvYWQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2JpbmFyeS1maWxlLWRvd25sb2FkL2JpbmFyeS1maWxlLWRvd25sb2FkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN4RSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBa0Isc0JBQXNCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDdkYsT0FBTyxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2xGLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDcEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUN4QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7Ozs7O0FBR3ZELE1BQU0sT0FBTyx5QkFBeUI7SUFDcEMsWUFDVSxNQUFjLEVBQ2QsS0FBcUIsRUFDckIsZ0JBQWtDLEVBQ2xDLFlBQTBCLEVBQzFCLFlBQTBCLEVBQzFCLFNBQTJCLEVBQzNCLGVBQXVDO1FBTnZDLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxVQUFLLEdBQUwsS0FBSyxDQUFnQjtRQUNyQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBQzFCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBQzFCLGNBQVMsR0FBVCxTQUFTLENBQWtCO1FBQzNCLG9CQUFlLEdBQWYsZUFBZSxDQUF3QjtJQUM5QyxDQUFD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eUI7MEhBQXpCLHlCQUF5QjsyRkFBekIseUJBQXlCO2tCQURyQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyLCBOYXZpZ2F0aW9uRW5kLCBBY3RpdmF0ZWRSb3V0ZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElNYW5hZ2VkT2JqZWN0LCBJbnZlbnRvcnlCaW5hcnlTZXJ2aWNlLCBJbnZlbnRvcnlTZXJ2aWNlIH0gZnJvbSAnQGM4eS9jbGllbnQnO1xuaW1wb3J0IHsgQWxlcnRTZXJ2aWNlLCBnZXR0ZXh0LCBNb2RhbFNlcnZpY2UsIFN0YXR1cyB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgc2F2ZUFzIH0gZnJvbSAnZmlsZS1zYXZlcic7XG5pbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCaW5hcnlGaWxlRG93bmxvYWRTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICBwcml2YXRlIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSxcbiAgICBwcml2YXRlIGludmVudG9yeVNlcnZpY2U6IEludmVudG9yeVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBhbGVydFNlcnZpY2U6IEFsZXJ0U2VydmljZSxcbiAgICBwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlLFxuICAgIHByaXZhdGUgdHJhbnNsYXRlOiBUcmFuc2xhdGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgaW52ZW50b3J5QmluYXJ5OiBJbnZlbnRvcnlCaW5hcnlTZXJ2aWNlXG4gICkge31cblxuICBydW4oKSB7XG4gICAgdGhpcy5yb3V0ZXIuZXZlbnRzXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kICYmIHRoaXMucm91dGUuc25hcHNob3QucXVlcnlQYXJhbXMuZG93bmxvYWQ7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKCkgPT4gdGhpcy5yb3V0ZS5zbmFwc2hvdC5xdWVyeVBhcmFtcy5kb3dubG9hZClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoYXN5bmMgZG93bmxvYWRJZCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLmludmVudG9yeVNlcnZpY2UuZGV0YWlsKGRvd25sb2FkSWQpO1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZGF0YS5jOHlfSXNCaW5hcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dEb3dubG9hZE1vZGFsKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbGVydE1lc3NhZ2UgPSB0aGlzLnRyYW5zbGF0ZS5pbnN0YW50KFxuICAgICAgICAgICAgICBnZXR0ZXh0KFxuICAgICAgICAgICAgICAgICdDb3VsZCBub3QgZG93bmxvYWQgdGhlIGZpbGU6IG9iamVjdCB3aXRoIElEIFwie3sgaWQgfX1cIiBpcyBub3QgYSB2YWxpZCBiaW5hcnkuJ1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB7IGlkOiBkYXRhLmlkIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFsZXJ0U2VydmljZS5kYW5nZXIoYWxlcnRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgdGhpcy5hbGVydFNlcnZpY2UuYWRkU2VydmVyRmFpbHVyZShleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2hvd0Rvd25sb2FkTW9kYWwoYmluYXJ5TW86IElNYW5hZ2VkT2JqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1vZGFsQm9keSA9IHRoaXMudHJhbnNsYXRlLmluc3RhbnQoXG4gICAgICAgIGdldHRleHQoJ1lvdSBhcmUgYWJvdXQgdG8gZG93bmxvYWQgZmlsZSBcInt7IGZpbGVOYW1lIH19XCIuIERvIHlvdSB3YW50IHRvIHByb2NlZWQ/JyksXG4gICAgICAgIHsgZmlsZU5hbWU6IGJpbmFyeU1vLm5hbWUgfVxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMubW9kYWxTZXJ2aWNlLmNvbmZpcm0oZ2V0dGV4dCgnRmlsZSBkb3dubG9hZCcpLCBtb2RhbEJvZHksIFN0YXR1cy5JTkZPLCB7XG4gICAgICAgIG9rOiBnZXR0ZXh0KCdEb3dubG9hZCcpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy5nZXRBcnJheUJ1ZmZlcihiaW5hcnlNby5pZCk7XG4gICAgICBjb25zdCBmaWxlQmluYXJ5ID0gbmV3IEZpbGUoW2FycmF5QnVmZmVyXSwgYmluYXJ5TW8ubmFtZSwgeyB0eXBlOiBiaW5hcnlNby5jb250ZW50VHlwZSB9KTtcbiAgICAgIHNhdmVBcyhmaWxlQmluYXJ5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlbXB0eSBib2R5IDooXG4gICAgICBjb25zb2xlLmxvZyh7IGUgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRBcnJheUJ1ZmZlcihiaW5hcnlJZCk6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICBsZXQgYXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmludmVudG9yeUJpbmFyeS5kb3dubG9hZChiaW5hcnlJZCk7XG4gICAgICBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjb25zdCBtc2cgPSBnZXR0ZXh0KCdDb3VsZCBub3QgZ2V0IHRoZSBiaW5hcnkuJyk7XG4gICAgICB0aGlzLmFsZXJ0U2VydmljZS5kYW5nZXIobXNnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gIH1cbn1cbiJdfQ==