"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScaffoldCommand = void 0;
const Commands_1 = require("./Commands");
const path = require("path");
const pacote = require("pacote");
const inquirer = require("inquirer");
const fetch = require("node-fetch");
const semver = require("semver");
const options_1 = require("../options");
const util_1 = require("util");
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const sanitizeFilename = require("sanitize-filename");
class ScaffoldCommand extends Commands_1.Commands {
    constructor() {
        super(...arguments);
        this.cliInterface = false;
        this.appPackageInterface = options_1.options['PACKAGE.BASE_TEMPLATE'];
        this.name = 'new [name] [template]';
        this.description = options_1.options['TXT.NEW'];
        this.defaultAppPackage = options_1.options['PACKAGE.BASE_TEMPLATE'];
        this.versionsList = [];
        this.options = [
            {
                name: '-r, --registry <registryUrl>',
                description: options_1.options['TXT.NPM_REGISTRY']
            },
            {
                name: '-a, --appPackage <packageName>',
                description: options_1.options['TXT.NPM_PACKAGE_NAME'](this.defaultAppPackage)
            },
            {
                name: '--ci',
                description: options_1.options['TXT.SCAFFOLD.CI']
            }
        ];
        this.appName = '';
        this.appToCopy = '';
        this.tempFolder = '__appsTemp';
    }
    get sanatizedName() {
        return sanitizeFilename(this.appName).toLowerCase().replace(/\s+/g, '-');
    }
    get brandingPackage() {
        return options_1.options['PACKAGE.BASE_BRANDING'];
    }
    get pkgApps() {
        return options_1.options['PACKAGE.APPS'];
    }
    get cliPackage() {
        return options_1.options['PACKAGE.CLI'];
    }
    get clientPackage() {
        return options_1.options['PACKAGE.CLIENT'];
    }
    get registry() {
        return this.getOption('registry') || options_1.options.NPM_REGISTRY;
    }
    get appPackage() {
        return this.getOption('appPackage') || this.defaultAppPackage;
    }
    getLatestReleases(latest, next) {
        let temp = [];
        const shownVersions = [];
        const latestReleases = [];
        let majorReleases = [...new Set(this.versionsList.map(a => a.split('.')[0]))];
        majorReleases = majorReleases.sort((a, b) => b - a).slice(0, 5); // get the 5 highest MAJOR versions.
        majorReleases.forEach(release => {
            if (release !== latest.split('.')[0]) {
                this.versionsList.forEach(version => {
                    if (this.isGaRelease(release, version)) {
                        temp.push(version);
                    }
                });
                const highest = semver.maxSatisfying(temp, '*');
                if (highest) {
                    shownVersions.push(highest);
                }
                temp = [];
            }
        });
        latestReleases.push(latest + ' (latest)', next + ' (next)', ...shownVersions, 'other');
        return latestReleases;
    }
    isGaRelease(releaseMajorVersionNumber, version) {
        const [majorVersionToCheck, minorVersionToCheck] = version.split('.');
        return releaseMajorVersionNumber === majorVersionToCheck && minorVersionToCheck === '0';
    }
    applicationNamePrompt() {
        return inquirer
            .prompt([
            {
                type: 'input',
                name: 'project_name',
                message: 'Enter the name of the project: ',
                default: 'my-application'
            }
        ])
            .then(answers => {
            this.appName = answers.project_name;
        });
    }
    getAllRelevantVersions() {
        return pacote.packument(options_1.options['PACKAGE.APPS']).then(async (packument) => {
            this.versionsList = Object.keys(packument.versions);
            return this.getLatestReleases(packument['dist-tags'].latest, packument['dist-tags'].next);
        });
    }
    otherVersionSelectedPrompt() {
        return inquirer
            .prompt([
            {
                type: 'input',
                name: 'version_choice',
                message: 'Enter the desired version: '
            }
        ])
            .then(input => {
            this.appPackageInterface = `${options_1.options['PACKAGE.APPS']}@${input.version_choice}`;
            return input.version_choice;
        });
    }
    chooseProjectToScaffoldFrom(availableApps) {
        return inquirer
            .prompt([
            {
                type: 'list',
                name: 'base_project',
                message: 'Which base project do you want to scaffold from?',
                choices: availableApps
            }
        ])
            .then(input => {
            this.appToCopy = input.base_project;
        });
    }
    async action(appName, template) {
        if (!template || !appName) {
            this.cliInterface = true;
            await this.promptInterface(appName);
        }
        else {
            this.appName = appName;
            this.appToCopy = template;
        }
        try {
            await this.ensureDir();
            await this.downloadAppsToTemp();
            console.info(options_1.options['TXT.DOWNLOADED_APPS']);
            await this.copyFiles();
            console.info(options_1.options['TXT.COPIED_FILES']);
            await this.npmInit();
            console.info(options_1.options['TXT.NPM_INITIALIZED']);
            await this.updatePackageJson();
            console.info(options_1.options['TXT.UPDATED_PACKAGE_JSON']);
            await this.removeTemp();
            console.info(options_1.options['TXT.NEW_APPLICATION'](this.sanatizedName));
        }
        catch (e) {
            console.error(options_1.options['TXT.NEW_APPLICATION_FAILED'](this.appName));
            await this.removeTemp();
            throw e;
        }
    }
    async promptInterface(appName) {
        if (!appName) {
            await this.applicationNamePrompt();
        }
        else {
            this.appName = appName;
        }
        const shownVersions = await this.getAllRelevantVersions();
        const selectedVersion = await this.selectBaseVersion(shownVersions);
        const apps = await this.getAllAppsForVersion(selectedVersion);
        const appsWithoutInternalFolders = apps.filter((app) => !app.startsWith('_'));
        if (apps.length === 0) {
            console.error(options_1.options['TXT.NONEXISTING_VERSION']);
            return;
        }
        await this.chooseProjectToScaffoldFrom(appsWithoutInternalFolders);
    }
    async selectBaseVersion(shownVersions) {
        return inquirer
            .prompt([
            {
                type: 'list',
                name: 'base_version',
                message: 'Which base version do you want to scaffold from?',
                choices: shownVersions
            }
        ])
            .then(async (answers) => {
            this.appPackageInterface = `${options_1.options['PACKAGE.APPS']}@${answers.base_version}`;
            if (answers.base_version.includes('latest') || answers.base_version.includes('next')) {
                // Check if latest or next was selected and clean the string to include only the version.
                answers.base_version = answers.base_version.split(' (')[0];
                this.appPackageInterface = `${options_1.options['PACKAGE.APPS']}@${answers.base_version}`;
            }
            else if (answers.base_version === 'other') {
                answers.base_version = await this.otherVersionSelectedPrompt();
            }
            return answers.base_version;
        });
    }
    async getAllAppsForVersion(selectedVersion) {
        let apps = [];
        const url = `${options_1.options.C8Y_APPS_NPM_URL}/apps@${selectedVersion}/?meta`;
        if (this.versionsList.includes(selectedVersion)) {
            try {
                await fetch(url)
                    .then(res => res.json())
                    .then(json => {
                    apps = json.files.filter(obj => {
                        return obj.type === 'directory';
                    });
                    apps = apps.map(app => app.path);
                    apps = apps.map(app => app.replace('/', ''));
                    apps.sort((a, b) => a.localeCompare(b));
                });
            }
            catch (e) {
                // if unpkg is down we will return only the default app choices
                return ['administration', 'cockpit', 'devicemanagement', 'tutorial', 'widget-plugin'];
            }
        }
        return apps;
    }
    async ensureDir() {
        return await (0, fs_extra_1.ensureDir)(this.sanatizedName);
    }
    async downloadAppsToTemp() {
        const tempFolder = path.resolve(this.tempFolder);
        if (this.cliInterface) {
            return await pacote.extract(this.appPackageInterface, tempFolder, {
                registry: this.registry
            });
        }
        return await pacote.extract(this.appPackage, tempFolder, { registry: this.registry });
    }
    async copyFiles() {
        const origin = path.resolve(this.tempFolder, this.appToCopy);
        const tests = path.resolve(this.tempFolder, '_test');
        const dest = path.resolve(this.sanatizedName);
        const pkgJson = path.resolve(this.sanatizedName, 'package.json');
        await (0, fs_extra_1.copy)(origin, dest);
        if ((0, fs_extra_1.existsSync)(tests)) {
            await (0, fs_extra_1.copy)(tests, dest);
        }
        return await (0, fs_extra_1.remove)(pkgJson);
    }
    async removeTemp() {
        const tempFolder = path.resolve(this.tempFolder);
        return await (0, fs_extra_1.remove)(tempFolder);
    }
    async npmInit() {
        const dest = path.resolve(this.sanatizedName);
        await (0, util_1.promisify)(child_process_1.exec)('npm init -f', { cwd: dest });
    }
    async updatePackageJson() {
        console.debug(`updatePackageJson called:`);
        const appsManifestPath = path.resolve(this.tempFolder, 'package.json');
        const appsManifest = await (0, fs_extra_1.readJson)(appsManifestPath);
        const appToCopyManifestPath = path.resolve(this.tempFolder, this.appToCopy, 'package.json');
        const appToCopyManifest = await (0, fs_extra_1.readJson)(appToCopyManifestPath);
        const newAppManifestPath = path.resolve(this.sanatizedName, 'package.json');
        const newAppManifest = await (0, fs_extra_1.readJson)(newAppManifestPath);
        console.debug(`\t- JSON files read.`);
        // set version of scaffolded app
        newAppManifest.version = appToCopyManifest.version;
        // TODO: add version for possible branded sdk
        // Version alignment is an issue, we probably will have to  partners to use the same versoning
        const packagesVersion = appsManifest.dependencies['@c8y/ngx-components'];
        newAppManifest.dependencies = Object.assign({}, appsManifest.dependencies, appToCopyManifest.dependencies);
        const brandingPackageVersion = await this.getValidPackageVersion(this.brandingPackage, packagesVersion);
        const clientPackageVersion = await this.getValidPackageVersion(this.clientPackage, packagesVersion);
        const cliPackageVersion = await this.getValidPackageVersion(this.cliPackage, packagesVersion);
        console.debug(`\t- Versions to install retrieved.`);
        newAppManifest.dependencies[this.brandingPackage] = brandingPackageVersion;
        newAppManifest.dependencies[this.clientPackage] = clientPackageVersion;
        newAppManifest.devDependencies = appsManifest.devDependencies;
        newAppManifest.devDependencies[this.cliPackage] = cliPackageVersion;
        newAppManifest.scripts = appToCopyManifest.scripts;
        for (const script in newAppManifest.scripts) {
            if (newAppManifest.scripts.hasOwnProperty(script)) {
                newAppManifest.scripts[script] = newAppManifest.scripts[script].replace(/c8ycli/, options_1.options.BIN);
            }
        }
        console.debug(`\t- replaced cli binary in scripts`);
        newAppManifest.c8y = appToCopyManifest.c8y || {};
        newAppManifest.c8y.application = newAppManifest.c8y.application || {};
        newAppManifest.browserslist = appToCopyManifest.browserslist;
        Object.assign(newAppManifest.c8y.application, {
            name: this.appName,
            contextPath: this.sanatizedName,
            key: `${this.sanatizedName}-application-key`
        });
        newAppManifest.c8y.cli = newAppManifest.c8y.cli || {};
        if (this.getOption('url')) {
            Object.assign(newAppManifest.c8y.cli, {
                url: this.getOption('url')
            });
        }
        // remove the main entry as it leads to warnings
        delete newAppManifest.main;
        console.debug(`\t- going to write json now`);
        await (0, fs_extra_1.writeJson)(newAppManifestPath, newAppManifest, { spaces: 2 });
        console.debug(`\t- json written`);
    }
    async getValidPackageVersion(packageName, desiredVersion) {
        if (this.getOption('ci')) {
            console.debug(`\t- Not checking version for package: "${packageName}", using desired version: "${desiredVersion}"`);
            return desiredVersion;
        }
        console.debug(`\t- Retrieving valid version for Package: "${packageName}", desired version: "${desiredVersion}"`);
        try {
            await pacote.manifest(`${packageName}@${desiredVersion}`, {
                registry: this.registry
            });
            return desiredVersion;
        }
        catch (e) {
            console.debug(`\t\t- not available in version: "${desiredVersion}"`);
            console.debug(e);
        }
        try {
            const latestPackage = await pacote.manifest(packageName, { registry: this.registry });
            return latestPackage.version;
        }
        catch (e) {
            console.debug(`\t\t- not available, falling back to version "${desiredVersion}"`);
            console.debug(e);
        }
        return desiredVersion;
    }
}
exports.ScaffoldCommand = ScaffoldCommand;
//# sourceMappingURL=ScaffoldCommand.js.map