"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVersion = exports.getSharedDependencies = void 0;
const path = require("path");
const fs = require("fs-extra");
const _ = require("lodash");
// I know this looks wired, but it's for testing and seems to be an accepted approach:
// Base problem is: You cannot mock require calls in Jest.
// https://stackoverflow.com/questions/39755439/how-to-mock-imported-named-function-in-jest-when-module-is-unmocked/65243744#65243744
const federationUtils = require("./federationUtils");
const chalk_1 = require("chalk");
const excludedSubDependencies = [];
const excludedDependenciesObj = {
    'libphonenumber-js': true,
    'zone.js': true
};
const dontResolveVersion = {
    rxjs: true
};
const snapshotRegexp = new RegExp(/-SNAPSHOT$/);
function getSharedDependencies(env) {
    const rootPackageJsonPath = getRootPackageJsonPath(env);
    const sharedDependenciesFromPackageJson = resolveDependencies(path.resolve(rootPackageJsonPath, 'package.json'));
    const dependencies = Object.keys(sharedDependenciesFromPackageJson)
        .map(key => {
        let version;
        if (excludedDependenciesObj[key]) {
            return undefined;
        }
        try {
            version = federationUtils.getVersion(key, sharedDependenciesFromPackageJson);
        }
        catch (ex) {
            console.warn(`${chalk_1.default.yellow('Warning')}: Dependency ${key} cannot be resolved for module federation sharing.`);
            return undefined;
        }
        // remove -SNAPSHOT extension of c8y package versions to allow module federation with SNAPSHOT versions
        if (key.startsWith('@c8y/') && snapshotRegexp.test(version)) {
            version = version.replace(snapshotRegexp, '');
        }
        return {
            name: key,
            version,
            pkgJsonVersion: sharedDependenciesFromPackageJson[key],
            path: path.dirname(require.resolve(`${key}/package.json`))
        };
    })
        .filter(Boolean);
    const dependenciesWithSubmodules = getDependenciesWithSubmodules(dependencies);
    const flatDependenciesListWithSubmodules = transformDependenciesWithSubmodules(dependenciesWithSubmodules, env.federation === 'strict');
    return flatDependenciesListWithSubmodules;
}
exports.getSharedDependencies = getSharedDependencies;
function getVersion(depKey, sharedDependenciesFromPackageJson) {
    if (dontResolveVersion[depKey]) {
        return sharedDependenciesFromPackageJson[depKey];
    }
    return require(`${depKey}/package.json`).version;
}
exports.getVersion = getVersion;
function getRootPackageJsonPath(env) {
    const cwd = /\.\m?[j|t]s$/.test(env.entry) ? path.dirname(env.entry) : env.entry;
    let pathToPackageJson = cwd;
    while (!fs.existsSync(path.resolve(pathToPackageJson, 'package.json'))) {
        pathToPackageJson = path.resolve(pathToPackageJson, '..');
        if (pathToPackageJson === path.resolve('/')) {
            throw new Error(`No package.json could be resolved from the entry ${env.entry}`);
        }
    }
    return pathToPackageJson;
}
function resolveDependencies(filePath) {
    const packageJson = fs.readJsonSync(filePath);
    let dependencies = packageJson.dependencies;
    // In our mono-repo the dependencies are in a folder one level up.
    try {
        const parentPath = path.join(filePath, '..', '..', 'package.json');
        if (fileExist(parentPath)) {
            const packageParentJson = fs.readJsonSync(parentPath);
            if (packageParentJson.name === '@c8y/apps') {
                dependencies = packageParentJson.dependencies;
            }
        }
    }
    catch (ex) {
        dependencies = packageJson.dependencies;
    }
    // ngx-components sadly has atm it's own dependencies (should be shared dependencies)
    // the following function resolves them to also share them in a module federation setup.
    const ngxComponentsDependencies = resolveDependenciesFromNgxComponents() || {};
    return Object.assign(Object.assign({}, ngxComponentsDependencies), (dependencies || {}));
}
function fileExist(filePath) {
    return fs.existsSync(filePath);
}
function resolveDependenciesFromNgxComponents() {
    const pathToNgxComponents = require.resolve('@c8y/ngx-components/package.json');
    if (fileExist(pathToNgxComponents)) {
        const packageJson = fs.readJsonSync(pathToNgxComponents);
        return packageJson.dependencies;
    }
}
function getDependenciesWithSubmodules(dependenciesWithResolvedPaths) {
    return dependenciesWithResolvedPaths.map(resolvedDependency => {
        const { path: depPath } = resolvedDependency;
        let submodules = getRawSubmodules(depPath);
        if (resolvedDependency.name.match('ngx-components')) {
            // getC8ySubmoduleName transforms ngx-components submodules names into @c8y/ngx-components/... form.
            submodules = submodules.map(submodule => getC8ySubmoduleName(submodule, 'ngx-components'));
        }
        if (submodules.length > 0) {
            return { dependency: resolvedDependency, submodules };
        }
        return { dependency: resolvedDependency };
    });
}
function transformDependenciesWithSubmodules(dependenciesWithSubmodules, strictVersion) {
    return _.reduce(dependenciesWithSubmodules, (allDependenciesObj, currentVal) => {
        const { dependency: { name, version, pkgJsonVersion }, submodules } = currentVal;
        // Sometimes resolving errors could lead to the original version. To avoid issues, we remove the ^ or ~
        const cleanVersion = cleanVersionPrefix(version);
        const sharedDependencyDef = {
            requiredVersion: getRequiredVersionPrefix(name, version, pkgJsonVersion) + cleanVersion,
            singleton: true,
            strictVersion,
            version: cleanVersion
        };
        allDependenciesObj[name] = sharedDependencyDef;
        if (submodules) {
            submodules.forEach(submodule => {
                allDependenciesObj[submodule] = sharedDependencyDef;
            });
        }
        return allDependenciesObj;
    }, {});
}
function cleanVersionPrefix(version) {
    return version.replace('^', '').replace('~', '');
}
function getRequiredVersionPrefix(dependency, version, originalVersion) {
    if (originalVersion.startsWith('^') || originalVersion.startsWith('~')) {
        return originalVersion[0];
    }
    if (dependency.startsWith('@c8y')) {
        return '^';
    }
    return '~';
}
function getC8ySubmoduleName(submodule, submoduleName) {
    const tokens = submodule.split('/');
    const index = tokens.indexOf(submoduleName);
    const ngxComponentsSubmodule = tokens.slice(index + 1, tokens.length).join('/');
    return `@c8y/ngx-components/${ngxComponentsSubmodule}`;
}
function getRawSubmodules(depResolvedPath) {
    return findSecondaries(depResolvedPath, excludedSubDependencies)
        .filter(submodule => isDistFolderDependency(submodule))
        .map(submodule => getSubmoduleNestedUpToFourLevelsDeep(submodule));
}
function isDistFolderDependency(submodule) {
    return !submodule.match('/dist');
}
function getSubmoduleNestedUpToFourLevelsDeep(submodule) {
    // i.e. cumulocity-ui/packages/ngx-components/binary-file-download
    // TODO find better way of getting submodule name
    const splitedSubmodulePath = submodule.split('/');
    return _.takeRight(splitedSubmodulePath, 4).join('/');
}
/**
 * Source:
 * https://github.com/angular-architects/module-federation-plugin/blob/790d0e4a20c54b570267c036ddd20154556e959d/libs/mf/src/utils/share-utils.ts#L49
 */
function findSecondaries(libPath, excludes) {
    const acc = [];
    _findSecondaries(libPath, excludes, acc);
    return acc;
}
function _findSecondaries(libPath, excludes, acc) {
    const files = fs.readdirSync(libPath);
    const dirs = files
        .map(f => path.join(libPath, f))
        .filter(f => fs.lstatSync(f).isDirectory() && f !== 'node_modules');
    const secondaries = dirs.filter(d => fs.existsSync(path.join(d, 'package.json')));
    for (const s of secondaries) {
        const secondaryLibName = s.replace(/\\/g, '/').replace(/^.*node_modules[/]/, '');
        if (excludes.includes(secondaryLibName)) {
            continue;
        }
        acc.push(secondaryLibName);
        _findSecondaries(s, excludes, acc);
    }
}
//# sourceMappingURL=federationUtils.js.map