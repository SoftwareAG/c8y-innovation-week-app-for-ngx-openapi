"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleFederationExports = void 0;
const federationUtils_1 = require("../../utils/federationUtils");
const path = require("path");
const lodash_1 = require("lodash");
function getModuleFederationExports(env) {
    if (env.federation === 'none') {
        return;
    }
    let mf;
    try {
        mf = require('webpack/lib/container/ModuleFederationPlugin');
    }
    catch (ex) {
        console.warn('Could not load ModuleFederationPlugin', ex);
        return;
    }
    let shared;
    if (!env.federation || env.federation === 'auto' || env.federation === 'strict') {
        shared = (0, federationUtils_1.getSharedDependencies)(env);
    }
    else {
        shared = env.federation;
    }
    if (env.app.exports) {
        return new mf({
            name: env.app.contextPath,
            library: { type: 'var', name: (0, lodash_1.camelCase)(env.app.contextPath) },
            filename: 'remoteEntry.js',
            exposes: getExportedModules(env),
            shared
        });
    }
    return new mf({
        remoteType: 'var',
        shared
    });
}
exports.getModuleFederationExports = getModuleFederationExports;
function getExportedModules(env) {
    return env.app.exports.map(exp => mapExports(exp, env));
}
function mapExports(exp, env) {
    const relativeEntryPath = path.resolve(env.entry.replace(process.cwd(), ''));
    let pathToExport = path.resolve(relativeEntryPath, exp.path);
    try {
        pathToExport = require.resolve(exp.path + '/index.ts');
    }
    catch (ex) {
        try {
            pathToExport = require.resolve(exp.path);
        }
        catch (ex) {
            // intended empty
        }
    }
    return { [exp.module || exp.name]: pathToExport };
}
//# sourceMappingURL=federation.js.map